/* automatically generated by rust-bindgen 0.64.0 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const CTL_IMPL_MAJOR_VERSION: u32 = 1;
pub const CTL_IMPL_MINOR_VERSION: u32 = 1;
pub const CTL_MAX_DEVICE_NAME_LEN: u32 = 100;
pub const CTL_MAX_RESERVED_SIZE: u32 = 116;
pub const CTL_I2C_MAX_DATA_SIZE: u32 = 128;
pub const CTL_AUX_MAX_DATA_SIZE: u32 = 132;
pub const CTL_MAX_NUM_SAMPLES_PER_CHANNEL_1D_LUT: u32 = 8192;
pub const CTL_FAN_TEMP_SPEED_PAIR_COUNT: u32 = 32;
pub const CTL_PSU_COUNT: u32 = 5;
pub const CTL_FAN_COUNT: u32 = 5;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type max_align_t = f64;
#[doc = "\n @brief Supported initialization flags"]
pub type ctl_init_flags_t = u32;
#[doc = "< Use Level0 or not. This is usually required for telemetry,\n< performance, frequency related APIs"]
pub const _ctl_init_flag_t_CTL_INIT_FLAG_USE_LEVEL_ZERO: _ctl_init_flag_t = 1;
pub const _ctl_init_flag_t_CTL_INIT_FLAG_MAX: _ctl_init_flag_t = -2147483648;
pub type _ctl_init_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_init_flag_t as ctl_init_flag_t;
#[doc = "\n @brief Version information"]
pub type ctl_version_info_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_api_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a control API instance"]
pub type ctl_api_handle_t = *mut _ctl_api_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_device_adapter_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a device adapter instance"]
pub type ctl_device_adapter_handle_t = *mut _ctl_device_adapter_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_temp_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a device temperature sensor"]
pub type ctl_temp_handle_t = *mut _ctl_temp_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_freq_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle for a device frequency domain"]
pub type ctl_freq_handle_t = *mut _ctl_freq_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pwr_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a power device."]
pub type ctl_pwr_handle_t = *mut _ctl_pwr_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_fan_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a device fan"]
pub type ctl_fan_handle_t = *mut _ctl_fan_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_mem_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a device memory module"]
pub type ctl_mem_handle_t = *mut _ctl_mem_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_engine_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a device engine group"]
pub type ctl_engine_handle_t = *mut _ctl_engine_handle_t;
#[doc = "\n @brief Base for all properties types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_base_interface_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
}
#[test]
fn bindgen_test_layout__ctl_base_interface_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_base_interface_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_base_interface_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ctl_base_interface_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_base_interface_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_base_interface_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_base_interface_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_base_interface_t),
            "::",
            stringify!(Version)
        )
    );
}
#[doc = "\n @brief Base for all properties types"]
pub type ctl_base_interface_t = _ctl_base_interface_t;
#[doc = "< Boolean"]
pub const _ctl_property_value_type_t_CTL_PROPERTY_VALUE_TYPE_BOOL: _ctl_property_value_type_t = 0;
#[doc = "< Float"]
pub const _ctl_property_value_type_t_CTL_PROPERTY_VALUE_TYPE_FLOAT: _ctl_property_value_type_t = 1;
#[doc = "< Int32"]
pub const _ctl_property_value_type_t_CTL_PROPERTY_VALUE_TYPE_INT32: _ctl_property_value_type_t = 2;
#[doc = "< Unsigned Int32"]
pub const _ctl_property_value_type_t_CTL_PROPERTY_VALUE_TYPE_UINT32: _ctl_property_value_type_t = 3;
#[doc = "< Enum"]
pub const _ctl_property_value_type_t_CTL_PROPERTY_VALUE_TYPE_ENUM: _ctl_property_value_type_t = 4;
#[doc = "< Custom argument"]
pub const _ctl_property_value_type_t_CTL_PROPERTY_VALUE_TYPE_CUSTOM: _ctl_property_value_type_t = 5;
pub const _ctl_property_value_type_t_CTL_PROPERTY_VALUE_TYPE_MAX: _ctl_property_value_type_t = 6;
#[doc = "\n @brief Value type"]
pub type _ctl_property_value_type_t = ::std::os::raw::c_int;
#[doc = "\n @brief Value type"]
pub use self::_ctl_property_value_type_t as ctl_property_value_type_t;
#[doc = "\n @brief Property range details, a generic struct to hold min/max/step size\n        information of various feature properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_property_range_info_t {
    #[doc = "< [out] Minimum possible value"]
    pub min_possible_value: f32,
    #[doc = "< [out] Maximum possible value"]
    pub max_possible_value: f32,
    #[doc = "< [out] Step size possible"]
    pub step_size: f32,
    #[doc = "< [out] Default value"]
    pub default_value: f32,
}
#[test]
fn bindgen_test_layout__ctl_property_range_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_property_range_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_property_range_info_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ctl_property_range_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_property_range_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_property_range_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_possible_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_range_info_t),
            "::",
            stringify!(min_possible_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_possible_value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_range_info_t),
            "::",
            stringify!(max_possible_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_range_info_t),
            "::",
            stringify!(step_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_range_info_t),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = "\n @brief Property range details, a generic struct to hold min/max/step size\n        information of various feature properties"]
pub type ctl_property_range_info_t = _ctl_property_range_info_t;
#[doc = "\n @brief Property range details of integer type, a generic struct to hold\n        min/max/step size information of various feature properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_property_range_info_int_t {
    #[doc = "< [out] Minimum possible value"]
    pub min_possible_value: i32,
    #[doc = "< [out] Maximum possible value"]
    pub max_possible_value: i32,
    #[doc = "< [out] Step size possible"]
    pub step_size: i32,
    #[doc = "< [out] Default value"]
    pub default_value: i32,
}
#[test]
fn bindgen_test_layout__ctl_property_range_info_int_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_property_range_info_int_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_property_range_info_int_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ctl_property_range_info_int_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_property_range_info_int_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_property_range_info_int_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_possible_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_range_info_int_t),
            "::",
            stringify!(min_possible_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_possible_value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_range_info_int_t),
            "::",
            stringify!(max_possible_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_range_info_int_t),
            "::",
            stringify!(step_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_range_info_int_t),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = "\n @brief Property range details of integer type, a generic struct to hold\n        min/max/step size information of various feature properties"]
pub type ctl_property_range_info_int_t = _ctl_property_range_info_int_t;
#[doc = "\n @brief Property range details of unsigned integer type, a generic struct to\n        hold min/max/step size information of various feature properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_property_range_info_uint_t {
    #[doc = "< [out] Minimum possible value"]
    pub min_possible_value: u32,
    #[doc = "< [out] Maximum possible value"]
    pub max_possible_value: u32,
    #[doc = "< [out] Step size possible"]
    pub step_size: u32,
    #[doc = "< [out] Default value"]
    pub default_value: u32,
}
#[test]
fn bindgen_test_layout__ctl_property_range_info_uint_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_property_range_info_uint_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_property_range_info_uint_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ctl_property_range_info_uint_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_property_range_info_uint_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_property_range_info_uint_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_possible_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_range_info_uint_t),
            "::",
            stringify!(min_possible_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_possible_value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_range_info_uint_t),
            "::",
            stringify!(max_possible_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_range_info_uint_t),
            "::",
            stringify!(step_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_range_info_uint_t),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = "\n @brief Property range details of unsigned integer type, a generic struct to\n        hold min/max/step size information of various feature properties"]
pub type ctl_property_range_info_uint_t = _ctl_property_range_info_uint_t;
#[doc = "\n @brief Bool feature details"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_property_info_boolean_t {
    #[doc = "< [out] Default state"]
    pub DefaultState: bool,
}
#[test]
fn bindgen_test_layout__ctl_property_info_boolean_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_property_info_boolean_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_property_info_boolean_t>(),
        1usize,
        concat!("Size of: ", stringify!(_ctl_property_info_boolean_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_property_info_boolean_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ctl_property_info_boolean_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DefaultState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_info_boolean_t),
            "::",
            stringify!(DefaultState)
        )
    );
}
#[doc = "\n @brief Bool feature details"]
pub type ctl_property_info_boolean_t = _ctl_property_info_boolean_t;
#[doc = "\n @brief Bool feature for get/set"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_property_boolean_t {
    #[doc = "< [in,out] Enable"]
    pub Enable: bool,
}
#[test]
fn bindgen_test_layout__ctl_property_boolean_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_property_boolean_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_property_boolean_t>(),
        1usize,
        concat!("Size of: ", stringify!(_ctl_property_boolean_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_property_boolean_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ctl_property_boolean_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_boolean_t),
            "::",
            stringify!(Enable)
        )
    );
}
#[doc = "\n @brief Bool feature for get/set"]
pub type ctl_property_boolean_t = _ctl_property_boolean_t;
#[doc = "\n @brief Enumeration feature details"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_property_info_enum_t {
    #[doc = "< [out] Supported possible values represented as a bitmask"]
    pub SupportedTypes: u64,
    #[doc = "< [out] Default type"]
    pub DefaultType: u32,
}
#[test]
fn bindgen_test_layout__ctl_property_info_enum_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_property_info_enum_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_property_info_enum_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ctl_property_info_enum_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_property_info_enum_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_property_info_enum_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportedTypes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_info_enum_t),
            "::",
            stringify!(SupportedTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DefaultType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_info_enum_t),
            "::",
            stringify!(DefaultType)
        )
    );
}
#[doc = "\n @brief Enumeration feature details"]
pub type ctl_property_info_enum_t = _ctl_property_info_enum_t;
#[doc = "\n @brief Enumeration feature for get/set"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_property_enum_t {
    #[doc = "< [in,out] Enable with specific type"]
    pub EnableType: u32,
}
#[test]
fn bindgen_test_layout__ctl_property_enum_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_property_enum_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_property_enum_t>(),
        4usize,
        concat!("Size of: ", stringify!(_ctl_property_enum_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_property_enum_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_property_enum_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnableType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_enum_t),
            "::",
            stringify!(EnableType)
        )
    );
}
#[doc = "\n @brief Enumeration feature for get/set"]
pub type ctl_property_enum_t = _ctl_property_enum_t;
#[doc = "\n @brief Float feature details"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_property_info_float_t {
    #[doc = "< [in,out] DefaultEnable"]
    pub DefaultEnable: bool,
    #[doc = "< [out] Min/max/default/step details"]
    pub RangeInfo: ctl_property_range_info_t,
}
#[test]
fn bindgen_test_layout__ctl_property_info_float_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_property_info_float_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_property_info_float_t>(),
        20usize,
        concat!("Size of: ", stringify!(_ctl_property_info_float_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_property_info_float_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_property_info_float_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DefaultEnable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_info_float_t),
            "::",
            stringify!(DefaultEnable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RangeInfo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_info_float_t),
            "::",
            stringify!(RangeInfo)
        )
    );
}
#[doc = "\n @brief Float feature details"]
pub type ctl_property_info_float_t = _ctl_property_info_float_t;
#[doc = "\n @brief Float feature for get/set"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_property_float_t {
    #[doc = "< [in,out] Enable"]
    pub Enable: bool,
    #[doc = "< [in,out] Value"]
    pub Value: f32,
}
#[test]
fn bindgen_test_layout__ctl_property_float_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_property_float_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_property_float_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ctl_property_float_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_property_float_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_property_float_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_float_t),
            "::",
            stringify!(Enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_float_t),
            "::",
            stringify!(Value)
        )
    );
}
#[doc = "\n @brief Float feature for get/set"]
pub type ctl_property_float_t = _ctl_property_float_t;
#[doc = "\n @brief Int32 feature details"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_property_info_int_t {
    #[doc = "< [in,out] DefaultEnable"]
    pub DefaultEnable: bool,
    #[doc = "< [out] Min/max/default/step details"]
    pub RangeInfo: ctl_property_range_info_int_t,
}
#[test]
fn bindgen_test_layout__ctl_property_info_int_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_property_info_int_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_property_info_int_t>(),
        20usize,
        concat!("Size of: ", stringify!(_ctl_property_info_int_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_property_info_int_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_property_info_int_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DefaultEnable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_info_int_t),
            "::",
            stringify!(DefaultEnable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RangeInfo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_info_int_t),
            "::",
            stringify!(RangeInfo)
        )
    );
}
#[doc = "\n @brief Int32 feature details"]
pub type ctl_property_info_int_t = _ctl_property_info_int_t;
#[doc = "\n @brief Int32 feature for get/set"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_property_int_t {
    #[doc = "< [in,out] Enable"]
    pub Enable: bool,
    #[doc = "< [in,out] Value"]
    pub Value: i32,
}
#[test]
fn bindgen_test_layout__ctl_property_int_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_property_int_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_property_int_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ctl_property_int_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_property_int_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_property_int_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_int_t),
            "::",
            stringify!(Enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_int_t),
            "::",
            stringify!(Value)
        )
    );
}
#[doc = "\n @brief Int32 feature for get/set"]
pub type ctl_property_int_t = _ctl_property_int_t;
#[doc = "\n @brief Int32 feature details"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_property_info_uint_t {
    #[doc = "< [in,out] DefaultEnable"]
    pub DefaultEnable: bool,
    #[doc = "< [out] Min/max/default/step details"]
    pub RangeInfo: ctl_property_range_info_uint_t,
}
#[test]
fn bindgen_test_layout__ctl_property_info_uint_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_property_info_uint_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_property_info_uint_t>(),
        20usize,
        concat!("Size of: ", stringify!(_ctl_property_info_uint_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_property_info_uint_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_property_info_uint_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DefaultEnable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_info_uint_t),
            "::",
            stringify!(DefaultEnable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RangeInfo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_info_uint_t),
            "::",
            stringify!(RangeInfo)
        )
    );
}
#[doc = "\n @brief Int32 feature details"]
pub type ctl_property_info_uint_t = _ctl_property_info_uint_t;
#[doc = "\n @brief Int32 feature for get/set"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_property_uint_t {
    #[doc = "< [in,out] Enable"]
    pub Enable: bool,
    #[doc = "< [in,out] Value"]
    pub Value: u32,
}
#[test]
fn bindgen_test_layout__ctl_property_uint_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_property_uint_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_property_uint_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ctl_property_uint_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_property_uint_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_property_uint_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_uint_t),
            "::",
            stringify!(Enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_uint_t),
            "::",
            stringify!(Value)
        )
    );
}
#[doc = "\n @brief Int32 feature for get/set"]
pub type ctl_property_uint_t = _ctl_property_uint_t;
#[doc = "\n @brief Feature element details, union of bool/float/enum property_info\n        structs. Used for feature specific capability check"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ctl_property_info_t {
    #[doc = "< [in,out] Boolean type fields"]
    pub BoolType: ctl_property_info_boolean_t,
    #[doc = "< [in,out] Float type fields"]
    pub FloatType: ctl_property_info_float_t,
    #[doc = "< [in,out] Int type fields"]
    pub IntType: ctl_property_info_int_t,
    #[doc = "< [in,out] Enum type fields"]
    pub EnumType: ctl_property_info_enum_t,
    #[doc = "< [in,out] Unsigned Int type fields"]
    pub UIntType: ctl_property_info_uint_t,
}
#[test]
fn bindgen_test_layout__ctl_property_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_property_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_property_info_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_property_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_property_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_property_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BoolType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_info_t),
            "::",
            stringify!(BoolType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FloatType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_info_t),
            "::",
            stringify!(FloatType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IntType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_info_t),
            "::",
            stringify!(IntType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnumType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_info_t),
            "::",
            stringify!(EnumType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UIntType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_info_t),
            "::",
            stringify!(UIntType)
        )
    );
}
#[doc = "\n @brief Feature element details, union of bool/float/enum property_info\n        structs. Used for feature specific capability check"]
pub type ctl_property_info_t = _ctl_property_info_t;
#[doc = "\n @brief Feature element details, union of bool/float/enum property structs.\n        Used for get/set calls"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ctl_property_t {
    #[doc = "< [in,out] Boolean type fields"]
    pub BoolType: ctl_property_boolean_t,
    #[doc = "< [in,out] Float type fields"]
    pub FloatType: ctl_property_float_t,
    #[doc = "< [in,out] Int type fields"]
    pub IntType: ctl_property_int_t,
    #[doc = "< [in,out] Enum type fields"]
    pub EnumType: ctl_property_enum_t,
    #[doc = "< [in,out] Unsigned Int type fields"]
    pub UIntType: ctl_property_uint_t,
}
#[test]
fn bindgen_test_layout__ctl_property_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_property_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_property_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ctl_property_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_property_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_property_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BoolType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_t),
            "::",
            stringify!(BoolType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FloatType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_t),
            "::",
            stringify!(FloatType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IntType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_t),
            "::",
            stringify!(IntType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnumType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_t),
            "::",
            stringify!(EnumType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UIntType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_property_t),
            "::",
            stringify!(UIntType)
        )
    );
}
#[doc = "\n @brief Feature element details, union of bool/float/enum property structs.\n        Used for get/set calls"]
pub type ctl_property_t = _ctl_property_t;
#[doc = "< success"]
pub const _ctl_result_t_CTL_RESULT_SUCCESS: _ctl_result_t = 0;
#[doc = "< success but still open by another caller"]
pub const _ctl_result_t_CTL_RESULT_SUCCESS_STILL_OPEN_BY_ANOTHER_CALLER: _ctl_result_t = 1;
#[doc = "< \"Success group error code end value, not to be used\n< \""]
pub const _ctl_result_t_CTL_RESULT_ERROR_SUCCESS_END: _ctl_result_t = 65535;
#[doc = "< Generic error code starting value, not to be used"]
pub const _ctl_result_t_CTL_RESULT_ERROR_GENERIC_START: _ctl_result_t = 1073741824;
#[doc = "< Result not initialized"]
pub const _ctl_result_t_CTL_RESULT_ERROR_NOT_INITIALIZED: _ctl_result_t = 1073741825;
#[doc = "< Already initialized"]
pub const _ctl_result_t_CTL_RESULT_ERROR_ALREADY_INITIALIZED: _ctl_result_t = 1073741826;
#[doc = "< Device hung, reset, was removed, or driver update occurred"]
pub const _ctl_result_t_CTL_RESULT_ERROR_DEVICE_LOST: _ctl_result_t = 1073741827;
#[doc = "< Insufficient host memory to satisfy call"]
pub const _ctl_result_t_CTL_RESULT_ERROR_OUT_OF_HOST_MEMORY: _ctl_result_t = 1073741828;
#[doc = "< Insufficient device memory to satisfy call"]
pub const _ctl_result_t_CTL_RESULT_ERROR_OUT_OF_DEVICE_MEMORY: _ctl_result_t = 1073741829;
#[doc = "< Access denied due to permission level"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS: _ctl_result_t = 1073741830;
#[doc = "< Resource was removed"]
pub const _ctl_result_t_CTL_RESULT_ERROR_NOT_AVAILABLE: _ctl_result_t = 1073741831;
#[doc = "< Library not initialized"]
pub const _ctl_result_t_CTL_RESULT_ERROR_UNINITIALIZED: _ctl_result_t = 1073741832;
#[doc = "< Generic error code for unsupported versions"]
pub const _ctl_result_t_CTL_RESULT_ERROR_UNSUPPORTED_VERSION: _ctl_result_t = 1073741833;
#[doc = "< Generic error code for unsupported features"]
pub const _ctl_result_t_CTL_RESULT_ERROR_UNSUPPORTED_FEATURE: _ctl_result_t = 1073741834;
#[doc = "< Generic error code for invalid arguments"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INVALID_ARGUMENT: _ctl_result_t = 1073741835;
#[doc = "< API handle in invalid"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INVALID_API_HANDLE: _ctl_result_t = 1073741836;
#[doc = "< Handle argument is not valid"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INVALID_NULL_HANDLE: _ctl_result_t = 1073741837;
#[doc = "< Pointer argument may not be nullptr"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INVALID_NULL_POINTER: _ctl_result_t = 1073741838;
#[doc = "< Size argument is invalid (e.g., must not be zero)"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INVALID_SIZE: _ctl_result_t = 1073741839;
#[doc = "< Size argument is not supported by the device (e.g., too large)"]
pub const _ctl_result_t_CTL_RESULT_ERROR_UNSUPPORTED_SIZE: _ctl_result_t = 1073741840;
#[doc = "< Image format is not supported by the device"]
pub const _ctl_result_t_CTL_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT: _ctl_result_t = 1073741841;
#[doc = "< Data read error"]
pub const _ctl_result_t_CTL_RESULT_ERROR_DATA_READ: _ctl_result_t = 1073741842;
#[doc = "< Data write error"]
pub const _ctl_result_t_CTL_RESULT_ERROR_DATA_WRITE: _ctl_result_t = 1073741843;
#[doc = "< Data not found error"]
pub const _ctl_result_t_CTL_RESULT_ERROR_DATA_NOT_FOUND: _ctl_result_t = 1073741844;
#[doc = "< Function not implemented"]
pub const _ctl_result_t_CTL_RESULT_ERROR_NOT_IMPLEMENTED: _ctl_result_t = 1073741845;
#[doc = "< Operating system call failure"]
pub const _ctl_result_t_CTL_RESULT_ERROR_OS_CALL: _ctl_result_t = 1073741846;
#[doc = "< Kernel mode driver call failure"]
pub const _ctl_result_t_CTL_RESULT_ERROR_KMD_CALL: _ctl_result_t = 1073741847;
#[doc = "< Library unload failure"]
pub const _ctl_result_t_CTL_RESULT_ERROR_UNLOAD: _ctl_result_t = 1073741848;
#[doc = "< Level0 loader not found"]
pub const _ctl_result_t_CTL_RESULT_ERROR_ZE_LOADER: _ctl_result_t = 1073741849;
#[doc = "< Invalid operation type"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INVALID_OPERATION_TYPE: _ctl_result_t = 1073741850;
#[doc = "< Null OS interface"]
pub const _ctl_result_t_CTL_RESULT_ERROR_NULL_OS_INTERFACE: _ctl_result_t = 1073741851;
#[doc = "< Null OS adapter handle"]
pub const _ctl_result_t_CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE: _ctl_result_t = 1073741852;
#[doc = "< Null display output handle"]
pub const _ctl_result_t_CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE: _ctl_result_t = 1073741853;
#[doc = "< Timeout in Wait function"]
pub const _ctl_result_t_CTL_RESULT_ERROR_WAIT_TIMEOUT: _ctl_result_t = 1073741854;
#[doc = "< Persistance not supported"]
pub const _ctl_result_t_CTL_RESULT_ERROR_PERSISTANCE_NOT_SUPPORTED: _ctl_result_t = 1073741855;
#[doc = "< Platform not supported"]
pub const _ctl_result_t_CTL_RESULT_ERROR_PLATFORM_NOT_SUPPORTED: _ctl_result_t = 1073741856;
#[doc = "< Unknown Appplicaion UID in Initialization call"]
pub const _ctl_result_t_CTL_RESULT_ERROR_UNKNOWN_APPLICATION_UID: _ctl_result_t = 1073741857;
#[doc = "< The enum is not valid"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INVALID_ENUMERATION: _ctl_result_t = 1073741858;
#[doc = "< Error in file delete operation"]
pub const _ctl_result_t_CTL_RESULT_ERROR_FILE_DELETE: _ctl_result_t = 1073741859;
#[doc = "< The device requires a reset."]
pub const _ctl_result_t_CTL_RESULT_ERROR_RESET_DEVICE_REQUIRED: _ctl_result_t = 1073741860;
#[doc = "< The device requires a full reboot."]
pub const _ctl_result_t_CTL_RESULT_ERROR_FULL_REBOOT_REQUIRED: _ctl_result_t = 1073741861;
#[doc = "< Library load failure"]
pub const _ctl_result_t_CTL_RESULT_ERROR_LOAD: _ctl_result_t = 1073741862;
#[doc = "< Unknown or internal error"]
pub const _ctl_result_t_CTL_RESULT_ERROR_UNKNOWN: _ctl_result_t = 1073807359;
#[doc = "< Operation failed, retry previous operation again"]
pub const _ctl_result_t_CTL_RESULT_ERROR_RETRY_OPERATION: _ctl_result_t = 1073807360;
#[doc = "< \"Generic error code end value, not to be used\n< \""]
pub const _ctl_result_t_CTL_RESULT_ERROR_GENERIC_END: _ctl_result_t = 1073807359;
#[doc = "< Core error code starting value, not to be used"]
pub const _ctl_result_t_CTL_RESULT_ERROR_CORE_START: _ctl_result_t = 1140850688;
#[doc = "< The Overclock is not supported."]
pub const _ctl_result_t_CTL_RESULT_ERROR_CORE_OVERCLOCK_NOT_SUPPORTED: _ctl_result_t = 1140850689;
#[doc = "< The Voltage exceeds the acceptable min/max."]
pub const _ctl_result_t_CTL_RESULT_ERROR_CORE_OVERCLOCK_VOLTAGE_OUTSIDE_RANGE: _ctl_result_t =
    1140850690;
#[doc = "< The Frequency exceeds the acceptable min/max."]
pub const _ctl_result_t_CTL_RESULT_ERROR_CORE_OVERCLOCK_FREQUENCY_OUTSIDE_RANGE: _ctl_result_t =
    1140850691;
#[doc = "< The Power exceeds the acceptable min/max."]
pub const _ctl_result_t_CTL_RESULT_ERROR_CORE_OVERCLOCK_POWER_OUTSIDE_RANGE: _ctl_result_t =
    1140850692;
#[doc = "< The Power exceeds the acceptable min/max."]
pub const _ctl_result_t_CTL_RESULT_ERROR_CORE_OVERCLOCK_TEMPERATURE_OUTSIDE_RANGE: _ctl_result_t =
    1140850693;
#[doc = "< The Overclock is in voltage locked mode."]
pub const _ctl_result_t_CTL_RESULT_ERROR_CORE_OVERCLOCK_IN_VOLTAGE_LOCKED_MODE: _ctl_result_t =
    1140850694;
#[doc = "< It indicates that the requested change will not be applied until the\n< device is reset."]
pub const _ctl_result_t_CTL_RESULT_ERROR_CORE_OVERCLOCK_RESET_REQUIRED: _ctl_result_t = 1140850695;
#[doc = "< The $OverclockWaiverSet function has not been called."]
pub const _ctl_result_t_CTL_RESULT_ERROR_CORE_OVERCLOCK_WAIVER_NOT_SET: _ctl_result_t = 1140850696;
#[doc = "< \"Core error code end value, not to be used\n< \""]
pub const _ctl_result_t_CTL_RESULT_ERROR_CORE_END: _ctl_result_t = 71368703;
#[doc = "< 3D error code starting value, not to be used"]
pub const _ctl_result_t_CTL_RESULT_ERROR_3D_START: _ctl_result_t = 1610612736;
#[doc = "< \"3D error code end value, not to be used\n< \""]
pub const _ctl_result_t_CTL_RESULT_ERROR_3D_END: _ctl_result_t = 1610678271;
#[doc = "< Media error code starting value, not to be used"]
pub const _ctl_result_t_CTL_RESULT_ERROR_MEDIA_START: _ctl_result_t = 1342177280;
#[doc = "< \"Media error code end value, not to be used\n< \""]
pub const _ctl_result_t_CTL_RESULT_ERROR_MEDIA_END: _ctl_result_t = 1342242815;
#[doc = "< Display error code starting value, not to be used"]
pub const _ctl_result_t_CTL_RESULT_ERROR_DISPLAY_START: _ctl_result_t = 1207959552;
#[doc = "< Invalid flag for Aux access"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INVALID_AUX_ACCESS_FLAG: _ctl_result_t = 1207959553;
#[doc = "< Invalid flag for Sharpness"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INVALID_SHARPNESS_FILTER_FLAG: _ctl_result_t = 1207959554;
#[doc = "< Error for Display not attached"]
pub const _ctl_result_t_CTL_RESULT_ERROR_DISPLAY_NOT_ATTACHED: _ctl_result_t = 1207959555;
#[doc = "< Error for display attached but not active"]
pub const _ctl_result_t_CTL_RESULT_ERROR_DISPLAY_NOT_ACTIVE: _ctl_result_t = 1207959556;
#[doc = "< Error for invalid power optimization flag"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INVALID_POWERFEATURE_OPTIMIZATION_FLAG: _ctl_result_t =
    1207959557;
#[doc = "< DPST is supported only in DC Mode"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INVALID_POWERSOURCE_TYPE_FOR_DPST: _ctl_result_t =
    1207959558;
#[doc = "< Invalid query type for pixel transformation get configuration"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INVALID_PIXTX_GET_CONFIG_QUERY_TYPE: _ctl_result_t =
    1207959559;
#[doc = "< Invalid operation type for pixel transformation set configuration"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INVALID_PIXTX_SET_CONFIG_OPERATION_TYPE: _ctl_result_t =
    1207959560;
#[doc = "< Invalid number of samples for pixel transformation set configuration"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INVALID_SET_CONFIG_NUMBER_OF_SAMPLES: _ctl_result_t =
    1207959561;
#[doc = "< Invalid block id for pixel transformation"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INVALID_PIXTX_BLOCK_ID: _ctl_result_t = 1207959562;
#[doc = "< Invalid block type for pixel transformation"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INVALID_PIXTX_BLOCK_TYPE: _ctl_result_t = 1207959563;
#[doc = "< Invalid block number for pixel transformation"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INVALID_PIXTX_BLOCK_NUMBER: _ctl_result_t = 1207959564;
#[doc = "< Insufficient memery allocated for BlockConfigs"]
pub const _ctl_result_t_CTL_RESULT_ERROR_INSUFFICIENT_PIXTX_BLOCK_CONFIG_MEMORY: _ctl_result_t =
    1207959565;
#[doc = "< Invalid pipe for 3dlut"]
pub const _ctl_result_t_CTL_RESULT_ERROR_3DLUT_INVALID_PIPE: _ctl_result_t = 1207959566;
#[doc = "< Invalid 3dlut data"]
pub const _ctl_result_t_CTL_RESULT_ERROR_3DLUT_INVALID_DATA: _ctl_result_t = 1207959567;
#[doc = "< 3dlut not supported in HDR"]
pub const _ctl_result_t_CTL_RESULT_ERROR_3DLUT_NOT_SUPPORTED_IN_HDR: _ctl_result_t = 1207959568;
#[doc = "< Invalid 3dlut operation"]
pub const _ctl_result_t_CTL_RESULT_ERROR_3DLUT_INVALID_OPERATION: _ctl_result_t = 1207959569;
#[doc = "< 3dlut call unsuccessful"]
pub const _ctl_result_t_CTL_RESULT_ERROR_3DLUT_UNSUCCESSFUL: _ctl_result_t = 1207959570;
#[doc = "< AUX defer failure"]
pub const _ctl_result_t_CTL_RESULT_ERROR_AUX_DEFER: _ctl_result_t = 1207959571;
#[doc = "< AUX timeout failure"]
pub const _ctl_result_t_CTL_RESULT_ERROR_AUX_TIMEOUT: _ctl_result_t = 1207959572;
#[doc = "< AUX incomplete write failure"]
pub const _ctl_result_t_CTL_RESULT_ERROR_AUX_INCOMPLETE_WRITE: _ctl_result_t = 1207959573;
#[doc = "< I2C/AUX unkonown failure"]
pub const _ctl_result_t_CTL_RESULT_ERROR_I2C_AUX_STATUS_UNKNOWN: _ctl_result_t = 1207959574;
#[doc = "< I2C/AUX unsuccessful"]
pub const _ctl_result_t_CTL_RESULT_ERROR_I2C_AUX_UNSUCCESSFUL: _ctl_result_t = 1207959575;
#[doc = "< Lace Incorrrect AggressivePercent data or LuxVsAggressive Map data\n< passed by user"]
pub const _ctl_result_t_CTL_RESULT_ERROR_LACE_INVALID_DATA_ARGUMENT_PASSED: _ctl_result_t =
    1207959576;
#[doc = "< External Display is Attached hence fail the Display Switch"]
pub const _ctl_result_t_CTL_RESULT_ERROR_EXTERNAL_DISPLAY_ATTACHED: _ctl_result_t = 1207959577;
#[doc = "< Standard custom mode exists"]
pub const _ctl_result_t_CTL_RESULT_ERROR_CUSTOM_MODE_STANDARD_CUSTOM_MODE_EXISTS: _ctl_result_t =
    1207959578;
#[doc = "< Non custom matching mode exists"]
pub const _ctl_result_t_CTL_RESULT_ERROR_CUSTOM_MODE_NON_CUSTOM_MATCHING_MODE_EXISTS:
    _ctl_result_t = 1207959579;
#[doc = "< Custom mode insufficent memory"]
pub const _ctl_result_t_CTL_RESULT_ERROR_CUSTOM_MODE_INSUFFICIENT_MEMORY: _ctl_result_t =
    1207959580;
#[doc = "< \"Display error code end value, not to be used\n< \""]
pub const _ctl_result_t_CTL_RESULT_ERROR_DISPLAY_END: _ctl_result_t = 1208025087;
pub const _ctl_result_t_CTL_RESULT_MAX: _ctl_result_t = 1208025088;
#[doc = "\n @brief Defines Return/Error codes.\n        All generic error (bit30) codes are between 0x40000000-0x4000FFFF.\n        All 3D (bit 29) specific error codes are between 0x60000000-0x6000FFFF.\n        All media (bit 28) specific error codes are between 0x50000000-0x5000FFFF.\n        All display (bit 27) specific error codes are between 0x48000000-0x4800FFFF\n        All core (bit 26) specific error codes are between 0x44000000-0x4400FFFF\n        Success result code with additional info are between 0x00000001-0x0000FFFF."]
pub type _ctl_result_t = ::std::os::raw::c_int;
#[doc = "\n @brief Defines Return/Error codes.\n        All generic error (bit30) codes are between 0x40000000-0x4000FFFF.\n        All 3D (bit 29) specific error codes are between 0x60000000-0x6000FFFF.\n        All media (bit 28) specific error codes are between 0x50000000-0x5000FFFF.\n        All display (bit 27) specific error codes are between 0x48000000-0x4800FFFF\n        All core (bit 26) specific error codes are between 0x44000000-0x4400FFFF\n        Success result code with additional info are between 0x00000001-0x0000FFFF."]
pub use self::_ctl_result_t as ctl_result_t;
#[doc = "< Type is Frequency with units in MHz."]
pub const _ctl_units_t_CTL_UNITS_FREQUENCY_MHZ: _ctl_units_t = 0;
#[doc = "< Type is Frequency with units in GT/s (gigatransfers per second)."]
pub const _ctl_units_t_CTL_UNITS_OPERATIONS_GTS: _ctl_units_t = 1;
#[doc = "< Type is Frequency with units in MT/s (megatransfers per second)."]
pub const _ctl_units_t_CTL_UNITS_OPERATIONS_MTS: _ctl_units_t = 2;
#[doc = "< Type is Voltage with units in Volts."]
pub const _ctl_units_t_CTL_UNITS_VOLTAGE_VOLTS: _ctl_units_t = 3;
#[doc = "< Type is Power with units in Watts."]
pub const _ctl_units_t_CTL_UNITS_POWER_WATTS: _ctl_units_t = 4;
#[doc = "< Type is Temperature with units in Celsius."]
pub const _ctl_units_t_CTL_UNITS_TEMPERATURE_CELSIUS: _ctl_units_t = 5;
#[doc = "< Type is Energy with units in Joules."]
pub const _ctl_units_t_CTL_UNITS_ENERGY_JOULES: _ctl_units_t = 6;
#[doc = "< Type is Time with units in Seconds."]
pub const _ctl_units_t_CTL_UNITS_TIME_SECONDS: _ctl_units_t = 7;
#[doc = "< Type is Memory with units in Bytes."]
pub const _ctl_units_t_CTL_UNITS_MEMORY_BYTES: _ctl_units_t = 8;
#[doc = "< Type is Angular Speed with units in Revolutions per Minute."]
pub const _ctl_units_t_CTL_UNITS_ANGULAR_SPEED_RPM: _ctl_units_t = 9;
#[doc = "< Type of units unknown."]
pub const _ctl_units_t_CTL_UNITS_UNKNOWN: _ctl_units_t = 1208025087;
pub const _ctl_units_t_CTL_UNITS_MAX: _ctl_units_t = 1208025088;
#[doc = "\n @brief General Physical Units."]
pub type _ctl_units_t = ::std::os::raw::c_int;
#[doc = "\n @brief General Physical Units."]
pub use self::_ctl_units_t as ctl_units_t;
#[doc = "< The data type is 8 bit signed integer."]
pub const _ctl_data_type_t_CTL_DATA_TYPE_INT8: _ctl_data_type_t = 0;
#[doc = "< The data type is 8 bit unsigned integer."]
pub const _ctl_data_type_t_CTL_DATA_TYPE_UINT8: _ctl_data_type_t = 1;
#[doc = "< The data type is 16 bit signed integer."]
pub const _ctl_data_type_t_CTL_DATA_TYPE_INT16: _ctl_data_type_t = 2;
#[doc = "< The data type is 16 bit unsigned integer."]
pub const _ctl_data_type_t_CTL_DATA_TYPE_UINT16: _ctl_data_type_t = 3;
#[doc = "< The data type is 32 bit signed integer."]
pub const _ctl_data_type_t_CTL_DATA_TYPE_INT32: _ctl_data_type_t = 4;
#[doc = "< The data type is 32 bit unsigned integer."]
pub const _ctl_data_type_t_CTL_DATA_TYPE_UINT32: _ctl_data_type_t = 5;
#[doc = "< The data type is 64 bit signed integer."]
pub const _ctl_data_type_t_CTL_DATA_TYPE_INT64: _ctl_data_type_t = 6;
#[doc = "< The data type is 64 bit unsigned integer."]
pub const _ctl_data_type_t_CTL_DATA_TYPE_UINT64: _ctl_data_type_t = 7;
#[doc = "< The data type is 32 bit floating point."]
pub const _ctl_data_type_t_CTL_DATA_TYPE_FLOAT: _ctl_data_type_t = 8;
#[doc = "< The data type is 64 bit floating point."]
pub const _ctl_data_type_t_CTL_DATA_TYPE_DOUBLE: _ctl_data_type_t = 9;
#[doc = "< The data type is an array of 8 bit unsigned integers."]
pub const _ctl_data_type_t_CTL_DATA_TYPE_STRING_ASCII: _ctl_data_type_t = 10;
#[doc = "< The data type is an array of 16 bit unsigned integers."]
pub const _ctl_data_type_t_CTL_DATA_TYPE_STRING_UTF16: _ctl_data_type_t = 11;
#[doc = "< The data type is an array of 32 bit unsigned integers."]
pub const _ctl_data_type_t_CTL_DATA_TYPE_STRING_UTF132: _ctl_data_type_t = 12;
#[doc = "< The data type is unknown."]
pub const _ctl_data_type_t_CTL_DATA_TYPE_UNKNOWN: _ctl_data_type_t = 1208025087;
pub const _ctl_data_type_t_CTL_DATA_TYPE_MAX: _ctl_data_type_t = 1208025088;
#[doc = "\n @brief General Data Types."]
pub type _ctl_data_type_t = ::std::os::raw::c_int;
#[doc = "\n @brief General Data Types."]
pub use self::_ctl_data_type_t as ctl_data_type_t;
#[doc = "\n @brief Union for Generic Data.\n\n @details\n     - The telemetry data items could be of different types.\n     - Refer to ::ctl_data_type_t to find the current type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ctl_data_value_t {
    #[doc = "< [out] The data type is 8 bit signed integer."]
    pub data8: i8,
    #[doc = "< [out] The data type is 8 bit unsigned integer."]
    pub datau8: u8,
    #[doc = "< [out] The data type is 16 bit signed integer."]
    pub data16: i16,
    #[doc = "< [out] The data type is 16 bit unsigned integer."]
    pub datau16: u16,
    #[doc = "< [out] The data type is 32 bit signed integer."]
    pub data32: i32,
    #[doc = "< [out] The data type is 32 bit unsigned integer."]
    pub datau32: u32,
    #[doc = "< [out] The data type is 64 bit signed integer."]
    pub data64: i64,
    #[doc = "< [out] The data type is 64 bit unsigned integer."]
    pub datau64: u64,
    #[doc = "< [out] The data type is 32 bit floating point."]
    pub datafloat: f32,
    #[doc = "< [out] The data type is 64 bit floating point."]
    pub datadouble: f64,
}
#[test]
fn bindgen_test_layout__ctl_data_value_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_data_value_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_data_value_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ctl_data_value_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_data_value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_data_value_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_data_value_t),
            "::",
            stringify!(data8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datau8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_data_value_t),
            "::",
            stringify!(datau8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_data_value_t),
            "::",
            stringify!(data16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datau16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_data_value_t),
            "::",
            stringify!(datau16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_data_value_t),
            "::",
            stringify!(data32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datau32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_data_value_t),
            "::",
            stringify!(datau32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_data_value_t),
            "::",
            stringify!(data64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datau64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_data_value_t),
            "::",
            stringify!(datau64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datafloat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_data_value_t),
            "::",
            stringify!(datafloat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datadouble) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_data_value_t),
            "::",
            stringify!(datadouble)
        )
    );
}
#[doc = "\n @brief Union for Generic Data.\n\n @details\n     - The telemetry data items could be of different types.\n     - Refer to ::ctl_data_type_t to find the current type."]
pub type ctl_data_value_t = _ctl_data_value_t;
#[doc = "\n @brief Base for all properties types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_base_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
}
#[test]
fn bindgen_test_layout__ctl_base_properties_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_base_properties_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_base_properties_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ctl_base_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_base_properties_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_base_properties_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_base_properties_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_base_properties_t),
            "::",
            stringify!(Version)
        )
    );
}
#[doc = "\n @brief Base for all properties types"]
pub type ctl_base_properties_t = _ctl_base_properties_t;
#[doc = "\n @brief Application Unique ID"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_application_id_t {
    #[doc = "< [in] Data1"]
    pub Data1: u32,
    #[doc = "< [in] Data2"]
    pub Data2: u16,
    #[doc = "< [in] Data3"]
    pub Data3: u16,
    #[doc = "< [in] Data4"]
    pub Data4: [u8; 8usize],
}
#[test]
fn bindgen_test_layout__ctl_application_id_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_application_id_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_application_id_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ctl_application_id_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_application_id_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_application_id_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_application_id_t),
            "::",
            stringify!(Data1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_application_id_t),
            "::",
            stringify!(Data2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data3) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_application_id_t),
            "::",
            stringify!(Data3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data4) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_application_id_t),
            "::",
            stringify!(Data4)
        )
    );
}
#[doc = "\n @brief Application Unique ID"]
pub type ctl_application_id_t = _ctl_application_id_t;
#[doc = "\n @brief Init arguments"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_init_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in][release] App's IGCL version"]
    pub AppVersion: ctl_version_info_t,
    #[doc = "< [in][release] Caller version"]
    pub flags: ctl_init_flags_t,
    #[doc = "< [out][release] IGCL implementation version"]
    pub SupportedVersion: ctl_version_info_t,
    #[doc = "< [in] Application Provided Unique ID.Application can pass all 0's as\n< the default ID"]
    pub ApplicationUID: ctl_application_id_t,
}
#[test]
fn bindgen_test_layout__ctl_init_args_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_init_args_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_init_args_t>(),
        36usize,
        concat!("Size of: ", stringify!(_ctl_init_args_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_init_args_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_init_args_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_init_args_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_init_args_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AppVersion) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_init_args_t),
            "::",
            stringify!(AppVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_init_args_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportedVersion) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_init_args_t),
            "::",
            stringify!(SupportedVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApplicationUID) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_init_args_t),
            "::",
            stringify!(ApplicationUID)
        )
    );
}
#[doc = "\n @brief Init arguments"]
pub type ctl_init_args_t = _ctl_init_args_t;
#[doc = "\n @brief Reserved struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_reserved_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Reserved struct"]
    pub pSpecialArg: *mut ::std::os::raw::c_void,
    #[doc = "< [in] struct size"]
    pub ArgSize: u32,
}
#[test]
fn bindgen_test_layout__ctl_reserved_args_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_reserved_args_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_reserved_args_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_reserved_args_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_reserved_args_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_reserved_args_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_reserved_args_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_reserved_args_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pSpecialArg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_reserved_args_t),
            "::",
            stringify!(pSpecialArg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ArgSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_reserved_args_t),
            "::",
            stringify!(ArgSize)
        )
    );
}
#[doc = "\n @brief Reserved struct"]
pub type ctl_reserved_args_t = _ctl_reserved_args_t;
#[doc = "\n @brief Reserved base struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_reserved_args_base_t {
    #[doc = "< [in] Unique ID for reserved/special function"]
    pub ReservedFuncID: ctl_application_id_t,
}
#[test]
fn bindgen_test_layout__ctl_reserved_args_base_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_reserved_args_base_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_reserved_args_base_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ctl_reserved_args_base_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_reserved_args_base_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_reserved_args_base_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFuncID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_reserved_args_base_t),
            "::",
            stringify!(ReservedFuncID)
        )
    );
}
#[doc = "\n @brief Reserved base struct"]
pub type ctl_reserved_args_base_t = _ctl_reserved_args_base_t;
#[doc = "\n @brief Reserved - Unlock function capability"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_unlock_capability_t {
    #[doc = "< [in] Unique ID for reserved/special function"]
    pub ReservedFuncID: ctl_application_id_t,
    #[doc = "< [in] Unique ID to unlock a specific function"]
    pub UnlockCapsID: ctl_application_id_t,
}
#[test]
fn bindgen_test_layout__ctl_unlock_capability_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_unlock_capability_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_unlock_capability_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ctl_unlock_capability_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_unlock_capability_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_unlock_capability_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFuncID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_unlock_capability_t),
            "::",
            stringify!(ReservedFuncID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnlockCapsID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_unlock_capability_t),
            "::",
            stringify!(UnlockCapsID)
        )
    );
}
#[doc = "\n @brief Reserved - Unlock function capability"]
pub type ctl_unlock_capability_t = _ctl_unlock_capability_t;
#[doc = "\n @brief Used by loader like modules to specify runtime implementation details"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_runtime_path_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Unique ID for reserved/special function"]
    pub UnlockID: ctl_application_id_t,
    #[doc = "< [in] Path to runtime DLL"]
    pub pRuntimePath: *mut wchar_t,
    #[doc = "< [in] Device ID of interest to caller. pRuntimePath should not be NULL."]
    pub DeviceID: u16,
    #[doc = "< [in] Revision ID of interest to caller. pRuntimePath should not be\n< NULL."]
    pub RevID: u8,
}
#[test]
fn bindgen_test_layout__ctl_runtime_path_args_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_runtime_path_args_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_runtime_path_args_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ctl_runtime_path_args_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_runtime_path_args_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_runtime_path_args_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_runtime_path_args_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_runtime_path_args_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UnlockID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_runtime_path_args_t),
            "::",
            stringify!(UnlockID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pRuntimePath) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_runtime_path_args_t),
            "::",
            stringify!(pRuntimePath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeviceID) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_runtime_path_args_t),
            "::",
            stringify!(DeviceID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RevID) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_runtime_path_args_t),
            "::",
            stringify!(RevID)
        )
    );
}
#[doc = "\n @brief Used by loader like modules to specify runtime implementation details"]
pub type ctl_runtime_path_args_t = _ctl_runtime_path_args_t;
extern "C" {
    #[doc = "\n @brief Control Api Init\n\n @details\n     - Control Api Init\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pInitDesc`\n         + `nullptr == phAPIHandle`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlInit(
        pInitDesc: *mut ctl_init_args_t,
        phAPIHandle: *mut ctl_api_handle_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Control Api Destroy\n\n @details\n     - Control Api Close\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hAPIHandle`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlClose(hAPIHandle: ctl_api_handle_t) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Runtime path\n\n @details\n     - Control Api set runtime path. Optional call from a loader which allows\n       the loaded runtime to enumerate only the adapters which the specified\n       runtime is responsible for. This is done usually by a loader or by\n       callers who know how to get the specific runtime of interest. This\n       call right now is reserved for use by Intel components.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlSetRuntimePath(pArgs: *mut ctl_runtime_path_args_t) -> ctl_result_t;
}
#[doc = "\n @brief Supported Functions"]
pub type ctl_supported_functions_flags_t = u32;
#[doc = "< [out] Is Display supported"]
pub const _ctl_supported_functions_flag_t_CTL_SUPPORTED_FUNCTIONS_FLAG_DISPLAY:
    _ctl_supported_functions_flag_t = 1;
#[doc = "< [out] Is 3D supported"]
pub const _ctl_supported_functions_flag_t_CTL_SUPPORTED_FUNCTIONS_FLAG_3D:
    _ctl_supported_functions_flag_t = 2;
#[doc = "< [out] Is Media supported"]
pub const _ctl_supported_functions_flag_t_CTL_SUPPORTED_FUNCTIONS_FLAG_MEDIA:
    _ctl_supported_functions_flag_t = 4;
pub const _ctl_supported_functions_flag_t_CTL_SUPPORTED_FUNCTIONS_FLAG_MAX:
    _ctl_supported_functions_flag_t = -2147483648;
pub type _ctl_supported_functions_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_supported_functions_flag_t as ctl_supported_functions_flag_t;
#[doc = "\n @brief Firmware version"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_firmware_version_t {
    #[doc = "< [out] Major version"]
    pub major_version: u64,
    #[doc = "< [out] Minor version"]
    pub minor_version: u64,
    #[doc = "< [out] Build number"]
    pub build_number: u64,
}
#[test]
fn bindgen_test_layout__ctl_firmware_version_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_firmware_version_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_firmware_version_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_firmware_version_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_firmware_version_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_firmware_version_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_firmware_version_t),
            "::",
            stringify!(major_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor_version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_firmware_version_t),
            "::",
            stringify!(minor_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).build_number) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_firmware_version_t),
            "::",
            stringify!(build_number)
        )
    );
}
#[doc = "\n @brief Firmware version"]
pub type ctl_firmware_version_t = _ctl_firmware_version_t;
#[doc = "< Graphics Device type"]
pub const _ctl_device_type_t_CTL_DEVICE_TYPE_GRAPHICS: _ctl_device_type_t = 1;
#[doc = "< System Device type"]
pub const _ctl_device_type_t_CTL_DEVICE_TYPE_SYSTEM: _ctl_device_type_t = 2;
pub const _ctl_device_type_t_CTL_DEVICE_TYPE_MAX: _ctl_device_type_t = 3;
#[doc = "\n @brief DeviceType"]
pub type _ctl_device_type_t = ::std::os::raw::c_int;
#[doc = "\n @brief DeviceType"]
pub use self::_ctl_device_type_t as ctl_device_type_t;
#[doc = "\n @brief Adapter Properties"]
pub type ctl_adapter_properties_flags_t = u32;
#[doc = "< [out] Is Integrated Graphics adapter"]
pub const _ctl_adapter_properties_flag_t_CTL_ADAPTER_PROPERTIES_FLAG_INTEGRATED:
    _ctl_adapter_properties_flag_t = 1;
pub const _ctl_adapter_properties_flag_t_CTL_ADAPTER_PROPERTIES_FLAG_MAX:
    _ctl_adapter_properties_flag_t = -2147483648;
pub type _ctl_adapter_properties_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_adapter_properties_flag_t as ctl_adapter_properties_flag_t;
#[doc = "\n @brief Device Adapter properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_device_adapter_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] OS specific Device ID"]
    pub pDeviceID: *mut ::std::os::raw::c_void,
    #[doc = "< [in] size of the device ID"]
    pub device_id_size: u32,
    #[doc = "< [out] Device Type"]
    pub device_type: ctl_device_type_t,
    #[doc = "< [out] Supported functions"]
    pub supported_subfunction_flags: ctl_supported_functions_flags_t,
    #[doc = "< [out] Driver version"]
    pub driver_version: u64,
    #[doc = "< [out] Firmware version"]
    pub firmware_version: ctl_firmware_version_t,
    #[doc = "< [out] PCI Vendor ID"]
    pub pci_vendor_id: u32,
    #[doc = "< [out] PCI Device ID"]
    pub pci_device_id: u32,
    #[doc = "< [out] PCI Revision ID"]
    pub rev_id: u32,
    #[doc = "< [out] Number of EUs per sub-slice"]
    pub num_eus_per_sub_slice: u32,
    #[doc = "< [out] Number of sub-slices per slice"]
    pub num_sub_slices_per_slice: u32,
    #[doc = "< [out] Number of slices"]
    pub num_slices: u32,
    #[doc = "< [out] Device name"]
    pub name: [::std::os::raw::c_char; 100usize],
    #[doc = "< [out] Graphics Adapter Properties"]
    pub graphics_adapter_properties: ctl_adapter_properties_flags_t,
    #[doc = "< [out] Clock frequency for this device. Supported only for Version > 0"]
    pub Frequency: u32,
    #[doc = "< [out] PCI SubSys ID, Supported only for Version > 1"]
    pub pci_subsys_id: u16,
    #[doc = "< [out] PCI SubSys Vendor ID, Supported only for Version > 1"]
    pub pci_subsys_vendor_id: u16,
    #[doc = "< [out] Reserved"]
    pub reserved: [::std::os::raw::c_char; 116usize],
}
#[test]
fn bindgen_test_layout__ctl_device_adapter_properties_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_device_adapter_properties_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_device_adapter_properties_t>(),
        320usize,
        concat!("Size of: ", stringify!(_ctl_device_adapter_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_device_adapter_properties_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_device_adapter_properties_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pDeviceID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(pDeviceID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_id_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(device_id_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(device_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported_subfunction_flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(supported_subfunction_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driver_version) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(driver_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firmware_version) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(firmware_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pci_vendor_id) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(pci_vendor_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pci_device_id) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(pci_device_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rev_id) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(rev_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_eus_per_sub_slice) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(num_eus_per_sub_slice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_sub_slices_per_slice) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(num_sub_slices_per_slice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_slices) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(num_slices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graphics_adapter_properties) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(graphics_adapter_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Frequency) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(Frequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pci_subsys_id) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(pci_subsys_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pci_subsys_vendor_id) as usize - ptr as usize },
        198usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(pci_subsys_vendor_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_device_adapter_properties_t),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = "\n @brief Device Adapter properties"]
pub type ctl_device_adapter_properties_t = _ctl_device_adapter_properties_t;
#[doc = "< Read operation"]
pub const _ctl_operation_type_t_CTL_OPERATION_TYPE_READ: _ctl_operation_type_t = 1;
#[doc = "< Write operation"]
pub const _ctl_operation_type_t_CTL_OPERATION_TYPE_WRITE: _ctl_operation_type_t = 2;
pub const _ctl_operation_type_t_CTL_OPERATION_TYPE_MAX: _ctl_operation_type_t = 3;
#[doc = "\n @brief OperationType"]
pub type _ctl_operation_type_t = ::std::os::raw::c_int;
#[doc = "\n @brief OperationType"]
pub use self::_ctl_operation_type_t as ctl_operation_type_t;
#[doc = "\n @brief Generic Structure for Void* datatypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_generic_void_datatype_t {
    #[doc = "< [in,out]void pointer to memory"]
    pub pData: *mut ::std::os::raw::c_void,
    #[doc = "< [in,out]size of the allocated memory"]
    pub size: u32,
}
#[test]
fn bindgen_test_layout__ctl_generic_void_datatype_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_generic_void_datatype_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_generic_void_datatype_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ctl_generic_void_datatype_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_generic_void_datatype_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_generic_void_datatype_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_generic_void_datatype_t),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_generic_void_datatype_t),
            "::",
            stringify!(size)
        )
    );
}
#[doc = "\n @brief Generic Structure for Void* datatypes"]
pub type ctl_generic_void_datatype_t = _ctl_generic_void_datatype_t;
#[doc = "\n @brief Generic Structure for Revision datatypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_revision_datatype_t {
    #[doc = "< [in,out]Major Version"]
    pub major_version: u8,
    #[doc = "< [in,out]Minor Version"]
    pub minor_version: u8,
    #[doc = "< [in,out]Revision Version"]
    pub revision_version: u8,
}
#[test]
fn bindgen_test_layout__ctl_revision_datatype_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_revision_datatype_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_revision_datatype_t>(),
        3usize,
        concat!("Size of: ", stringify!(_ctl_revision_datatype_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_revision_datatype_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ctl_revision_datatype_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_revision_datatype_t),
            "::",
            stringify!(major_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor_version) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_revision_datatype_t),
            "::",
            stringify!(minor_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revision_version) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_revision_datatype_t),
            "::",
            stringify!(revision_version)
        )
    );
}
#[doc = "\n @brief Generic Structure for Revision datatypes"]
pub type ctl_revision_datatype_t = _ctl_revision_datatype_t;
#[doc = "\n @brief Property Type flags"]
pub type ctl_property_type_flags_t = u32;
#[doc = "< Display type. Supported scenarios: Sharpness/gamma/CSC"]
pub const _ctl_property_type_flag_t_CTL_PROPERTY_TYPE_FLAG_DISPLAY: _ctl_property_type_flag_t = 1;
#[doc = "< 3D type. Supported scenarios: All set calls via IGCL's 3D APIs"]
pub const _ctl_property_type_flag_t_CTL_PROPERTY_TYPE_FLAG_3D: _ctl_property_type_flag_t = 2;
#[doc = "< Media type. Supported scenarios: All set calls via IGCL's media APIs"]
pub const _ctl_property_type_flag_t_CTL_PROPERTY_TYPE_FLAG_MEDIA: _ctl_property_type_flag_t = 4;
#[doc = "< For future: Core graphic event types like clocking, frequency etc."]
pub const _ctl_property_type_flag_t_CTL_PROPERTY_TYPE_FLAG_CORE: _ctl_property_type_flag_t = 8;
pub const _ctl_property_type_flag_t_CTL_PROPERTY_TYPE_FLAG_MAX: _ctl_property_type_flag_t =
    -2147483648;
pub type _ctl_property_type_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_property_type_flag_t as ctl_property_type_flag_t;
#[doc = "\n @brief Arguments related to wait for a property change function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_wait_property_change_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Type of the property"]
    pub PropertyType: ctl_property_type_flags_t,
    #[doc = "< [in][release] Time-out interval in milliseconds. Specify 0xFFFFFFFF if\n< time-out is not desired"]
    pub TimeOutMilliSec: u32,
    #[doc = "< [in][release] Event flags for future use"]
    pub EventMiscFlags: u32,
    #[doc = "< [in][release] Reserved for future use"]
    pub pReserved: *mut ::std::os::raw::c_void,
    #[doc = "< [out] Reserved out argument for future use"]
    pub ReservedOutFlags: u64,
}
#[test]
fn bindgen_test_layout__ctl_wait_property_change_args_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_wait_property_change_args_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_wait_property_change_args_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ctl_wait_property_change_args_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_wait_property_change_args_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_wait_property_change_args_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_wait_property_change_args_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_wait_property_change_args_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PropertyType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_wait_property_change_args_t),
            "::",
            stringify!(PropertyType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TimeOutMilliSec) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_wait_property_change_args_t),
            "::",
            stringify!(TimeOutMilliSec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EventMiscFlags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_wait_property_change_args_t),
            "::",
            stringify!(EventMiscFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pReserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_wait_property_change_args_t),
            "::",
            stringify!(pReserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedOutFlags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_wait_property_change_args_t),
            "::",
            stringify!(ReservedOutFlags)
        )
    );
}
#[doc = "\n @brief Arguments related to wait for a property change function"]
pub type ctl_wait_property_change_args_t = _ctl_wait_property_change_args_t;
#[doc = "< 0 Degree"]
pub const _ctl_display_orientation_t_CTL_DISPLAY_ORIENTATION_0: _ctl_display_orientation_t = 0;
#[doc = "< 90 Degree"]
pub const _ctl_display_orientation_t_CTL_DISPLAY_ORIENTATION_90: _ctl_display_orientation_t = 1;
#[doc = "< 180 Degree"]
pub const _ctl_display_orientation_t_CTL_DISPLAY_ORIENTATION_180: _ctl_display_orientation_t = 2;
#[doc = "< 270 Degree"]
pub const _ctl_display_orientation_t_CTL_DISPLAY_ORIENTATION_270: _ctl_display_orientation_t = 3;
pub const _ctl_display_orientation_t_CTL_DISPLAY_ORIENTATION_MAX: _ctl_display_orientation_t = 4;
#[doc = "\n @brief Display orientation (rotation)"]
pub type _ctl_display_orientation_t = ::std::os::raw::c_int;
#[doc = "\n @brief Display orientation (rotation)"]
pub use self::_ctl_display_orientation_t as ctl_display_orientation_t;
#[doc = "\n @brief Rectangle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_rect_t {
    #[doc = "< [in,out] Left"]
    pub Left: i32,
    #[doc = "< [in,out] Top"]
    pub Top: i32,
    #[doc = "< [in,out] Right"]
    pub Right: i32,
    #[doc = "< [in,out] Bottom"]
    pub Bottom: i32,
}
#[test]
fn bindgen_test_layout__ctl_rect_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_rect_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_rect_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ctl_rect_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_rect_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_rect_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_rect_t),
            "::",
            stringify!(Left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_rect_t),
            "::",
            stringify!(Top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Right) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_rect_t),
            "::",
            stringify!(Right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Bottom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_rect_t),
            "::",
            stringify!(Bottom)
        )
    );
}
#[doc = "\n @brief Rectangle"]
pub type ctl_rect_t = _ctl_rect_t;
extern "C" {
    #[doc = "\n @brief Wait for a property change. Note that this is a blocking call\n\n @details\n     - Wait for a property change in display, 3d, media etc.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceAdapter`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlWaitForPropertyChange(
        hDeviceAdapter: ctl_device_adapter_handle_t,
        pArgs: *mut ctl_wait_property_change_args_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Reserved function\n\n @details\n     - Reserved function\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceAdapter`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlReservedCall(
        hDeviceAdapter: ctl_device_adapter_handle_t,
        pArgs: *mut ctl_reserved_args_t,
    ) -> ctl_result_t;
}
#[doc = "\n @brief Endurance Gaming caps"]
pub type ctl_endurance_gaming_caps_t = _ctl_endurance_gaming_caps_t;
#[doc = "\n @brief Endurance Gaming Get/Set"]
pub type ctl_endurance_gaming_t = _ctl_endurance_gaming_t;
#[doc = "\n @brief Endurance Gaming version2 Get/Set"]
pub type ctl_endurance_gaming2_t = _ctl_endurance_gaming2_t;
#[doc = "\n @brief Adaptive sync plus caps"]
pub type ctl_adaptivesync_caps_t = _ctl_adaptivesync_caps_t;
#[doc = "\n @brief Adaptive sync plus"]
pub type ctl_adaptivesync_getset_t = _ctl_adaptivesync_getset_t;
#[doc = "\n @brief Game Profile Capabilities. Typically these remain the same across\n        games."]
pub type ctl_3d_app_profiles_caps_t = _ctl_3d_app_profiles_caps_t;
#[doc = "\n @brief Game Profile tiers"]
pub type ctl_3d_app_profiles_t = _ctl_3d_app_profiles_t;
#[doc = "\n @brief Game Profile tiers details"]
pub type ctl_3d_tier_details_t = _ctl_3d_tier_details_t;
#[doc = "\n @brief 3D feature capability details which will have range/supported and\n        default values"]
pub type ctl_3d_feature_details_t = _ctl_3d_feature_details_t;
#[doc = "\n @brief 3D feature which are controllable"]
pub type ctl_3d_feature_caps_t = _ctl_3d_feature_caps_t;
#[doc = "\n @brief 3D feature for get/set"]
pub type ctl_3d_feature_getset_t = _ctl_3d_feature_getset_t;
#[doc = "\n @brief Load KMD gaming features. Restricted function"]
pub type ctl_kmd_load_features_t = _ctl_kmd_load_features_t;
#[doc = "\n @brief Display Timing"]
pub type ctl_display_timing_t = _ctl_display_timing_t;
#[doc = "\n @brief This structure will contain the properties of the display currently\n        attached to the encoder."]
pub type ctl_display_properties_t = _ctl_display_properties_t;
#[doc = "\n @brief Adapter's display encoder properties"]
pub type ctl_adapter_display_encoder_properties_t = _ctl_adapter_display_encoder_properties_t;
#[doc = "\n @brief Sharpness filter properties"]
pub type ctl_sharpness_filter_properties_t = _ctl_sharpness_filter_properties_t;
#[doc = "\n @brief Various sharpness filter types"]
pub type ctl_sharpness_caps_t = _ctl_sharpness_caps_t;
#[doc = "\n @brief Current sharpness setting"]
pub type ctl_sharpness_settings_t = _ctl_sharpness_settings_t;
#[doc = "\n @brief I2C access arguments"]
pub type ctl_i2c_access_args_t = _ctl_i2c_access_args_t;
#[doc = "\n @brief AUX access arguments"]
pub type ctl_aux_access_args_t = _ctl_aux_access_args_t;
#[doc = "\n @brief Power optimization caps"]
pub type ctl_power_optimization_caps_t = _ctl_power_optimization_caps_t;
#[doc = "\n @brief LRR detailed settings"]
pub type ctl_power_optimization_lrr_t = _ctl_power_optimization_lrr_t;
#[doc = "\n @brief PSR detailed settings"]
pub type ctl_power_optimization_psr_t = _ctl_power_optimization_psr_t;
#[doc = "\n @brief DPST detailed settings"]
pub type ctl_power_optimization_dpst_t = _ctl_power_optimization_dpst_t;
#[doc = "\n @brief Power optimization settings"]
pub type ctl_power_optimization_settings_t = _ctl_power_optimization_settings_t;
#[doc = "\n @brief Brightness settings for SET call"]
pub type ctl_set_brightness_t = _ctl_set_brightness_t;
#[doc = "\n @brief Brightness settings for GET call"]
pub type ctl_get_brightness_t = _ctl_get_brightness_t;
#[doc = "\n @brief Pixel transformation color primaries"]
pub type ctl_pixtx_color_primaries_t = _ctl_pixtx_color_primaries_t;
#[doc = "\n @brief Pixel transformation pixel format"]
pub type ctl_pixtx_pixel_format_t = _ctl_pixtx_pixel_format_t;
#[doc = "\n @brief Pixel transformation 1D LUT configuration"]
pub type ctl_pixtx_1dlut_config_t = _ctl_pixtx_1dlut_config_t;
#[doc = "\n @brief Pixel transformation matrix configuration"]
pub type ctl_pixtx_matrix_config_t = _ctl_pixtx_matrix_config_t;
#[doc = "\n @brief Pixel transformation 3D LUT sample. Samples are converted to integer\n        based on underlying HW capabilities. Hence slight precision loss will\n        be observed while getting sample values."]
pub type ctl_pixtx_3dlut_sample_t = _ctl_pixtx_3dlut_sample_t;
#[doc = "\n @brief Pixel transformation 3D LUT configuration"]
pub type ctl_pixtx_3dlut_config_t = _ctl_pixtx_3dlut_config_t;
#[doc = "\n @brief Pixel transformation block configuration"]
pub type ctl_pixtx_block_config_t = _ctl_pixtx_block_config_t;
#[doc = "\n @brief Pixel transformation pipe get configuration"]
pub type ctl_pixtx_pipe_get_config_t = _ctl_pixtx_pipe_get_config_t;
#[doc = "\n @brief Pixel transformation pipe set configuration"]
pub type ctl_pixtx_pipe_set_config_t = _ctl_pixtx_pipe_set_config_t;
#[doc = "\n @brief Panel descriptor access arguments"]
pub type ctl_panel_descriptor_access_args_t = _ctl_panel_descriptor_access_args_t;
#[doc = "\n @brief Set/Get Retro Scaling Type"]
pub type ctl_retro_scaling_settings_t = _ctl_retro_scaling_settings_t;
#[doc = "\n @brief Retro Scaling caps"]
pub type ctl_retro_scaling_caps_t = _ctl_retro_scaling_caps_t;
#[doc = "\n @brief Scaling caps"]
pub type ctl_scaling_caps_t = _ctl_scaling_caps_t;
#[doc = "\n @brief Set/Get Scaling type"]
pub type ctl_scaling_settings_t = _ctl_scaling_settings_t;
#[doc = "\n @brief Ambient light based enhancement table entry"]
pub type ctl_lace_lux_aggr_map_entry_t = _ctl_lace_lux_aggr_map_entry_t;
#[doc = "\n @brief Ambient light based enhancement table"]
pub type ctl_lace_lux_aggr_map_t = _ctl_lace_lux_aggr_map_t;
#[doc = "\n @brief Set/Get LACE Config"]
pub type ctl_lace_config_t = _ctl_lace_config_t;
#[doc = "\n @brief Get Software PSR status/Set Software PSR settings"]
pub type ctl_sw_psr_settings_t = _ctl_sw_psr_settings_t;
#[doc = "\n @brief Intel Arc Sync Monitor Params"]
pub type ctl_intel_arc_sync_monitor_params_t = _ctl_intel_arc_sync_monitor_params_t;
#[doc = "\n @brief Display MUX device properties"]
pub type ctl_mux_properties_t = _ctl_mux_properties_t;
#[doc = "\n @brief Intel Arc Sync Profile Params"]
pub type ctl_intel_arc_sync_profile_params_t = _ctl_intel_arc_sync_profile_params_t;
#[doc = "\n @brief EDID management"]
pub type ctl_edid_management_args_t = _ctl_edid_management_args_t;
#[doc = "\n @brief Get/Set Custom Mode"]
pub type ctl_get_set_custom_mode_args_t = _ctl_get_set_custom_mode_args_t;
#[doc = "\n @brief Get/Set Custom Mode"]
pub type ctl_custom_src_mode_t = _ctl_custom_src_mode_t;
#[doc = "\n @brief Combined Display's child display target mode"]
pub type ctl_child_display_target_mode_t = _ctl_child_display_target_mode_t;
#[doc = "\n @brief Combined Display's child display information"]
pub type ctl_combined_display_child_info_t = _ctl_combined_display_child_info_t;
#[doc = "\n @brief Combined Display arguments"]
pub type ctl_combined_display_args_t = _ctl_combined_display_args_t;
#[doc = "\n @brief Display Genlock Info"]
pub type ctl_genlock_display_info_t = _ctl_genlock_display_info_t;
#[doc = "\n @brief Genlock Target Mode List"]
pub type ctl_genlock_target_mode_list_t = _ctl_genlock_target_mode_list_t;
#[doc = "\n @brief Genlock Topology"]
pub type ctl_genlock_topology_t = _ctl_genlock_topology_t;
#[doc = "\n @brief Display Genlock Arg type"]
pub type ctl_genlock_args_t = _ctl_genlock_args_t;
#[doc = "\n @brief Engine group properties"]
pub type ctl_engine_properties_t = _ctl_engine_properties_t;
#[doc = "\n @brief Engine activity counters\n\n @details\n     - Percent utilization is calculated by taking two snapshots (s1, s2) and\n       using the equation: %util = (s2.activeTime - s1.activeTime) /\n       (s2.timestamp - s1.timestamp)"]
pub type ctl_engine_stats_t = _ctl_engine_stats_t;
#[doc = "\n @brief Fan speed"]
pub type ctl_fan_speed_t = _ctl_fan_speed_t;
#[doc = "\n @brief Fan temperature/speed pair"]
pub type ctl_fan_temp_speed_t = _ctl_fan_temp_speed_t;
#[doc = "\n @brief Fan speed table"]
pub type ctl_fan_speed_table_t = _ctl_fan_speed_table_t;
#[doc = "\n @brief Fan properties"]
pub type ctl_fan_properties_t = _ctl_fan_properties_t;
#[doc = "\n @brief Fan configuration"]
pub type ctl_fan_config_t = _ctl_fan_config_t;
#[doc = "\n @brief Frequency properties"]
pub type ctl_freq_properties_t = _ctl_freq_properties_t;
#[doc = "\n @brief Frequency range between which the hardware can operate. The limits can\n        be above or below the hardware limits - the hardware will clamp\n        appropriately."]
pub type ctl_freq_range_t = _ctl_freq_range_t;
#[doc = "\n @brief Frequency state"]
pub type ctl_freq_state_t = _ctl_freq_state_t;
#[doc = "\n @brief Frequency throttle time snapshot\n\n @details\n     - Percent time throttled is calculated by taking two snapshots (s1, s2)\n       and using the equation: %throttled = (s2.throttleTime -\n       s1.throttleTime) / (s2.timestamp - s1.timestamp)"]
pub type ctl_freq_throttle_time_t = _ctl_freq_throttle_time_t;
#[doc = "\n @brief Super Resolution feature details structure to be used with\n        SUPER_RESOLUTION"]
pub type ctl_video_processing_super_resolution_info_t =
    _ctl_video_processing_super_resolution_info_t;
#[doc = "\n @brief Super Resolution Get/Set structure to be used with SUPER_RESOLUTION"]
pub type ctl_video_processing_super_resolution_t = _ctl_video_processing_super_resolution_t;
#[doc = "\n @brief Noise Reduction feature details structure to be used with\n        NOISE_REDUCTION"]
pub type ctl_video_processing_noise_reduction_info_t = _ctl_video_processing_noise_reduction_info_t;
#[doc = "\n @brief Noise Reduction Get/Set structure to be used with NOISE_REDUCTION"]
pub type ctl_video_processing_noise_reduction_t = _ctl_video_processing_noise_reduction_t;
#[doc = "\n @brief Adaptive Contrast Enhancement feature details structure to be used\n        with ADAPTIVE_CONTRAST_ENHANCEMENT"]
pub type ctl_video_processing_adaptive_contrast_enhancement_info_t =
    _ctl_video_processing_adaptive_contrast_enhancement_info_t;
#[doc = "\n @brief Adaptive Contrast Enhancement Get/Set structure to be used with\n        ADAPTIVE_CONTRAST_ENHANCEMENT"]
pub type ctl_video_processing_adaptive_contrast_enhancement_t =
    _ctl_video_processing_adaptive_contrast_enhancement_t;
#[doc = "\n @brief Standard Color Correction feature details structure to be used with\n        STANDARD_COLOR_CORRECTION"]
pub type ctl_video_processing_standard_color_correction_info_t =
    _ctl_video_processing_standard_color_correction_info_t;
#[doc = "\n @brief Standard Color Correction Get/Set structure to be used with\n        STANDARD_COLOR_CORRECTION"]
pub type ctl_video_processing_standard_color_correction_t =
    _ctl_video_processing_standard_color_correction_t;
#[doc = "\n @brief Total Color Correction Get/Set structure to be used with\n        TOTAL_COLOR_CORRECTION"]
pub type ctl_video_processing_total_color_correction_info_t =
    _ctl_video_processing_total_color_correction_info_t;
#[doc = "\n @brief Total Color Correction Get/Set structure to be used with\n        TOTAL_COLOR_CORRECTION"]
pub type ctl_video_processing_total_color_correction_t =
    _ctl_video_processing_total_color_correction_t;
#[doc = "\n @brief Video Processing feature details which will have range supported and\n        default values"]
pub type ctl_video_processing_feature_details_t = _ctl_video_processing_feature_details_t;
#[doc = "\n @brief Video Processing features which are controllable"]
pub type ctl_video_processing_feature_caps_t = _ctl_video_processing_feature_caps_t;
#[doc = "\n @brief Video Processing feature for get/set"]
pub type ctl_video_processing_feature_getset_t = _ctl_video_processing_feature_getset_t;
#[doc = "\n @brief Memory properties"]
pub type ctl_mem_properties_t = _ctl_mem_properties_t;
#[doc = "\n @brief Memory state - health, allocated\n\n @details\n     - Percent allocation is given by 100 * (size - free / size.\n     - Percent free is given by 100 * free / size."]
pub type ctl_mem_state_t = _ctl_mem_state_t;
#[doc = "\n @brief Memory bandwidth\n\n @details\n     - Percent bandwidth is calculated by taking two snapshots (s1, s2) and\n       using the equation: %bw = 10^6 * ((s2.readCounter - s1.readCounter) +\n       (s2.writeCounter - s1.writeCounter)) / (s2.maxBandwidth *\n       (s2.timestamp - s1.timestamp))"]
pub type ctl_mem_bandwidth_t = _ctl_mem_bandwidth_t;
#[doc = "\n @brief Telemetry Item for each telemetry property\n\n @details\n     - If the supported field is true, then the entire structure has valid\n       information.\n     - The ::ctl_data_value_t is of type ::ctl_data_type_t and units\n       ::ctl_units_t"]
pub type ctl_oc_telemetry_item_t = _ctl_oc_telemetry_item_t;
#[doc = "\n @brief Overclocking Control Information\n\n @details\n     - Whether the device supports overclocking.\n     - The\n       bSupported/bRelative/bReference/units/min/max/step/default/reference\n       values for the available overclock controls\n     - The idea is to facilitate the way the applications present overclock\n       settings to the user. If bSupported is false, the corresponding\n       overclock control is not supported\n     - The setting units will be an enum that enables the application to know\n       the units for the control setting e.g. MHz. The min and max settings\n       give the limits for the control.\n     - The step setting gives the minimum change in the control value (plus\n       or minus) - if a control is not changed by at least this amount, the\n       hardware may round up or down.\n     - The default values gives the manufacturing setting for the control.\n       Some controls such as frequency offset and voltage offset are\n       relative; in this case, bRelative will be true, otherwise the control\n       settings are absolute values.\n     - For relative controls and if bReference is true, the reference value\n       gives the absolute value at the default setting.\n     - If bReference is false, the absolute value of the default setting is\n       no not known and it is probably better to display the setting to users\n       as percentage offsets."]
pub type ctl_oc_control_info_t = _ctl_oc_control_info_t;
#[doc = "\n @brief Overclock properties"]
pub type ctl_oc_properties_t = _ctl_oc_properties_t;
#[doc = "\n @brief Overclock Voltage Frequency Pair"]
pub type ctl_oc_vf_pair_t = _ctl_oc_vf_pair_t;
#[doc = "\n @brief PSU Info"]
pub type ctl_psu_info_t = _ctl_psu_info_t;
#[doc = "\n @brief Power Telemetry"]
pub type ctl_power_telemetry_t = _ctl_power_telemetry_t;
#[doc = "\n @brief PCI address"]
pub type ctl_pci_address_t = _ctl_pci_address_t;
#[doc = "\n @brief PCI speed"]
pub type ctl_pci_speed_t = _ctl_pci_speed_t;
#[doc = "\n @brief Static PCI properties"]
pub type ctl_pci_properties_t = _ctl_pci_properties_t;
#[doc = "\n @brief Dynamic PCI state"]
pub type ctl_pci_state_t = _ctl_pci_state_t;
#[doc = "\n @brief Properties related to device power settings"]
pub type ctl_power_properties_t = _ctl_power_properties_t;
#[doc = "\n @brief Energy counter snapshot\n\n @details\n     - Average power is calculated by taking two snapshots (s1, s2) and using\n       the equation: PowerWatts = (s2.energy - s1.energy) / (s2.timestamp -\n       s1.timestamp)"]
pub type ctl_power_energy_counter_t = _ctl_power_energy_counter_t;
#[doc = "\n @brief Sustained power limits\n\n @details\n     - The power controller (Punit) will throttle the operating frequency if\n       the power averaged over a window (typically seconds) exceeds this\n       limit."]
pub type ctl_power_sustained_limit_t = _ctl_power_sustained_limit_t;
#[doc = "\n @brief Burst power limit\n\n @details\n     - The power controller (Punit) will throttle the operating frequency of\n       the device if the power averaged over a few milliseconds exceeds a\n       limit known as PL2. Typically PL2 > PL1 so that it permits the\n       frequency to burst higher for short periods than would be otherwise\n       permitted by PL1."]
pub type ctl_power_burst_limit_t = _ctl_power_burst_limit_t;
#[doc = "\n @brief Peak power limit\n\n @details\n     - The power controller (Punit) will preemptively throttle the operating\n       frequency of the device when the instantaneous power exceeds this\n       limit. The limit is known as PL4. It expresses the maximum power that\n       can be drawn from the power supply.\n     - If this power limit is removed or set too high, the power supply will\n       generate an interrupt when it detects an overcurrent condition and the\n       power controller will throttle the device frequencies down to min. It\n       is thus better to tune the PL4 value in order to avoid such\n       excursions."]
pub type ctl_power_peak_limit_t = _ctl_power_peak_limit_t;
#[doc = "\n @brief Power limits"]
pub type ctl_power_limits_t = _ctl_power_limits_t;
#[doc = "\n @brief Energy threshold\n\n @details\n     - ."]
pub type ctl_energy_threshold_t = _ctl_energy_threshold_t;
#[doc = "\n @brief Temperature sensor properties"]
pub type ctl_temp_properties_t = _ctl_temp_properties_t;
#[doc = "< Frame pacing. Contains generic enum type fields"]
pub const _ctl_3d_feature_t_CTL_3D_FEATURE_FRAME_PACING: _ctl_3d_feature_t = 0;
#[doc = "< Endurance gaming. Contains generic integer type fields. Value will be\n< interpreted as the max FPS to be used when in DC mode globally or per\n< application"]
pub const _ctl_3d_feature_t_CTL_3D_FEATURE_ENDURANCE_GAMING: _ctl_3d_feature_t = 1;
#[doc = "< Frame limit for games. Contains generic integer type fields. Value\n< will be interpreted as the max FPS to be used independent of system\n< power state"]
pub const _ctl_3d_feature_t_CTL_3D_FEATURE_FRAME_LIMIT: _ctl_3d_feature_t = 2;
#[doc = "< ANISOTROPIC. Contains generic enum type fields"]
pub const _ctl_3d_feature_t_CTL_3D_FEATURE_ANISOTROPIC: _ctl_3d_feature_t = 3;
#[doc = "< CMAA. Contains generic enum type fields"]
pub const _ctl_3d_feature_t_CTL_3D_FEATURE_CMAA: _ctl_3d_feature_t = 4;
#[doc = "< Texture filtering quality. Contains generic enum type fields"]
pub const _ctl_3d_feature_t_CTL_3D_FEATURE_TEXTURE_FILTERING_QUALITY: _ctl_3d_feature_t = 5;
#[doc = "< Adaptive tessellation quality. Contains generic integer type fields"]
pub const _ctl_3d_feature_t_CTL_3D_FEATURE_ADAPTIVE_TESSELLATION: _ctl_3d_feature_t = 6;
#[doc = "< Sharpening Filter. Contains generic integer type fields"]
pub const _ctl_3d_feature_t_CTL_3D_FEATURE_SHARPENING_FILTER: _ctl_3d_feature_t = 7;
#[doc = "< Msaa. Contains generic enum type fields"]
pub const _ctl_3d_feature_t_CTL_3D_FEATURE_MSAA: _ctl_3d_feature_t = 8;
#[doc = "< Various Gaming flip modes like speed frame, smooth sync & force async\n< flip. Contains generic enum type fields"]
pub const _ctl_3d_feature_t_CTL_3D_FEATURE_GAMING_FLIP_MODES: _ctl_3d_feature_t = 9;
#[doc = "< Adaptive sync plus. Refer custom field ::ctl_adaptivesync_caps_t &\n< ::ctl_adaptivesync_getset_t"]
pub const _ctl_3d_feature_t_CTL_3D_FEATURE_ADAPTIVE_SYNC_PLUS: _ctl_3d_feature_t = 10;
#[doc = "< Game Compatibility & Performance Profiles. Refer custom field\n< ::ctl_3d_app_profiles_caps_t & ::ctl_3d_app_profiles_t"]
pub const _ctl_3d_feature_t_CTL_3D_FEATURE_APP_PROFILES: _ctl_3d_feature_t = 11;
#[doc = "< Game Profile Customization. Refer custom field ::ctl_3d_tier_details_t"]
pub const _ctl_3d_feature_t_CTL_3D_FEATURE_APP_PROFILE_DETAILS: _ctl_3d_feature_t = 12;
#[doc = "< Emulated Typed 64bit Atomics support in DG2"]
pub const _ctl_3d_feature_t_CTL_3D_FEATURE_EMULATED_TYPED_64BIT_ATOMICS: _ctl_3d_feature_t = 13;
pub const _ctl_3d_feature_t_CTL_3D_FEATURE_MAX: _ctl_3d_feature_t = 14;
#[doc = "\n @brief Feature type"]
pub type _ctl_3d_feature_t = ::std::os::raw::c_int;
#[doc = "\n @brief Feature type"]
pub use self::_ctl_3d_feature_t as ctl_3d_feature_t;
#[doc = "\n @brief 3D feature misc flags"]
pub type ctl_3d_feature_misc_flags_t = u32;
#[doc = "< Feature supported on DX11"]
pub const _ctl_3d_feature_misc_flag_t_CTL_3D_FEATURE_MISC_FLAG_DX11: _ctl_3d_feature_misc_flag_t =
    1;
#[doc = "< Feature supported on DX12"]
pub const _ctl_3d_feature_misc_flag_t_CTL_3D_FEATURE_MISC_FLAG_DX12: _ctl_3d_feature_misc_flag_t =
    2;
#[doc = "< Feature supported on VULKAN"]
pub const _ctl_3d_feature_misc_flag_t_CTL_3D_FEATURE_MISC_FLAG_VULKAN: _ctl_3d_feature_misc_flag_t =
    4;
#[doc = "< User can change feature live without restarting the game"]
pub const _ctl_3d_feature_misc_flag_t_CTL_3D_FEATURE_MISC_FLAG_LIVE_CHANGE:
    _ctl_3d_feature_misc_flag_t = 8;
pub const _ctl_3d_feature_misc_flag_t_CTL_3D_FEATURE_MISC_FLAG_MAX: _ctl_3d_feature_misc_flag_t =
    -2147483648;
pub type _ctl_3d_feature_misc_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_3d_feature_misc_flag_t as ctl_3d_feature_misc_flag_t;
#[doc = "< Application choice"]
pub const _ctl_3d_anisotropic_types_t_CTL_3D_ANISOTROPIC_TYPES_APP_CHOICE:
    _ctl_3d_anisotropic_types_t = 0;
#[doc = "< 2X"]
pub const _ctl_3d_anisotropic_types_t_CTL_3D_ANISOTROPIC_TYPES_2X: _ctl_3d_anisotropic_types_t = 2;
#[doc = "< 4X"]
pub const _ctl_3d_anisotropic_types_t_CTL_3D_ANISOTROPIC_TYPES_4X: _ctl_3d_anisotropic_types_t = 4;
#[doc = "< 8X"]
pub const _ctl_3d_anisotropic_types_t_CTL_3D_ANISOTROPIC_TYPES_8X: _ctl_3d_anisotropic_types_t = 8;
#[doc = "< 16X"]
pub const _ctl_3d_anisotropic_types_t_CTL_3D_ANISOTROPIC_TYPES_16X: _ctl_3d_anisotropic_types_t =
    16;
pub const _ctl_3d_anisotropic_types_t_CTL_3D_ANISOTROPIC_TYPES_MAX: _ctl_3d_anisotropic_types_t =
    17;
#[doc = "\n @brief Anisotropic values possible"]
pub type _ctl_3d_anisotropic_types_t = ::std::os::raw::c_int;
#[doc = "\n @brief Anisotropic values possible"]
pub use self::_ctl_3d_anisotropic_types_t as ctl_3d_anisotropic_types_t;
#[doc = "< Performance"]
pub const _ctl_3d_texture_filtering_quality_types_t_CTL_3D_TEXTURE_FILTERING_QUALITY_TYPES_PERFORMANCE : _ctl_3d_texture_filtering_quality_types_t = 0 ;
#[doc = "< Balanced"]
pub const _ctl_3d_texture_filtering_quality_types_t_CTL_3D_TEXTURE_FILTERING_QUALITY_TYPES_BALANCED : _ctl_3d_texture_filtering_quality_types_t = 1 ;
#[doc = "< Quality"]
pub const _ctl_3d_texture_filtering_quality_types_t_CTL_3D_TEXTURE_FILTERING_QUALITY_TYPES_QUALITY : _ctl_3d_texture_filtering_quality_types_t = 2 ;
pub const _ctl_3d_texture_filtering_quality_types_t_CTL_3D_TEXTURE_FILTERING_QUALITY_TYPES_MAX:
    _ctl_3d_texture_filtering_quality_types_t = 3;
#[doc = "\n @brief Texture filtering values possible"]
pub type _ctl_3d_texture_filtering_quality_types_t = ::std::os::raw::c_int;
#[doc = "\n @brief Texture filtering values possible"]
pub use self::_ctl_3d_texture_filtering_quality_types_t as ctl_3d_texture_filtering_quality_types_t;
#[doc = "< Disable"]
pub const _ctl_3d_frame_pacing_types_t_CTL_3D_FRAME_PACING_TYPES_DISABLE:
    _ctl_3d_frame_pacing_types_t = 0;
#[doc = "< Enable with scheduler without any frame smoothening"]
pub const _ctl_3d_frame_pacing_types_t_CTL_3D_FRAME_PACING_TYPES_ENABLE_MODE_FRAME_NO_SMOOTHENING : _ctl_3d_frame_pacing_types_t = 1 ;
#[doc = "< Enable with scheduler with maximum smoothness"]
pub const _ctl_3d_frame_pacing_types_t_CTL_3D_FRAME_PACING_TYPES_ENABLE_MODE_FRAME_MAX_SMOOTHENING : _ctl_3d_frame_pacing_types_t = 2 ;
#[doc = "< Enable with scheduler in competitive gaming mode"]
pub const _ctl_3d_frame_pacing_types_t_CTL_3D_FRAME_PACING_TYPES_ENABLE_MODE_COMPETITIVE_GAMING:
    _ctl_3d_frame_pacing_types_t = 3;
pub const _ctl_3d_frame_pacing_types_t_CTL_3D_FRAME_PACING_TYPES_MAX: _ctl_3d_frame_pacing_types_t =
    4;
#[doc = "\n @brief Frame pacing values possible"]
pub type _ctl_3d_frame_pacing_types_t = ::std::os::raw::c_int;
#[doc = "\n @brief Frame pacing values possible"]
pub use self::_ctl_3d_frame_pacing_types_t as ctl_3d_frame_pacing_types_t;
#[doc = "< Endurance Gaming disable"]
pub const _ctl_3d_endurance_gaming_control_t_CTL_3D_ENDURANCE_GAMING_CONTROL_TURN_OFF:
    _ctl_3d_endurance_gaming_control_t = 0;
#[doc = "< Endurance Gaming enable"]
pub const _ctl_3d_endurance_gaming_control_t_CTL_3D_ENDURANCE_GAMING_CONTROL_TURN_ON:
    _ctl_3d_endurance_gaming_control_t = 1;
#[doc = "< Endurance Gaming auto"]
pub const _ctl_3d_endurance_gaming_control_t_CTL_3D_ENDURANCE_GAMING_CONTROL_AUTO:
    _ctl_3d_endurance_gaming_control_t = 2;
pub const _ctl_3d_endurance_gaming_control_t_CTL_3D_ENDURANCE_GAMING_CONTROL_MAX:
    _ctl_3d_endurance_gaming_control_t = 3;
#[doc = "\n @brief Endurance Gaming control possible"]
pub type _ctl_3d_endurance_gaming_control_t = ::std::os::raw::c_int;
#[doc = "\n @brief Endurance Gaming control possible"]
pub use self::_ctl_3d_endurance_gaming_control_t as ctl_3d_endurance_gaming_control_t;
#[doc = "< Endurance Gaming better performance mode"]
pub const _ctl_3d_endurance_gaming_mode_t_CTL_3D_ENDURANCE_GAMING_MODE_BETTER_PERFORMANCE:
    _ctl_3d_endurance_gaming_mode_t = 0;
#[doc = "< Endurance Gaming balanced mode"]
pub const _ctl_3d_endurance_gaming_mode_t_CTL_3D_ENDURANCE_GAMING_MODE_BALANCED:
    _ctl_3d_endurance_gaming_mode_t = 1;
#[doc = "< Endurance Gaming maximum battery mode"]
pub const _ctl_3d_endurance_gaming_mode_t_CTL_3D_ENDURANCE_GAMING_MODE_MAXIMUM_BATTERY:
    _ctl_3d_endurance_gaming_mode_t = 2;
pub const _ctl_3d_endurance_gaming_mode_t_CTL_3D_ENDURANCE_GAMING_MODE_MAX:
    _ctl_3d_endurance_gaming_mode_t = 3;
#[doc = "\n @brief Endurance Gaming modes possible"]
pub type _ctl_3d_endurance_gaming_mode_t = ::std::os::raw::c_int;
#[doc = "\n @brief Endurance Gaming modes possible"]
pub use self::_ctl_3d_endurance_gaming_mode_t as ctl_3d_endurance_gaming_mode_t;
#[doc = "< Turn off"]
pub const _ctl_3d_cmaa_types_t_CTL_3D_CMAA_TYPES_TURN_OFF: _ctl_3d_cmaa_types_t = 0;
#[doc = "< Override MSAA"]
pub const _ctl_3d_cmaa_types_t_CTL_3D_CMAA_TYPES_OVERRIDE_MSAA: _ctl_3d_cmaa_types_t = 1;
#[doc = "< Enhance Application"]
pub const _ctl_3d_cmaa_types_t_CTL_3D_CMAA_TYPES_ENHANCE_APPLICATION: _ctl_3d_cmaa_types_t = 2;
pub const _ctl_3d_cmaa_types_t_CTL_3D_CMAA_TYPES_MAX: _ctl_3d_cmaa_types_t = 3;
#[doc = "\n @brief Cmaa values possible"]
pub type _ctl_3d_cmaa_types_t = ::std::os::raw::c_int;
#[doc = "\n @brief Cmaa values possible"]
pub use self::_ctl_3d_cmaa_types_t as ctl_3d_cmaa_types_t;
#[doc = "< Turn off"]
pub const _ctl_3d_adaptive_tessellation_types_t_CTL_3D_ADAPTIVE_TESSELLATION_TYPES_TURN_OFF:
    _ctl_3d_adaptive_tessellation_types_t = 0;
#[doc = "< Turn on"]
pub const _ctl_3d_adaptive_tessellation_types_t_CTL_3D_ADAPTIVE_TESSELLATION_TYPES_TURN_ON:
    _ctl_3d_adaptive_tessellation_types_t = 1;
pub const _ctl_3d_adaptive_tessellation_types_t_CTL_3D_ADAPTIVE_TESSELLATION_TYPES_MAX:
    _ctl_3d_adaptive_tessellation_types_t = 2;
#[doc = "\n @brief Adaptive Tessellation"]
pub type _ctl_3d_adaptive_tessellation_types_t = ::std::os::raw::c_int;
#[doc = "\n @brief Adaptive Tessellation"]
pub use self::_ctl_3d_adaptive_tessellation_types_t as ctl_3d_adaptive_tessellation_types_t;
#[doc = "< Turn off"]
pub const _ctl_3d_sharpening_filter_types_t_CTL_3D_SHARPENING_FILTER_TYPES_TURN_OFF:
    _ctl_3d_sharpening_filter_types_t = 0;
#[doc = "< Turn on"]
pub const _ctl_3d_sharpening_filter_types_t_CTL_3D_SHARPENING_FILTER_TYPES_TURN_ON:
    _ctl_3d_sharpening_filter_types_t = 1;
pub const _ctl_3d_sharpening_filter_types_t_CTL_3D_SHARPENING_FILTER_TYPES_MAX:
    _ctl_3d_sharpening_filter_types_t = 2;
#[doc = "\n @brief Sharpening filter values possible"]
pub type _ctl_3d_sharpening_filter_types_t = ::std::os::raw::c_int;
#[doc = "\n @brief Sharpening filter values possible"]
pub use self::_ctl_3d_sharpening_filter_types_t as ctl_3d_sharpening_filter_types_t;
#[doc = "< Application choice"]
pub const _ctl_3d_msaa_types_t_CTL_3D_MSAA_TYPES_APP_CHOICE: _ctl_3d_msaa_types_t = 0;
#[doc = "< Disabled. MSAA count 1"]
pub const _ctl_3d_msaa_types_t_CTL_3D_MSAA_TYPES_DISABLED: _ctl_3d_msaa_types_t = 1;
#[doc = "< 2X"]
pub const _ctl_3d_msaa_types_t_CTL_3D_MSAA_TYPES_2X: _ctl_3d_msaa_types_t = 2;
#[doc = "< 4X"]
pub const _ctl_3d_msaa_types_t_CTL_3D_MSAA_TYPES_4X: _ctl_3d_msaa_types_t = 4;
#[doc = "< 8X"]
pub const _ctl_3d_msaa_types_t_CTL_3D_MSAA_TYPES_8X: _ctl_3d_msaa_types_t = 8;
#[doc = "< 16X"]
pub const _ctl_3d_msaa_types_t_CTL_3D_MSAA_TYPES_16X: _ctl_3d_msaa_types_t = 16;
pub const _ctl_3d_msaa_types_t_CTL_3D_MSAA_TYPES_MAX: _ctl_3d_msaa_types_t = 17;
#[doc = "\n @brief MSAA values possible"]
pub type _ctl_3d_msaa_types_t = ::std::os::raw::c_int;
#[doc = "\n @brief MSAA values possible"]
pub use self::_ctl_3d_msaa_types_t as ctl_3d_msaa_types_t;
#[doc = "\n @brief Gaming flip modes"]
pub type ctl_gaming_flip_mode_flags_t = u32;
#[doc = "< Application Default"]
pub const _ctl_gaming_flip_mode_flag_t_CTL_GAMING_FLIP_MODE_FLAG_APPLICATION_DEFAULT:
    _ctl_gaming_flip_mode_flag_t = 1;
#[doc = "< Convert all sync flips to async on the next possible scanline."]
pub const _ctl_gaming_flip_mode_flag_t_CTL_GAMING_FLIP_MODE_FLAG_VSYNC_OFF:
    _ctl_gaming_flip_mode_flag_t = 2;
#[doc = "< Convert all async flips to sync flips."]
pub const _ctl_gaming_flip_mode_flag_t_CTL_GAMING_FLIP_MODE_FLAG_VSYNC_ON:
    _ctl_gaming_flip_mode_flag_t = 4;
#[doc = "< Reduce tearing effect with async flips"]
pub const _ctl_gaming_flip_mode_flag_t_CTL_GAMING_FLIP_MODE_FLAG_SMOOTH_SYNC:
    _ctl_gaming_flip_mode_flag_t = 8;
#[doc = "< Application unaware triple buffering"]
pub const _ctl_gaming_flip_mode_flag_t_CTL_GAMING_FLIP_MODE_FLAG_SPEED_FRAME:
    _ctl_gaming_flip_mode_flag_t = 16;
#[doc = "< Limit the game FPS to panel RR"]
pub const _ctl_gaming_flip_mode_flag_t_CTL_GAMING_FLIP_MODE_FLAG_CAPPED_FPS:
    _ctl_gaming_flip_mode_flag_t = 32;
pub const _ctl_gaming_flip_mode_flag_t_CTL_GAMING_FLIP_MODE_FLAG_MAX: _ctl_gaming_flip_mode_flag_t =
    -2147483648;
pub type _ctl_gaming_flip_mode_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_gaming_flip_mode_flag_t as ctl_gaming_flip_mode_flag_t;
#[doc = "\n @brief Endurance Gaming caps"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_endurance_gaming_caps_t {
    #[doc = "< [out] Endurance Gaming control capability"]
    pub EGControlCaps: ctl_property_info_enum_t,
    #[doc = "< [out] Endurance Gaming mode capability"]
    pub EGModeCaps: ctl_property_info_enum_t,
}
#[test]
fn bindgen_test_layout__ctl_endurance_gaming_caps_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_endurance_gaming_caps_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_endurance_gaming_caps_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ctl_endurance_gaming_caps_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_endurance_gaming_caps_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_endurance_gaming_caps_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EGControlCaps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_endurance_gaming_caps_t),
            "::",
            stringify!(EGControlCaps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EGModeCaps) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_endurance_gaming_caps_t),
            "::",
            stringify!(EGModeCaps)
        )
    );
}
#[doc = "\n @brief Endurance Gaming Get/Set"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_endurance_gaming_t {
    #[doc = "< [in,out] Endurance Gaming control - Off/On/Auto"]
    pub EGControl: ctl_3d_endurance_gaming_control_t,
    #[doc = "< [in,out] Endurance Gaming mode - Better Performance/Balanced/Maximum\n< Battery"]
    pub EGMode: ctl_3d_endurance_gaming_mode_t,
}
#[test]
fn bindgen_test_layout__ctl_endurance_gaming_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_endurance_gaming_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_endurance_gaming_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ctl_endurance_gaming_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_endurance_gaming_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_endurance_gaming_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EGControl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_endurance_gaming_t),
            "::",
            stringify!(EGControl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EGMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_endurance_gaming_t),
            "::",
            stringify!(EGMode)
        )
    );
}
#[doc = "\n @brief Endurance Gaming version2 Get/Set"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_endurance_gaming2_t {
    #[doc = "< [in,out] Endurance Gaming control - Off/On/Auto"]
    pub EGControl: ctl_3d_endurance_gaming_control_t,
    #[doc = "< [in,out] Endurance Gaming mode - Better Performance/Balanced/Maximum\n< Battery"]
    pub EGMode: ctl_3d_endurance_gaming_mode_t,
    #[doc = "< [out] Is frame pacing required, dynamic state"]
    pub IsFPRequired: bool,
    #[doc = "< [out] Target FPS for frame pacing"]
    pub TargetFPS: f64,
    #[doc = "< [out] Refresh rate used to calculate target fps"]
    pub RefreshRate: f64,
    #[doc = "< [out] Reserved fields"]
    pub Reserved: [u32; 4usize],
}
#[test]
fn bindgen_test_layout__ctl_endurance_gaming2_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_endurance_gaming2_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_endurance_gaming2_t>(),
        48usize,
        concat!("Size of: ", stringify!(_ctl_endurance_gaming2_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_endurance_gaming2_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_endurance_gaming2_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EGControl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_endurance_gaming2_t),
            "::",
            stringify!(EGControl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EGMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_endurance_gaming2_t),
            "::",
            stringify!(EGMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsFPRequired) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_endurance_gaming2_t),
            "::",
            stringify!(IsFPRequired)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetFPS) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_endurance_gaming2_t),
            "::",
            stringify!(TargetFPS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RefreshRate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_endurance_gaming2_t),
            "::",
            stringify!(RefreshRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_endurance_gaming2_t),
            "::",
            stringify!(Reserved)
        )
    );
}
#[doc = "\n @brief Adaptive sync plus caps"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_adaptivesync_caps_t {
    #[doc = "< [out] Adaptive balance supported"]
    pub AdaptiveBalanceSupported: bool,
    #[doc = "< [out] Strength of adaptive balance algorithm - min/max/steps/default"]
    pub AdaptiveBalanceStrengthCaps: ctl_property_info_float_t,
}
#[test]
fn bindgen_test_layout__ctl_adaptivesync_caps_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_adaptivesync_caps_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_adaptivesync_caps_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_adaptivesync_caps_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_adaptivesync_caps_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_adaptivesync_caps_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AdaptiveBalanceSupported) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_adaptivesync_caps_t),
            "::",
            stringify!(AdaptiveBalanceSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AdaptiveBalanceStrengthCaps) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_adaptivesync_caps_t),
            "::",
            stringify!(AdaptiveBalanceStrengthCaps)
        )
    );
}
#[doc = "\n @brief Adaptive sync plus"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_adaptivesync_getset_t {
    #[doc = "< [in,out] Adaptive sync. Note that in Windows, OS controls state of\n< adaptive sync and which game gets the feature using it's own policies"]
    pub AdaptiveSync: bool,
    #[doc = "< [in,out] Adaptive balance"]
    pub AdaptiveBalance: bool,
    #[doc = "< [in,out] Allow async flips when FPS is higher than max refresh rate of\n< the panel"]
    pub AllowAsyncForHighFPS: bool,
    #[doc = "< [in,out] Adaptive balance strength"]
    pub AdaptiveBalanceStrength: f32,
}
#[test]
fn bindgen_test_layout__ctl_adaptivesync_getset_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_adaptivesync_getset_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_adaptivesync_getset_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ctl_adaptivesync_getset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_adaptivesync_getset_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_adaptivesync_getset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AdaptiveSync) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_adaptivesync_getset_t),
            "::",
            stringify!(AdaptiveSync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AdaptiveBalance) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_adaptivesync_getset_t),
            "::",
            stringify!(AdaptiveBalance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllowAsyncForHighFPS) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_adaptivesync_getset_t),
            "::",
            stringify!(AllowAsyncForHighFPS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AdaptiveBalanceStrength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_adaptivesync_getset_t),
            "::",
            stringify!(AdaptiveBalanceStrength)
        )
    );
}
#[doc = "\n @brief Game tier types"]
pub type ctl_3d_tier_type_flags_t = u32;
#[doc = "< Compatibility Tier"]
pub const _ctl_3d_tier_type_flag_t_CTL_3D_TIER_TYPE_FLAG_COMPATIBILITY: _ctl_3d_tier_type_flag_t =
    1;
#[doc = "< Performance Tier"]
pub const _ctl_3d_tier_type_flag_t_CTL_3D_TIER_TYPE_FLAG_PERFORMANCE: _ctl_3d_tier_type_flag_t = 2;
pub const _ctl_3d_tier_type_flag_t_CTL_3D_TIER_TYPE_FLAG_MAX: _ctl_3d_tier_type_flag_t =
    -2147483648;
pub type _ctl_3d_tier_type_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_3d_tier_type_flag_t as ctl_3d_tier_type_flag_t;
#[doc = "\n @brief Game tiers"]
pub type ctl_3d_tier_profile_flags_t = u32;
#[doc = "< Tier 1 Profile"]
pub const _ctl_3d_tier_profile_flag_t_CTL_3D_TIER_PROFILE_FLAG_TIER_1: _ctl_3d_tier_profile_flag_t =
    1;
#[doc = "< Tier 2 Profile"]
pub const _ctl_3d_tier_profile_flag_t_CTL_3D_TIER_PROFILE_FLAG_TIER_2: _ctl_3d_tier_profile_flag_t =
    2;
#[doc = "< Recommended Tier Profile. If set other tier values shouldn't be set"]
pub const _ctl_3d_tier_profile_flag_t_CTL_3D_TIER_PROFILE_FLAG_TIER_RECOMMENDED:
    _ctl_3d_tier_profile_flag_t = 1073741824;
pub const _ctl_3d_tier_profile_flag_t_CTL_3D_TIER_PROFILE_FLAG_MAX: _ctl_3d_tier_profile_flag_t =
    -2147483648;
pub type _ctl_3d_tier_profile_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_3d_tier_profile_flag_t as ctl_3d_tier_profile_flag_t;
#[doc = "\n @brief Game Profile Capabilities. Typically these remain the same across\n        games."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_3d_app_profiles_caps_t {
    #[doc = "< [out] Tier of interest for capability check"]
    pub SupportedTierTypes: ctl_3d_tier_type_flags_t,
    #[doc = "< [in,out] Reserved for future"]
    pub Reserved: u64,
}
#[test]
fn bindgen_test_layout__ctl_3d_app_profiles_caps_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_3d_app_profiles_caps_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_3d_app_profiles_caps_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ctl_3d_app_profiles_caps_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_3d_app_profiles_caps_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_3d_app_profiles_caps_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportedTierTypes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_app_profiles_caps_t),
            "::",
            stringify!(SupportedTierTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_app_profiles_caps_t),
            "::",
            stringify!(Reserved)
        )
    );
}
#[doc = "\n @brief Game Profile tiers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_3d_app_profiles_t {
    #[doc = "< [in] Tier type"]
    pub TierType: ctl_3d_tier_type_flag_t,
    #[doc = "< [out] Supported tier profiles bitmask"]
    pub SupportedTierProfiles: ctl_3d_tier_profile_flags_t,
    #[doc = "< [out] Default tiers which driver will enable if there is no user\n< specific setting for global or per application"]
    pub DefaultEnabledTierProfiles: ctl_3d_tier_profile_flags_t,
    #[doc = "< [out] Tiers supporting customization - reserved for future"]
    pub CustomizationSupportedTierProfiles: ctl_3d_tier_profile_flags_t,
    #[doc = "< [in,out] Tier profile(s) to be enabled/disabled in the case of a set\n< call. For a get call this will return the currently enabled tiers"]
    pub EnabledTierProfiles: ctl_3d_tier_profile_flags_t,
    #[doc = "< [in,out] Tier profile(s) which are customized. Caller shall call\n< ::ctl_3d_tier_details_t to get specifics if any."]
    pub CustomizationEnabledTierProfiles: ctl_3d_tier_profile_flags_t,
    #[doc = "< [in,out] Reserved for future"]
    pub Reserved: u64,
}
#[test]
fn bindgen_test_layout__ctl_3d_app_profiles_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_3d_app_profiles_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_3d_app_profiles_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ctl_3d_app_profiles_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_3d_app_profiles_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_3d_app_profiles_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TierType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_app_profiles_t),
            "::",
            stringify!(TierType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportedTierProfiles) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_app_profiles_t),
            "::",
            stringify!(SupportedTierProfiles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DefaultEnabledTierProfiles) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_app_profiles_t),
            "::",
            stringify!(DefaultEnabledTierProfiles)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CustomizationSupportedTierProfiles) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_app_profiles_t),
            "::",
            stringify!(CustomizationSupportedTierProfiles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnabledTierProfiles) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_app_profiles_t),
            "::",
            stringify!(EnabledTierProfiles)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).CustomizationEnabledTierProfiles) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_app_profiles_t),
            "::",
            stringify!(CustomizationEnabledTierProfiles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_app_profiles_t),
            "::",
            stringify!(Reserved)
        )
    );
}
#[doc = "\n @brief Game Profile tiers details"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_3d_tier_details_t {
    #[doc = "< [in] Tier type"]
    pub TierType: ctl_3d_tier_type_flag_t,
    #[doc = "< [in] Tier profile(s) for get/set details"]
    pub TierProfile: ctl_3d_tier_profile_flag_t,
    #[doc = "< [in,out] Reserved for future"]
    pub Reserved: [u64; 4usize],
}
#[test]
fn bindgen_test_layout__ctl_3d_tier_details_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_3d_tier_details_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_3d_tier_details_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ctl_3d_tier_details_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_3d_tier_details_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_3d_tier_details_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TierType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_tier_details_t),
            "::",
            stringify!(TierType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TierProfile) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_tier_details_t),
            "::",
            stringify!(TierProfile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_tier_details_t),
            "::",
            stringify!(Reserved)
        )
    );
}
#[doc = "< Default settings is based on workload/driver decision."]
pub const _ctl_emulated_typed_64bit_atomics_types_t_CTL_EMULATED_TYPED_64BIT_ATOMICS_TYPES_DEFAULT : _ctl_emulated_typed_64bit_atomics_types_t = 0 ;
#[doc = "< Force Turn on"]
pub const _ctl_emulated_typed_64bit_atomics_types_t_CTL_EMULATED_TYPED_64BIT_ATOMICS_TYPES_TURN_ON : _ctl_emulated_typed_64bit_atomics_types_t = 1 ;
#[doc = "< Force Turn off"]
pub const _ctl_emulated_typed_64bit_atomics_types_t_CTL_EMULATED_TYPED_64BIT_ATOMICS_TYPES_TURN_OFF : _ctl_emulated_typed_64bit_atomics_types_t = 2 ;
pub const _ctl_emulated_typed_64bit_atomics_types_t_CTL_EMULATED_TYPED_64BIT_ATOMICS_TYPES_MAX:
    _ctl_emulated_typed_64bit_atomics_types_t = 3;
#[doc = "\n @brief Emulated Typed 64bit Atomics"]
pub type _ctl_emulated_typed_64bit_atomics_types_t = ::std::os::raw::c_int;
#[doc = "\n @brief Emulated Typed 64bit Atomics"]
pub use self::_ctl_emulated_typed_64bit_atomics_types_t as ctl_emulated_typed_64bit_atomics_types_t;
#[doc = "\n @brief 3D feature capability details which will have range/supported and\n        default values"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_3d_feature_details_t {
    #[doc = "< [out] 3D feature type"]
    pub FeatureType: ctl_3d_feature_t,
    #[doc = "< [out] Type of value"]
    pub ValueType: ctl_property_value_type_t,
    #[doc = "< [out] Union of various type of values for 3D features. For enum types\n< this can be anisotropic/frame pacing etc. This member is valid iff\n< ValueType is not CTL_PROPERTY_VALUE_TYPE_CUSTOM"]
    pub Value: ctl_property_info_t,
    #[doc = "< [in] CustomValue buffer size. Typically for a feature requiring custom\n< struct, caller will know of it upfront and can provide the right size\n< info here"]
    pub CustomValueSize: i32,
    #[doc = "< [in,out] Pointer to a custom structure. Caller should allocate this\n< buffer with known custom feature structure size. This member is valid\n< iff ValueType is CTL_PROPERTY_VALUE_TYPE_CUSTOM"]
    pub pCustomValue: *mut ::std::os::raw::c_void,
    #[doc = "< [out] Flag indicating whether the feature is supported per application\n< or not"]
    pub PerAppSupport: bool,
    #[doc = "< [out] Mask of ::ctl_3d_feature_t values which can't be enabled along\n< with the mentioned FeatureType. If this is 0, it meant the feature\n< doesn't have any conflicts with other features"]
    pub ConflictingFeatures: i64,
    #[doc = "< [out] 3D Feature Miscellaneous support flags. This will be based on\n< ::ctl_3d_feature_misc_flags_t"]
    pub FeatureMiscSupport: i16,
    #[doc = "< [out] Reserved"]
    pub Reserved: i16,
    #[doc = "< [out] Reserved"]
    pub Reserved1: i16,
    #[doc = "< [out] Reserved"]
    pub Reserved2: i16,
}
#[test]
fn bindgen_test_layout__ctl_3d_feature_details_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_3d_feature_details_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_3d_feature_details_t>(),
        72usize,
        concat!("Size of: ", stringify!(_ctl_3d_feature_details_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_3d_feature_details_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_3d_feature_details_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FeatureType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_details_t),
            "::",
            stringify!(FeatureType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValueType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_details_t),
            "::",
            stringify!(ValueType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_details_t),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CustomValueSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_details_t),
            "::",
            stringify!(CustomValueSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCustomValue) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_details_t),
            "::",
            stringify!(pCustomValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PerAppSupport) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_details_t),
            "::",
            stringify!(PerAppSupport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConflictingFeatures) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_details_t),
            "::",
            stringify!(ConflictingFeatures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FeatureMiscSupport) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_details_t),
            "::",
            stringify!(FeatureMiscSupport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_details_t),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_details_t),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_details_t),
            "::",
            stringify!(Reserved2)
        )
    );
}
#[doc = "\n @brief 3D feature which are controllable"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_3d_feature_caps_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Number of elements in supported features array"]
    pub NumSupportedFeatures: u32,
    #[doc = "< [in,out] Array of feature details"]
    pub pFeatureDetails: *mut ctl_3d_feature_details_t,
}
#[test]
fn bindgen_test_layout__ctl_3d_feature_caps_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_3d_feature_caps_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_3d_feature_caps_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_3d_feature_caps_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_3d_feature_caps_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_3d_feature_caps_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_caps_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_caps_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumSupportedFeatures) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_caps_t),
            "::",
            stringify!(NumSupportedFeatures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pFeatureDetails) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_caps_t),
            "::",
            stringify!(pFeatureDetails)
        )
    );
}
#[doc = "\n @brief 3D feature for get/set"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_3d_feature_getset_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Features interested in"]
    pub FeatureType: ctl_3d_feature_t,
    #[doc = "< [in] Application name for which the property type is applicable. If\n< this is an empty string then this will get/set global settings for the\n< given adapter. Note that this should contain only the name of the\n< application and not the system specific path"]
    pub ApplicationName: *mut ::std::os::raw::c_char,
    #[doc = "< [in] Length of ApplicationName string"]
    pub ApplicationNameLength: i8,
    #[doc = "< [in] Set this if it's a set call"]
    pub bSet: bool,
    #[doc = "< [in] Type of value. Caller has to ensure it provides the right value\n< type which decides how one read the union structure below"]
    pub ValueType: ctl_property_value_type_t,
    #[doc = "< [in,out] Union of various type of values for 3D features. For enum\n< types this can be anisotropic/frame pacing etc. This member is valid\n< iff ValueType is not CTL_PROPERTY_VALUE_TYPE_CUSTOM"]
    pub Value: ctl_property_t,
    #[doc = "< [in] CustomValue buffer size. Typically for a feature requiring custom\n< struct, caller will know of it upfront and cn provide the right size\n< info here"]
    pub CustomValueSize: i32,
    #[doc = "< [in,out] Pointer to a custom structure. Caller should allocate this\n< buffer with known custom feature structure size. This member is valid\n< iff ValueType is CTL_PROPERTY_VALUE_TYPE_CUSTOM"]
    pub pCustomValue: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__ctl_3d_feature_getset_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_3d_feature_getset_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_3d_feature_getset_t>(),
        56usize,
        concat!("Size of: ", stringify!(_ctl_3d_feature_getset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_3d_feature_getset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_3d_feature_getset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_getset_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_getset_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FeatureType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_getset_t),
            "::",
            stringify!(FeatureType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApplicationName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_getset_t),
            "::",
            stringify!(ApplicationName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApplicationNameLength) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_getset_t),
            "::",
            stringify!(ApplicationNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bSet) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_getset_t),
            "::",
            stringify!(bSet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValueType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_getset_t),
            "::",
            stringify!(ValueType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_getset_t),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CustomValueSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_getset_t),
            "::",
            stringify!(CustomValueSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCustomValue) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_3d_feature_getset_t),
            "::",
            stringify!(pCustomValue)
        )
    );
}
#[doc = "\n @brief Load KMD gaming features. Restricted function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_kmd_load_features_t {
    #[doc = "< [in] Unique ID for reserved/special function"]
    pub ReservedFuncID: ctl_application_id_t,
    #[doc = "< [in] If set, will load known KMD features. If not set will reset known\n< KMD features to default"]
    pub bLoad: bool,
    #[doc = "< [in,out] Mask indicating the subset of KMD features within\n< ::ctl_3d_feature_t values. Default of 0 indicate all KMD features"]
    pub SubsetFeatureMask: i64,
    #[doc = "< [in] Application name for which the KMD properties are loaded for. If\n< this is an empty string then this will load global settings for the\n< given adapter. Note that this should contain only the name of the\n< application and not the system specific path"]
    pub ApplicationName: *mut ::std::os::raw::c_char,
    #[doc = "< [in] Length of ApplicationName string"]
    pub ApplicationNameLength: i8,
}
#[test]
fn bindgen_test_layout__ctl_kmd_load_features_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_kmd_load_features_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_kmd_load_features_t>(),
        48usize,
        concat!("Size of: ", stringify!(_ctl_kmd_load_features_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_kmd_load_features_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_kmd_load_features_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFuncID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_kmd_load_features_t),
            "::",
            stringify!(ReservedFuncID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bLoad) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_kmd_load_features_t),
            "::",
            stringify!(bLoad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SubsetFeatureMask) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_kmd_load_features_t),
            "::",
            stringify!(SubsetFeatureMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApplicationName) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_kmd_load_features_t),
            "::",
            stringify!(ApplicationName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApplicationNameLength) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_kmd_load_features_t),
            "::",
            stringify!(ApplicationNameLength)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get 3D capabilities\n\n @details\n     - The application gets 3D properties\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pFeatureCaps`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetSupported3DCapabilities(
        hDAhandle: ctl_device_adapter_handle_t,
        pFeatureCaps: *mut ctl_3d_feature_caps_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get/Set 3D feature\n\n @details\n     - 3D feature details\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pFeature`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetSet3DFeature(
        hDAhandle: ctl_device_adapter_handle_t,
        pFeature: *mut ctl_3d_feature_getset_t,
    ) -> ctl_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_display_output_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a display output instance"]
pub type ctl_display_output_handle_t = *mut _ctl_display_output_handle_t;
extern "C" {
    #[doc = "\n @brief Check Driver version\n\n @details\n     - The application checks driver version\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceAdapter`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlCheckDriverVersion(
        hDeviceAdapter: ctl_device_adapter_handle_t,
        version_info: ctl_version_info_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Enumerate devices\n\n @details\n     - The application enumerates all device adapters in the system\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hAPIHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlEnumerateDevices(
        hAPIHandle: ctl_api_handle_t,
        pCount: *mut u32,
        phDevices: *mut ctl_device_adapter_handle_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Enumerate display outputs\n\n @details\n     - Enumerates display output capabilities\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceAdapter`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlEnumerateDisplayOutputs(
        hDeviceAdapter: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phDisplayOutputs: *mut ctl_display_output_handle_t,
    ) -> ctl_result_t;
}
#[doc = "\n @brief OS specific Display identifiers"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ctl_os_display_encoder_identifier_t {
    #[doc = "< [out] Windows OS Display encoder ID"]
    pub WindowsDisplayEncoderID: u32,
    #[doc = "< [out] Display encoder ID for non-windows OS"]
    pub DisplayEncoderID: ctl_generic_void_datatype_t,
}
#[test]
fn bindgen_test_layout__ctl_os_display_encoder_identifier_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_os_display_encoder_identifier_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_os_display_encoder_identifier_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_os_display_encoder_identifier_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_os_display_encoder_identifier_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_os_display_encoder_identifier_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WindowsDisplayEncoderID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_os_display_encoder_identifier_t),
            "::",
            stringify!(WindowsDisplayEncoderID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayEncoderID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_os_display_encoder_identifier_t),
            "::",
            stringify!(DisplayEncoderID)
        )
    );
}
#[doc = "\n @brief OS specific Display identifiers"]
pub type ctl_os_display_encoder_identifier_t = _ctl_os_display_encoder_identifier_t;
#[doc = "< Invalid"]
pub const _ctl_display_output_types_t_CTL_DISPLAY_OUTPUT_TYPES_INVALID:
    _ctl_display_output_types_t = 0;
#[doc = "< DisplayPort"]
pub const _ctl_display_output_types_t_CTL_DISPLAY_OUTPUT_TYPES_DISPLAYPORT:
    _ctl_display_output_types_t = 1;
#[doc = "< HDMI"]
pub const _ctl_display_output_types_t_CTL_DISPLAY_OUTPUT_TYPES_HDMI: _ctl_display_output_types_t =
    2;
#[doc = "< DVI"]
pub const _ctl_display_output_types_t_CTL_DISPLAY_OUTPUT_TYPES_DVI: _ctl_display_output_types_t = 3;
#[doc = "< MIPI"]
pub const _ctl_display_output_types_t_CTL_DISPLAY_OUTPUT_TYPES_MIPI: _ctl_display_output_types_t =
    4;
#[doc = "< CRT"]
pub const _ctl_display_output_types_t_CTL_DISPLAY_OUTPUT_TYPES_CRT: _ctl_display_output_types_t = 5;
pub const _ctl_display_output_types_t_CTL_DISPLAY_OUTPUT_TYPES_MAX: _ctl_display_output_types_t = 6;
#[doc = "\n @brief Various display types"]
pub type _ctl_display_output_types_t = ::std::os::raw::c_int;
#[doc = "\n @brief Various display types"]
pub use self::_ctl_display_output_types_t as ctl_display_output_types_t;
#[doc = "\n @brief Supported output bits per color (bpc) bitmasks"]
pub type ctl_output_bpc_flags_t = u32;
#[doc = "< [out] Is 6bpc supported"]
pub const _ctl_output_bpc_flag_t_CTL_OUTPUT_BPC_FLAG_6BPC: _ctl_output_bpc_flag_t = 1;
#[doc = "< [out] Is 8bpc supported"]
pub const _ctl_output_bpc_flag_t_CTL_OUTPUT_BPC_FLAG_8BPC: _ctl_output_bpc_flag_t = 2;
#[doc = "< [out] Is 10bpc supported"]
pub const _ctl_output_bpc_flag_t_CTL_OUTPUT_BPC_FLAG_10BPC: _ctl_output_bpc_flag_t = 4;
#[doc = "< [out] Is 12bpc supported"]
pub const _ctl_output_bpc_flag_t_CTL_OUTPUT_BPC_FLAG_12BPC: _ctl_output_bpc_flag_t = 8;
pub const _ctl_output_bpc_flag_t_CTL_OUTPUT_BPC_FLAG_MAX: _ctl_output_bpc_flag_t = -2147483648;
pub type _ctl_output_bpc_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_output_bpc_flag_t as ctl_output_bpc_flag_t;
#[doc = "\n @brief Display output features. This will indicate only the high level\n        capabilities"]
pub type ctl_std_display_feature_flags_t = u32;
#[doc = "< [out] Is HDCP supported"]
pub const _ctl_std_display_feature_flag_t_CTL_STD_DISPLAY_FEATURE_FLAG_HDCP:
    _ctl_std_display_feature_flag_t = 1;
#[doc = "< [out] Is HD Audio supported"]
pub const _ctl_std_display_feature_flag_t_CTL_STD_DISPLAY_FEATURE_FLAG_HD_AUDIO:
    _ctl_std_display_feature_flag_t = 2;
#[doc = "< [out] Is VESA PSR supported"]
pub const _ctl_std_display_feature_flag_t_CTL_STD_DISPLAY_FEATURE_FLAG_PSR:
    _ctl_std_display_feature_flag_t = 4;
#[doc = "< [out] Is VESA Adaptive Sync or HDMI VRR supported"]
pub const _ctl_std_display_feature_flag_t_CTL_STD_DISPLAY_FEATURE_FLAG_ADAPTIVESYNC_VRR:
    _ctl_std_display_feature_flag_t = 8;
#[doc = "< [out] Is display compression (VESA DSC) supported"]
pub const _ctl_std_display_feature_flag_t_CTL_STD_DISPLAY_FEATURE_FLAG_VESA_COMPRESSION:
    _ctl_std_display_feature_flag_t = 16;
#[doc = "< [out] Is HDR supported"]
pub const _ctl_std_display_feature_flag_t_CTL_STD_DISPLAY_FEATURE_FLAG_HDR:
    _ctl_std_display_feature_flag_t = 32;
#[doc = "< [out] Is HDMI QMS supported"]
pub const _ctl_std_display_feature_flag_t_CTL_STD_DISPLAY_FEATURE_FLAG_HDMI_QMS:
    _ctl_std_display_feature_flag_t = 64;
pub const _ctl_std_display_feature_flag_t_CTL_STD_DISPLAY_FEATURE_FLAG_MAX:
    _ctl_std_display_feature_flag_t = -2147483648;
pub type _ctl_std_display_feature_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_std_display_feature_flag_t as ctl_std_display_feature_flag_t;
#[doc = "\n @brief Advanced Graphics Features provided by Intel Graphics Adapter. This\n        will indicate only the high level capabilities"]
pub type ctl_intel_display_feature_flags_t = u32;
#[doc = "< [out] Is DPST supported"]
pub const _ctl_intel_display_feature_flag_t_CTL_INTEL_DISPLAY_FEATURE_FLAG_DPST:
    _ctl_intel_display_feature_flag_t = 1;
#[doc = "< [out] Is LACE supported"]
pub const _ctl_intel_display_feature_flag_t_CTL_INTEL_DISPLAY_FEATURE_FLAG_LACE:
    _ctl_intel_display_feature_flag_t = 2;
#[doc = "< [out] Is DRRS supported"]
pub const _ctl_intel_display_feature_flag_t_CTL_INTEL_DISPLAY_FEATURE_FLAG_DRRS:
    _ctl_intel_display_feature_flag_t = 4;
pub const _ctl_intel_display_feature_flag_t_CTL_INTEL_DISPLAY_FEATURE_FLAG_MAX:
    _ctl_intel_display_feature_flag_t = -2147483648;
pub type _ctl_intel_display_feature_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_intel_display_feature_flag_t as ctl_intel_display_feature_flag_t;
#[doc = "< [out] Native DP / HDMI"]
pub const _ctl_attached_display_mux_type_t_CTL_ATTACHED_DISPLAY_MUX_TYPE_NATIVE:
    _ctl_attached_display_mux_type_t = 0;
#[doc = "< [out] Thunderbolt"]
pub const _ctl_attached_display_mux_type_t_CTL_ATTACHED_DISPLAY_MUX_TYPE_THUNDERBOLT:
    _ctl_attached_display_mux_type_t = 1;
#[doc = "< [out] USB Type C"]
pub const _ctl_attached_display_mux_type_t_CTL_ATTACHED_DISPLAY_MUX_TYPE_TYPE_C:
    _ctl_attached_display_mux_type_t = 2;
#[doc = "< [out] USB4"]
pub const _ctl_attached_display_mux_type_t_CTL_ATTACHED_DISPLAY_MUX_TYPE_USB4:
    _ctl_attached_display_mux_type_t = 3;
pub const _ctl_attached_display_mux_type_t_CTL_ATTACHED_DISPLAY_MUX_TYPE_MAX:
    _ctl_attached_display_mux_type_t = 4;
#[doc = "\n @brief Attached Display Mux Type"]
pub type _ctl_attached_display_mux_type_t = ::std::os::raw::c_int;
#[doc = "\n @brief Attached Display Mux Type"]
pub use self::_ctl_attached_display_mux_type_t as ctl_attached_display_mux_type_t;
#[doc = "< [out] Unknown Signal Standard"]
pub const _ctl_signal_standard_type_t_CTL_SIGNAL_STANDARD_TYPE_UNKNOWN:
    _ctl_signal_standard_type_t = 0;
#[doc = "< [out] Custom added timing"]
pub const _ctl_signal_standard_type_t_CTL_SIGNAL_STANDARD_TYPE_CUSTOM: _ctl_signal_standard_type_t =
    1;
#[doc = "< [out] DMT timing"]
pub const _ctl_signal_standard_type_t_CTL_SIGNAL_STANDARD_TYPE_DMT: _ctl_signal_standard_type_t = 2;
#[doc = "< [out] GTF Timing"]
pub const _ctl_signal_standard_type_t_CTL_SIGNAL_STANDARD_TYPE_GTF: _ctl_signal_standard_type_t = 3;
#[doc = "< [out] CVT Timing"]
pub const _ctl_signal_standard_type_t_CTL_SIGNAL_STANDARD_TYPE_CVT: _ctl_signal_standard_type_t = 4;
#[doc = "< [out] CTA Timing"]
pub const _ctl_signal_standard_type_t_CTL_SIGNAL_STANDARD_TYPE_CTA: _ctl_signal_standard_type_t = 5;
pub const _ctl_signal_standard_type_t_CTL_SIGNAL_STANDARD_TYPE_MAX: _ctl_signal_standard_type_t = 6;
#[doc = "\n @brief Signal Standard"]
pub type _ctl_signal_standard_type_t = ::std::os::raw::c_int;
#[doc = "\n @brief Signal Standard"]
pub use self::_ctl_signal_standard_type_t as ctl_signal_standard_type_t;
#[doc = "\n @brief Protocol Converter Location"]
pub type ctl_protocol_converter_location_flags_t = u32;
#[doc = "< [out] OnBoard Protocol Converter"]
pub const _ctl_protocol_converter_location_flag_t_CTL_PROTOCOL_CONVERTER_LOCATION_FLAG_ONBOARD:
    _ctl_protocol_converter_location_flag_t = 1;
#[doc = "< [out] External Dongle"]
pub const _ctl_protocol_converter_location_flag_t_CTL_PROTOCOL_CONVERTER_LOCATION_FLAG_EXTERNAL:
    _ctl_protocol_converter_location_flag_t = 2;
pub const _ctl_protocol_converter_location_flag_t_CTL_PROTOCOL_CONVERTER_LOCATION_FLAG_MAX:
    _ctl_protocol_converter_location_flag_t = -2147483648;
pub type _ctl_protocol_converter_location_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_protocol_converter_location_flag_t as ctl_protocol_converter_location_flag_t;
#[doc = "\n @brief [out] Display Output configuration related flags which indicate how\n        the output pixel stream drive the panel"]
pub type ctl_display_config_flags_t = u32;
#[doc = "< [out] DisplayActive 0: InActive 1: Active"]
pub const _ctl_display_config_flag_t_CTL_DISPLAY_CONFIG_FLAG_DISPLAY_ACTIVE:
    _ctl_display_config_flag_t = 1;
#[doc = "< [out] DisplayAttached.This Bit indicates if any dongle/display/hub is\n< attached to the encoder. 0: Not Attached 1: Attached"]
pub const _ctl_display_config_flag_t_CTL_DISPLAY_CONFIG_FLAG_DISPLAY_ATTACHED:
    _ctl_display_config_flag_t = 2;
#[doc = "< [out] This BIT will be set if a dongle/hub/onboard protocol converter\n< , is attached to the encoder"]
pub const _ctl_display_config_flag_t_CTL_DISPLAY_CONFIG_FLAG_IS_DONGLE_CONNECTED_TO_ENCODER:
    _ctl_display_config_flag_t = 4;
#[doc = "< [out] This BIT will be set if dithering is enabled on the encoder"]
pub const _ctl_display_config_flag_t_CTL_DISPLAY_CONFIG_FLAG_DITHERING_ENABLED:
    _ctl_display_config_flag_t = 8;
pub const _ctl_display_config_flag_t_CTL_DISPLAY_CONFIG_FLAG_MAX: _ctl_display_config_flag_t =
    -2147483648;
pub type _ctl_display_config_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_display_config_flag_t as ctl_display_config_flag_t;
#[doc = "\n @brief [out] Encoder configuration related flags which indicate how the\n        output pixel stream drive the panel"]
pub type ctl_encoder_config_flags_t = u32;
#[doc = "< [out] Internal connection or not"]
pub const _ctl_encoder_config_flag_t_CTL_ENCODER_CONFIG_FLAG_INTERNAL_DISPLAY:
    _ctl_encoder_config_flag_t = 1;
#[doc = "< [out] VESA DisplayID based tiled display which is driven by either\n< multiple physical connections (DisplayPort SST) or virtual streams\n< (DisplayPort MST)"]
pub const _ctl_encoder_config_flag_t_CTL_ENCODER_CONFIG_FLAG_VESA_TILED_DISPLAY:
    _ctl_encoder_config_flag_t = 2;
#[doc = "< [out] This is set if encoder supports type c display"]
pub const _ctl_encoder_config_flag_t_CTL_ENCODER_CONFIG_FLAG_TYPEC_CAPABLE:
    _ctl_encoder_config_flag_t = 4;
#[doc = "< [out] This is set if encoder supports Thunderbolt display"]
pub const _ctl_encoder_config_flag_t_CTL_ENCODER_CONFIG_FLAG_TBT_CAPABLE:
    _ctl_encoder_config_flag_t = 8;
#[doc = "< [out] This BIT will be set if encoder supports dithering"]
pub const _ctl_encoder_config_flag_t_CTL_ENCODER_CONFIG_FLAG_DITHERING_SUPPORTED:
    _ctl_encoder_config_flag_t = 16;
#[doc = "< [out] This BIT will be set if this is a virtual display.Hardware based\n< features will not be applicable to this display.For collage display\n< this will be set for the virtual output created by driver. For split\n< display this will be set for the virtual split displays created out of\n< one single physical display"]
pub const _ctl_encoder_config_flag_t_CTL_ENCODER_CONFIG_FLAG_VIRTUAL_DISPLAY:
    _ctl_encoder_config_flag_t = 32;
#[doc = "< [out] This BIT will be set if display is hidden from OS"]
pub const _ctl_encoder_config_flag_t_CTL_ENCODER_CONFIG_FLAG_HIDDEN_DISPLAY:
    _ctl_encoder_config_flag_t = 64;
#[doc = "< [out] This BIT will be set if this is a collage display"]
pub const _ctl_encoder_config_flag_t_CTL_ENCODER_CONFIG_FLAG_COLLAGE_DISPLAY:
    _ctl_encoder_config_flag_t = 128;
#[doc = "< [out] This BIT will be set if this is a split display"]
pub const _ctl_encoder_config_flag_t_CTL_ENCODER_CONFIG_FLAG_SPLIT_DISPLAY:
    _ctl_encoder_config_flag_t = 256;
#[doc = "< [out] This BIT will be set if this is a companion display"]
pub const _ctl_encoder_config_flag_t_CTL_ENCODER_CONFIG_FLAG_COMPANION_DISPLAY:
    _ctl_encoder_config_flag_t = 512;
pub const _ctl_encoder_config_flag_t_CTL_ENCODER_CONFIG_FLAG_MAX: _ctl_encoder_config_flag_t =
    -2147483648;
pub type _ctl_encoder_config_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_encoder_config_flag_t as ctl_encoder_config_flag_t;
#[doc = "\n @brief Display Timing"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_display_timing_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Pixel Clock in Hz"]
    pub PixelClock: u64,
    #[doc = "< [out] Horizontal Active"]
    pub HActive: u32,
    #[doc = "< [out] Vertical Active"]
    pub VActive: u32,
    #[doc = "< [out] Horizontal Total"]
    pub HTotal: u32,
    #[doc = "< [out] Vertical Total"]
    pub VTotal: u32,
    #[doc = "< [out] Horizontal Blank"]
    pub HBlank: u32,
    #[doc = "< [out] Vertical Blank"]
    pub VBlank: u32,
    #[doc = "< [out] Horizontal Blank"]
    pub HSync: u32,
    #[doc = "< [out] Vertical Blank"]
    pub VSync: u32,
    #[doc = "< [out] Refresh Rate"]
    pub RefreshRate: f32,
    #[doc = "< [out] Signal Standard"]
    pub SignalStandard: ctl_signal_standard_type_t,
    #[doc = "< [out] VIC ID for CTA timings"]
    pub VicId: u8,
}
#[test]
fn bindgen_test_layout__ctl_display_timing_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_display_timing_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_display_timing_t>(),
        64usize,
        concat!("Size of: ", stringify!(_ctl_display_timing_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_display_timing_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_display_timing_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_timing_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_timing_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PixelClock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_timing_t),
            "::",
            stringify!(PixelClock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HActive) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_timing_t),
            "::",
            stringify!(HActive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VActive) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_timing_t),
            "::",
            stringify!(VActive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HTotal) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_timing_t),
            "::",
            stringify!(HTotal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VTotal) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_timing_t),
            "::",
            stringify!(VTotal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HBlank) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_timing_t),
            "::",
            stringify!(HBlank)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VBlank) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_timing_t),
            "::",
            stringify!(VBlank)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HSync) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_timing_t),
            "::",
            stringify!(HSync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VSync) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_timing_t),
            "::",
            stringify!(VSync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RefreshRate) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_timing_t),
            "::",
            stringify!(RefreshRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SignalStandard) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_timing_t),
            "::",
            stringify!(SignalStandard)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VicId) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_timing_t),
            "::",
            stringify!(VicId)
        )
    );
}
#[doc = "\n @brief This structure will contain the properties of the display currently\n        attached to the encoder."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_display_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] OS specific Display ID"]
    pub Os_display_encoder_handle: ctl_os_display_encoder_identifier_t,
    #[doc = "< [out] Device Type from display HW stand point. If a DisplayPort\n< protocol converter is involved, this will indicate it's DisplayPort.\n< The protocol converter's output will be available from\n< ProtocolConverterOutput field"]
    pub Type: ctl_display_output_types_t,
    #[doc = "< [out] Attached Display Mux Type"]
    pub AttachedDisplayMuxType: ctl_attached_display_mux_type_t,
    #[doc = "< [out] Protocol output type which can be used if config flags indicate\n< it's a protocol converter. If it's not a protocol converter this will\n< be set to CTL_DISPLAY_OUTPUT_TYPES_INVALID"]
    pub ProtocolConverterOutput: ctl_display_output_types_t,
    #[doc = "< [out] Supported industry spec version."]
    pub SupportedSpec: ctl_revision_datatype_t,
    #[doc = "< [out] Supported output bits per color. Refer ::ctl_output_bpc_flag_t.\n< This is independent of RGB or YCbCr output.This is the max BPC\n< supported.BPC will vary per mode based on restrictions like bandwidth\n< and monitor support"]
    pub SupportedOutputBPCFlags: ctl_output_bpc_flags_t,
    #[doc = "< [out] Currently Active Protocol Converter. Refer\n< ::ctl_protocol_converter_location_flag_t"]
    pub ProtocolConverterType: ctl_protocol_converter_location_flags_t,
    #[doc = "< [out] Output configuration related flags which indicate how the output\n< pixel stream drive the panel. Refer ::ctl_display_config_flag_t"]
    pub DisplayConfigFlags: ctl_display_config_flags_t,
    #[doc = "< [out] Enabled Display features.Refer ::ctl_std_display_feature_flag_t."]
    pub FeatureEnabledFlags: ctl_std_display_feature_flags_t,
    #[doc = "< [out] Display Supported feature.Refer ::ctl_std_display_feature_flag_t"]
    pub FeatureSupportedFlags: ctl_std_display_feature_flags_t,
    #[doc = "< [out] Enabled advanced feature.Refer\n< ::ctl_intel_display_feature_flag_t."]
    pub AdvancedFeatureEnabledFlags: ctl_intel_display_feature_flags_t,
    #[doc = "< [out] Supported advanced feature.Refer\n< ::ctl_intel_display_feature_flag_t."]
    pub AdvancedFeatureSupportedFlags: ctl_intel_display_feature_flags_t,
    #[doc = "< [out] Applied Timing on the Display"]
    pub Display_Timing_Info: ctl_display_timing_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[test]
fn bindgen_test_layout__ctl_display_properties_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_display_properties_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_display_properties_t>(),
        200usize,
        concat!("Size of: ", stringify!(_ctl_display_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_display_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_display_properties_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_properties_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_properties_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Os_display_encoder_handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_properties_t),
            "::",
            stringify!(Os_display_encoder_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_properties_t),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AttachedDisplayMuxType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_properties_t),
            "::",
            stringify!(AttachedDisplayMuxType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProtocolConverterOutput) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_properties_t),
            "::",
            stringify!(ProtocolConverterOutput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportedSpec) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_properties_t),
            "::",
            stringify!(SupportedSpec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportedOutputBPCFlags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_properties_t),
            "::",
            stringify!(SupportedOutputBPCFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProtocolConverterType) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_properties_t),
            "::",
            stringify!(ProtocolConverterType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayConfigFlags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_properties_t),
            "::",
            stringify!(DisplayConfigFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FeatureEnabledFlags) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_properties_t),
            "::",
            stringify!(FeatureEnabledFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FeatureSupportedFlags) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_properties_t),
            "::",
            stringify!(FeatureSupportedFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AdvancedFeatureEnabledFlags) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_properties_t),
            "::",
            stringify!(AdvancedFeatureEnabledFlags)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).AdvancedFeatureSupportedFlags) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_properties_t),
            "::",
            stringify!(AdvancedFeatureSupportedFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Display_Timing_Info) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_properties_t),
            "::",
            stringify!(Display_Timing_Info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_display_properties_t),
            "::",
            stringify!(ReservedFields)
        )
    );
}
#[doc = "\n @brief Adapter's display encoder properties"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_adapter_display_encoder_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] OS specific Display ID"]
    pub Os_display_encoder_handle: ctl_os_display_encoder_identifier_t,
    #[doc = "< [out] Device Type from display HW stand point. If a DisplayPort\n< protocol converter is involved, this will indicate it's DisplayPort.\n< The protocol converter's output will be available from\n< ProtocolConverterOutput field"]
    pub Type: ctl_display_output_types_t,
    #[doc = "< [out] Protocol output type which can be used if it's a protocol\n< converter. If it's not a protocol converter this will be set to\n< CTL_DISPLAY_OUTPUT_TYPES_INVALID"]
    pub IsOnBoardProtocolConverterOutputPresent: bool,
    #[doc = "< [out] Supported industry spec version"]
    pub SupportedSpec: ctl_revision_datatype_t,
    #[doc = "< [out] Supported output bits per color. Refer ::ctl_output_bpc_flag_t.\n< This is independent of RGB or YCbCr output.This is the max BPC\n< supported.BPC will vary per mode based on restrictions like bandwidth\n< and monitor support"]
    pub SupportedOutputBPCFlags: ctl_output_bpc_flags_t,
    #[doc = "< [out] Output configuration related flags which indicate how the output\n< pixel stream drive the panel. Refer ::ctl_encoder_config_flag_t\n< Note:\n<    Virtual = 1: This indicates that its a software display. Hardware\n< based features will not be applicable to this display.\n<    Collage=1,Virtual=1: Indicates the fake display output created by\n< driver which has the combined resolution of multiple physical displays\n< involved in collage configuration\n<    Collage=1,Virtual=0: Indicates the child physical displays involved\n< in a collage configuration. These are real physical outputs\n<    Split=1,Virtual=1  : Indicates the fake display output created by\n< driver which occupies a portion of a real physical display\n<    Split=1,Virtual=0  : Indicates the physical display which got split\n< to form multiple split displays\n<    Split=1,Collage=1  : Invalid combination"]
    pub EncoderConfigFlags: ctl_encoder_config_flags_t,
    #[doc = "< [out] Adapter Supported feature flags. Refer\n< ::ctl_std_display_feature_flag_t"]
    pub FeatureSupportedFlags: ctl_std_display_feature_flags_t,
    #[doc = "< [out] Advanced Features Supported by the Adapter. Refer\n< ::ctl_intel_display_feature_flag_t"]
    pub AdvancedFeatureSupportedFlags: ctl_intel_display_feature_flags_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[test]
fn bindgen_test_layout__ctl_adapter_display_encoder_properties_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_adapter_display_encoder_properties_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_adapter_display_encoder_properties_t>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_adapter_display_encoder_properties_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_adapter_display_encoder_properties_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_adapter_display_encoder_properties_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_adapter_display_encoder_properties_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_adapter_display_encoder_properties_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Os_display_encoder_handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_adapter_display_encoder_properties_t),
            "::",
            stringify!(Os_display_encoder_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_adapter_display_encoder_properties_t),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).IsOnBoardProtocolConverterOutputPresent) as usize
                - ptr as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_adapter_display_encoder_properties_t),
            "::",
            stringify!(IsOnBoardProtocolConverterOutputPresent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportedSpec) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_adapter_display_encoder_properties_t),
            "::",
            stringify!(SupportedSpec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportedOutputBPCFlags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_adapter_display_encoder_properties_t),
            "::",
            stringify!(SupportedOutputBPCFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EncoderConfigFlags) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_adapter_display_encoder_properties_t),
            "::",
            stringify!(EncoderConfigFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FeatureSupportedFlags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_adapter_display_encoder_properties_t),
            "::",
            stringify!(FeatureSupportedFlags)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).AdvancedFeatureSupportedFlags) as usize - ptr as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_adapter_display_encoder_properties_t),
            "::",
            stringify!(AdvancedFeatureSupportedFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_adapter_display_encoder_properties_t),
            "::",
            stringify!(ReservedFields)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get Device Properties\n\n @details\n     - The application gets device properties\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetDeviceProperties(
        hDAhandle: ctl_device_adapter_handle_t,
        pProperties: *mut ctl_device_adapter_properties_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get Display  Properties\n\n @details\n     - The application gets display  properties\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetDisplayProperties(
        hDisplayOutput: ctl_display_output_handle_t,
        pProperties: *mut ctl_display_properties_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get Adapter Display encoder  Properties\n\n @details\n     - The application gets the graphic adapters display encoder properties\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetAdaperDisplayEncoderProperties(
        hDisplayOutput: ctl_display_output_handle_t,
        pProperties: *mut ctl_adapter_display_encoder_properties_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get Level0 Device handle\n\n @details\n     - The application gets OneAPI Level0 Device handles\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pZeDevice`\n         + `nullptr == hInstance`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetZeDevice(
        hDAhandle: ctl_device_adapter_handle_t,
        pZeDevice: *mut ::std::os::raw::c_void,
        hInstance: *mut *mut ::std::os::raw::c_void,
    ) -> ctl_result_t;
}
#[doc = "\n @brief Various sharpness filter types"]
pub type ctl_sharpness_filter_type_flags_t = u32;
#[doc = "< Non-adaptive sharpness"]
pub const _ctl_sharpness_filter_type_flag_t_CTL_SHARPNESS_FILTER_TYPE_FLAG_NON_ADAPTIVE:
    _ctl_sharpness_filter_type_flag_t = 1;
#[doc = "< Adaptive sharpness"]
pub const _ctl_sharpness_filter_type_flag_t_CTL_SHARPNESS_FILTER_TYPE_FLAG_ADAPTIVE:
    _ctl_sharpness_filter_type_flag_t = 2;
pub const _ctl_sharpness_filter_type_flag_t_CTL_SHARPNESS_FILTER_TYPE_FLAG_MAX:
    _ctl_sharpness_filter_type_flag_t = -2147483648;
pub type _ctl_sharpness_filter_type_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_sharpness_filter_type_flag_t as ctl_sharpness_filter_type_flag_t;
#[doc = "\n @brief Sharpness filter properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_sharpness_filter_properties_t {
    #[doc = "< [out] Filter type. Refer ::ctl_sharpness_filter_type_flag_t"]
    pub FilterType: ctl_sharpness_filter_type_flags_t,
    #[doc = "< [out] Min, max & step size information"]
    pub FilterDetails: ctl_property_range_info_t,
}
#[test]
fn bindgen_test_layout__ctl_sharpness_filter_properties_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_sharpness_filter_properties_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_sharpness_filter_properties_t>(),
        20usize,
        concat!("Size of: ", stringify!(_ctl_sharpness_filter_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_sharpness_filter_properties_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_sharpness_filter_properties_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FilterType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_sharpness_filter_properties_t),
            "::",
            stringify!(FilterType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FilterDetails) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_sharpness_filter_properties_t),
            "::",
            stringify!(FilterDetails)
        )
    );
}
#[doc = "\n @brief Various sharpness filter types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_sharpness_caps_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Supported sharpness filters for a given display output. Refer\n< ::ctl_sharpness_filter_type_flag_t"]
    pub SupportedFilterFlags: ctl_sharpness_filter_type_flags_t,
    #[doc = "< [out] Number of elements in filter properties array"]
    pub NumFilterTypes: u8,
    #[doc = "< [in,out] Array of filter properties structure describing supported\n< filter capabilities. Caller should provide a pre-allocated memory for\n< this."]
    pub pFilterProperty: *mut ctl_sharpness_filter_properties_t,
}
#[test]
fn bindgen_test_layout__ctl_sharpness_caps_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_sharpness_caps_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_sharpness_caps_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_sharpness_caps_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_sharpness_caps_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_sharpness_caps_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_sharpness_caps_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_sharpness_caps_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportedFilterFlags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_sharpness_caps_t),
            "::",
            stringify!(SupportedFilterFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumFilterTypes) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_sharpness_caps_t),
            "::",
            stringify!(NumFilterTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pFilterProperty) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_sharpness_caps_t),
            "::",
            stringify!(pFilterProperty)
        )
    );
}
#[doc = "\n @brief Current sharpness setting"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_sharpness_settings_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Current or new state of sharpness setting"]
    pub Enable: bool,
    #[doc = "< [in,out] Current or new filter to be set. Refer\n< ::ctl_sharpness_filter_type_flag_t"]
    pub FilterType: ctl_sharpness_filter_type_flags_t,
    #[doc = "< [in,out] Setting intensity to be applied"]
    pub Intensity: f32,
}
#[test]
fn bindgen_test_layout__ctl_sharpness_settings_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_sharpness_settings_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_sharpness_settings_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ctl_sharpness_settings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_sharpness_settings_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_sharpness_settings_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_sharpness_settings_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_sharpness_settings_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Enable) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_sharpness_settings_t),
            "::",
            stringify!(Enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FilterType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_sharpness_settings_t),
            "::",
            stringify!(FilterType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Intensity) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_sharpness_settings_t),
            "::",
            stringify!(Intensity)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get Sharpness capability\n\n @details\n     - Returns sharpness capability\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pSharpnessCaps`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetSharpnessCaps(
        hDisplayOutput: ctl_display_output_handle_t,
        pSharpnessCaps: *mut ctl_sharpness_caps_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get Sharpness setting\n\n @details\n     - Returns current sharpness settings\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pSharpnessSettings`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetCurrentSharpness(
        hDisplayOutput: ctl_display_output_handle_t,
        pSharpnessSettings: *mut ctl_sharpness_settings_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Set Sharpness setting\n\n @details\n     - Set current sharpness settings\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pSharpnessSettings`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlSetCurrentSharpness(
        hDisplayOutput: ctl_display_output_handle_t,
        pSharpnessSettings: *mut ctl_sharpness_settings_t,
    ) -> ctl_result_t;
}
#[doc = "\n @brief I2CFlags bitmasks"]
pub type ctl_i2c_flags_t = u32;
#[doc = "< Force Atomic I2C"]
pub const _ctl_i2c_flag_t_CTL_I2C_FLAG_ATOMICI2C: _ctl_i2c_flag_t = 1;
pub const _ctl_i2c_flag_t_CTL_I2C_FLAG_MAX: _ctl_i2c_flag_t = -2147483648;
pub type _ctl_i2c_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_i2c_flag_t as ctl_i2c_flag_t;
#[doc = "\n @brief I2C access arguments"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_i2c_access_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Valid data size"]
    pub DataSize: u32,
    #[doc = "< [in] Adreess to read or write"]
    pub Address: u32,
    #[doc = "< [in] Operation type, 1 for Read, 2 for Write, for Write operation, App\n< needs to run with admin privileges"]
    pub OpType: ctl_operation_type_t,
    #[doc = "< [in] Offset"]
    pub Offset: u32,
    #[doc = "< [in] I2C Flags. Refer ::ctl_i2c_flag_t"]
    pub Flags: ctl_i2c_flags_t,
    #[doc = "< [in] RAD, For Future use, to be used for branch devices, Interface\n< will be provided to get RAD"]
    pub RAD: u64,
    #[doc = "< [in,out] Data array"]
    pub Data: [u8; 128usize],
}
#[test]
fn bindgen_test_layout__ctl_i2c_access_args_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_i2c_access_args_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_i2c_access_args_t>(),
        168usize,
        concat!("Size of: ", stringify!(_ctl_i2c_access_args_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_i2c_access_args_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_i2c_access_args_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_i2c_access_args_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_i2c_access_args_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_i2c_access_args_t),
            "::",
            stringify!(DataSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Address) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_i2c_access_args_t),
            "::",
            stringify!(Address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OpType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_i2c_access_args_t),
            "::",
            stringify!(OpType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_i2c_access_args_t),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_i2c_access_args_t),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RAD) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_i2c_access_args_t),
            "::",
            stringify!(RAD)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_i2c_access_args_t),
            "::",
            stringify!(Data)
        )
    );
}
extern "C" {
    #[doc = "\n @brief I2C Access\n\n @details\n     - The application does I2C aceess\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pI2cAccessArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_INVALID_SIZE - \"Invalid I2C data size\"\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS - \"Insufficient permissions\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernal mode driver call failure\""]
    pub fn ctlI2CAccess(
        hDisplayOutput: ctl_display_output_handle_t,
        pI2cAccessArgs: *mut ctl_i2c_access_args_t,
    ) -> ctl_result_t;
}
#[doc = "\n @brief AUX Flags bitmasks"]
pub type ctl_aux_flags_t = u32;
#[doc = "< For Native AUX operation"]
pub const _ctl_aux_flag_t_CTL_AUX_FLAG_NATIVE_AUX: _ctl_aux_flag_t = 1;
#[doc = "< For I2C AUX operation"]
pub const _ctl_aux_flag_t_CTL_AUX_FLAG_I2C_AUX: _ctl_aux_flag_t = 2;
#[doc = "< For I2C AUX MOT operation"]
pub const _ctl_aux_flag_t_CTL_AUX_FLAG_I2C_AUX_MOT: _ctl_aux_flag_t = 4;
pub const _ctl_aux_flag_t_CTL_AUX_FLAG_MAX: _ctl_aux_flag_t = -2147483648;
pub type _ctl_aux_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_aux_flag_t as ctl_aux_flag_t;
#[doc = "\n @brief AUX access arguments"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_aux_access_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Operation type, 1 for Read, 2 for Write, for Write operation, App\n< needs to run with admin privileges"]
    pub OpType: ctl_operation_type_t,
    #[doc = "< [in] Aux Flags. Refer ::ctl_aux_flag_t"]
    pub Flags: ctl_aux_flags_t,
    #[doc = "< [in] Adreess to read or write"]
    pub Address: u32,
    #[doc = "< [in] RAD, For Future use, to be used for branch devices, Interface\n< will be provided to get RAD"]
    pub RAD: u64,
    #[doc = "< [in] Port ID, For Future use, to be used for SST tiled devices"]
    pub PortID: u32,
    #[doc = "< [in,out] Valid data size"]
    pub DataSize: u32,
    #[doc = "< [in,out] Data array"]
    pub Data: [u8; 132usize],
}
#[test]
fn bindgen_test_layout__ctl_aux_access_args_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_aux_access_args_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_aux_access_args_t>(),
        176usize,
        concat!("Size of: ", stringify!(_ctl_aux_access_args_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_aux_access_args_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_aux_access_args_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_aux_access_args_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_aux_access_args_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OpType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_aux_access_args_t),
            "::",
            stringify!(OpType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_aux_access_args_t),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_aux_access_args_t),
            "::",
            stringify!(Address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RAD) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_aux_access_args_t),
            "::",
            stringify!(RAD)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PortID) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_aux_access_args_t),
            "::",
            stringify!(PortID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataSize) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_aux_access_args_t),
            "::",
            stringify!(DataSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_aux_access_args_t),
            "::",
            stringify!(Data)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Aux Access\n\n @details\n     - The application does Aux aceess, PSR needs to be disabled for AUX\n       call.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pAuxAccessArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_INVALID_SIZE - \"Invalid AUX data size\"\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS - \"Insufficient permissions\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_INVALID_AUX_ACCESS_FLAG - \"Invalid flag for AUX access\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernal mode driver call failure\""]
    pub fn ctlAUXAccess(
        hDisplayOutput: ctl_display_output_handle_t,
        pAuxAccessArgs: *mut ctl_aux_access_args_t,
    ) -> ctl_result_t;
}
#[doc = "\n @brief Power saving features (Each individual feature's set & get call can be\n        called only once at a time)"]
pub type ctl_power_optimization_flags_t = u32;
#[doc = "< Frame buffer compression"]
pub const _ctl_power_optimization_flag_t_CTL_POWER_OPTIMIZATION_FLAG_FBC:
    _ctl_power_optimization_flag_t = 1;
#[doc = "< Panel self refresh"]
pub const _ctl_power_optimization_flag_t_CTL_POWER_OPTIMIZATION_FLAG_PSR:
    _ctl_power_optimization_flag_t = 2;
#[doc = "< Display power saving technology (Panel technology dependent)"]
pub const _ctl_power_optimization_flag_t_CTL_POWER_OPTIMIZATION_FLAG_DPST:
    _ctl_power_optimization_flag_t = 4;
#[doc = "< Low refresh rate (LRR/ALRR/UBRR), UBRR is supported only for IGCC and\n< NDA clients. UBZRR and UBLRR both can not be enabled at the same time,\n< only one can be enabled at a given time"]
pub const _ctl_power_optimization_flag_t_CTL_POWER_OPTIMIZATION_FLAG_LRR:
    _ctl_power_optimization_flag_t = 8;
pub const _ctl_power_optimization_flag_t_CTL_POWER_OPTIMIZATION_FLAG_MAX:
    _ctl_power_optimization_flag_t = -2147483648;
pub type _ctl_power_optimization_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_power_optimization_flag_t as ctl_power_optimization_flag_t;
#[doc = "\n @brief GPU/Panel/TCON dependent power optimization technology"]
pub type ctl_power_optimization_dpst_flags_t = u32;
#[doc = "< Intel DPST with Backlight control"]
pub const _ctl_power_optimization_dpst_flag_t_CTL_POWER_OPTIMIZATION_DPST_FLAG_BKLT:
    _ctl_power_optimization_dpst_flag_t = 1;
#[doc = "< Panel TCON specific Content Adaptive Control mechanism"]
pub const _ctl_power_optimization_dpst_flag_t_CTL_POWER_OPTIMIZATION_DPST_FLAG_PANEL_CABC:
    _ctl_power_optimization_dpst_flag_t = 2;
#[doc = "< Intel OLED Power Saving Technology"]
pub const _ctl_power_optimization_dpst_flag_t_CTL_POWER_OPTIMIZATION_DPST_FLAG_OPST:
    _ctl_power_optimization_dpst_flag_t = 4;
#[doc = "< TCON based Edge Luminance Profile"]
pub const _ctl_power_optimization_dpst_flag_t_CTL_POWER_OPTIMIZATION_DPST_FLAG_ELP:
    _ctl_power_optimization_dpst_flag_t = 8;
#[doc = "< Extra power saving mode"]
pub const _ctl_power_optimization_dpst_flag_t_CTL_POWER_OPTIMIZATION_DPST_FLAG_EPSM:
    _ctl_power_optimization_dpst_flag_t = 16;
pub const _ctl_power_optimization_dpst_flag_t_CTL_POWER_OPTIMIZATION_DPST_FLAG_MAX:
    _ctl_power_optimization_dpst_flag_t = -2147483648;
pub type _ctl_power_optimization_dpst_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_power_optimization_dpst_flag_t as ctl_power_optimization_dpst_flag_t;
#[doc = "< Power Source AC"]
pub const _ctl_power_source_t_CTL_POWER_SOURCE_AC: _ctl_power_source_t = 0;
#[doc = "< Power Source DC"]
pub const _ctl_power_source_t_CTL_POWER_SOURCE_DC: _ctl_power_source_t = 1;
pub const _ctl_power_source_t_CTL_POWER_SOURCE_MAX: _ctl_power_source_t = 2;
#[doc = "\n @brief Power Source"]
pub type _ctl_power_source_t = ::std::os::raw::c_int;
#[doc = "\n @brief Power Source"]
pub use self::_ctl_power_source_t as ctl_power_source_t;
#[doc = "< Balanced mode"]
pub const _ctl_power_optimization_plan_t_CTL_POWER_OPTIMIZATION_PLAN_BALANCED:
    _ctl_power_optimization_plan_t = 0;
#[doc = "< High Performance Mode"]
pub const _ctl_power_optimization_plan_t_CTL_POWER_OPTIMIZATION_PLAN_HIGH_PERFORMANCE:
    _ctl_power_optimization_plan_t = 1;
#[doc = "< Power Saver Mode"]
pub const _ctl_power_optimization_plan_t_CTL_POWER_OPTIMIZATION_PLAN_POWER_SAVER:
    _ctl_power_optimization_plan_t = 2;
pub const _ctl_power_optimization_plan_t_CTL_POWER_OPTIMIZATION_PLAN_MAX:
    _ctl_power_optimization_plan_t = 3;
#[doc = "\n @brief Power Optimization Plan"]
pub type _ctl_power_optimization_plan_t = ::std::os::raw::c_int;
#[doc = "\n @brief Power Optimization Plan"]
pub use self::_ctl_power_optimization_plan_t as ctl_power_optimization_plan_t;
#[doc = "\n @brief Type of low refresh rate feature"]
pub type ctl_power_optimization_lrr_flags_t = u32;
#[doc = "< LRR 1.0"]
pub const _ctl_power_optimization_lrr_flag_t_CTL_POWER_OPTIMIZATION_LRR_FLAG_LRR10:
    _ctl_power_optimization_lrr_flag_t = 1;
#[doc = "< LRR 2.0"]
pub const _ctl_power_optimization_lrr_flag_t_CTL_POWER_OPTIMIZATION_LRR_FLAG_LRR20:
    _ctl_power_optimization_lrr_flag_t = 2;
#[doc = "< LRR 2.5"]
pub const _ctl_power_optimization_lrr_flag_t_CTL_POWER_OPTIMIZATION_LRR_FLAG_LRR25:
    _ctl_power_optimization_lrr_flag_t = 4;
#[doc = "< Autonomous LRR"]
pub const _ctl_power_optimization_lrr_flag_t_CTL_POWER_OPTIMIZATION_LRR_FLAG_ALRR:
    _ctl_power_optimization_lrr_flag_t = 8;
#[doc = "< User based low refresh rate"]
pub const _ctl_power_optimization_lrr_flag_t_CTL_POWER_OPTIMIZATION_LRR_FLAG_UBLRR:
    _ctl_power_optimization_lrr_flag_t = 16;
#[doc = "< User based zero refresh rate"]
pub const _ctl_power_optimization_lrr_flag_t_CTL_POWER_OPTIMIZATION_LRR_FLAG_UBZRR:
    _ctl_power_optimization_lrr_flag_t = 32;
pub const _ctl_power_optimization_lrr_flag_t_CTL_POWER_OPTIMIZATION_LRR_FLAG_MAX:
    _ctl_power_optimization_lrr_flag_t = -2147483648;
pub type _ctl_power_optimization_lrr_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_power_optimization_lrr_flag_t as ctl_power_optimization_lrr_flag_t;
#[doc = "\n @brief Power optimization caps"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_power_optimization_caps_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Supported power optimization features. Refer\n< ::ctl_power_optimization_flag_t"]
    pub SupportedFeatures: ctl_power_optimization_flags_t,
}
#[test]
fn bindgen_test_layout__ctl_power_optimization_caps_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_power_optimization_caps_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_power_optimization_caps_t>(),
        12usize,
        concat!("Size of: ", stringify!(_ctl_power_optimization_caps_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_power_optimization_caps_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_power_optimization_caps_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_caps_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_caps_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportedFeatures) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_caps_t),
            "::",
            stringify!(SupportedFeatures)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get Power optimization features\n\n @details\n     - Returns power optimization capabilities\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pPowerOptimizationCaps`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetPowerOptimizationCaps(
        hDisplayOutput: ctl_display_output_handle_t,
        pPowerOptimizationCaps: *mut ctl_power_optimization_caps_t,
    ) -> ctl_result_t;
}
#[doc = "\n @brief LRR detailed settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_power_optimization_lrr_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] LRR type(s). Refer ::ctl_power_optimization_lrr_flag_t"]
    pub SupportedLRRTypes: ctl_power_optimization_lrr_flags_t,
    #[doc = "< [in,out] Current enabled LRR type(s) or the LRR type(s) to set to.\n< Refer ::ctl_power_optimization_lrr_flag_t"]
    pub CurrentLRRTypes: ctl_power_optimization_lrr_flags_t,
    #[doc = "< [out] Require PSR disable for any change in the selected LRR feature.\n< Caller can re-enable PSR once the respective LRR feature is\n< enable/disabled. E.g. for UBRR based on platform this flag may not be\n< set in which case caller doesn't need to do an explicit PSR disable"]
    pub bRequirePSRDisable: bool,
    #[doc = "< [out] Lowest RR used for LRR functionality if known to source"]
    pub LowRR: u16,
}
#[test]
fn bindgen_test_layout__ctl_power_optimization_lrr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_power_optimization_lrr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_power_optimization_lrr_t>(),
        20usize,
        concat!("Size of: ", stringify!(_ctl_power_optimization_lrr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_power_optimization_lrr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_power_optimization_lrr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_lrr_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_lrr_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportedLRRTypes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_lrr_t),
            "::",
            stringify!(SupportedLRRTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentLRRTypes) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_lrr_t),
            "::",
            stringify!(CurrentLRRTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bRequirePSRDisable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_lrr_t),
            "::",
            stringify!(bRequirePSRDisable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LowRR) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_lrr_t),
            "::",
            stringify!(LowRR)
        )
    );
}
#[doc = "\n @brief PSR detailed settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_power_optimization_psr_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] A value of 1 means PSR1, 2 means PSR2"]
    pub PSRVersion: u8,
    #[doc = "< [in,out] Full fetch and update"]
    pub FullFetchUpdate: bool,
}
#[test]
fn bindgen_test_layout__ctl_power_optimization_psr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_power_optimization_psr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_power_optimization_psr_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ctl_power_optimization_psr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_power_optimization_psr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_power_optimization_psr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_psr_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_psr_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PSRVersion) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_psr_t),
            "::",
            stringify!(PSRVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FullFetchUpdate) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_psr_t),
            "::",
            stringify!(FullFetchUpdate)
        )
    );
}
#[doc = "\n @brief DPST detailed settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_power_optimization_dpst_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Minimum supported aggressiveness level"]
    pub MinLevel: u8,
    #[doc = "< [out] Maximum supported aggressiveness level"]
    pub MaxLevel: u8,
    #[doc = "< [in,out] Current aggressiveness level to be set"]
    pub Level: u8,
    #[doc = "< [out] Supported features"]
    pub SupportedFeatures: ctl_power_optimization_dpst_flags_t,
    #[doc = "< [in,out] Features enabled or to be enabled"]
    pub EnabledFeatures: ctl_power_optimization_dpst_flags_t,
}
#[test]
fn bindgen_test_layout__ctl_power_optimization_dpst_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_power_optimization_dpst_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_power_optimization_dpst_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ctl_power_optimization_dpst_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_power_optimization_dpst_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_power_optimization_dpst_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_dpst_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_dpst_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinLevel) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_dpst_t),
            "::",
            stringify!(MinLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxLevel) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_dpst_t),
            "::",
            stringify!(MaxLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Level) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_dpst_t),
            "::",
            stringify!(Level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportedFeatures) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_dpst_t),
            "::",
            stringify!(SupportedFeatures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnabledFeatures) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_dpst_t),
            "::",
            stringify!(EnabledFeatures)
        )
    );
}
#[doc = "\n @brief Feature specific power optimization data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ctl_power_optimization_feature_specific_info_t {
    #[doc = "< [out] LRR info"]
    pub LRRInfo: ctl_power_optimization_lrr_t,
    #[doc = "< [in,out] PSR info"]
    pub PSRInfo: ctl_power_optimization_psr_t,
    #[doc = "< [in,out] DPST info"]
    pub DPSTInfo: ctl_power_optimization_dpst_t,
}
#[test]
fn bindgen_test_layout__ctl_power_optimization_feature_specific_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_power_optimization_feature_specific_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_power_optimization_feature_specific_info_t>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_power_optimization_feature_specific_info_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_power_optimization_feature_specific_info_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_power_optimization_feature_specific_info_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LRRInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_feature_specific_info_t),
            "::",
            stringify!(LRRInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PSRInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_feature_specific_info_t),
            "::",
            stringify!(PSRInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DPSTInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_feature_specific_info_t),
            "::",
            stringify!(DPSTInfo)
        )
    );
}
#[doc = "\n @brief Feature specific power optimization data"]
pub type ctl_power_optimization_feature_specific_info_t =
    _ctl_power_optimization_feature_specific_info_t;
#[doc = "\n @brief Power optimization settings"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_power_optimization_settings_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Power optimization power plan (max power/max perf/balanced)"]
    pub PowerOptimizationPlan: ctl_power_optimization_plan_t,
    #[doc = "< [in] Power optimization feature interested in. Refer\n< ::ctl_power_optimization_flag_t"]
    pub PowerOptimizationFeature: ctl_power_optimization_flags_t,
    #[doc = "< [in,out] Enable state"]
    pub Enable: bool,
    #[doc = "< [in,out] Data specific to the feature caller is interested in"]
    pub FeatureSpecificData: ctl_power_optimization_feature_specific_info_t,
    #[doc = "< [in] AC/DC"]
    pub PowerSource: ctl_power_source_t,
}
#[test]
fn bindgen_test_layout__ctl_power_optimization_settings_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_power_optimization_settings_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_power_optimization_settings_t>(),
        44usize,
        concat!("Size of: ", stringify!(_ctl_power_optimization_settings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_power_optimization_settings_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_power_optimization_settings_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_settings_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_settings_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PowerOptimizationPlan) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_settings_t),
            "::",
            stringify!(PowerOptimizationPlan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PowerOptimizationFeature) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_settings_t),
            "::",
            stringify!(PowerOptimizationFeature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Enable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_settings_t),
            "::",
            stringify!(Enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FeatureSpecificData) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_settings_t),
            "::",
            stringify!(FeatureSpecificData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PowerSource) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_optimization_settings_t),
            "::",
            stringify!(PowerSource)
        )
    );
}
#[doc = "\n @brief Brightness settings for SET call"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_set_brightness_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] The brightness level that the display need to transitioning to in\n< milli-percentage. Range is 0-100000 (100%)"]
    pub TargetBrightness: u32,
    #[doc = "< [in] Transition Time for brightness to take effect in milli-seconds.\n< If its 0 then it will be an immediate change. Maximum possible value\n< is 1000ms."]
    pub SmoothTransitionTimeInMs: u32,
    #[doc = "< [in] Reserved for future use"]
    pub ReservedFields: [u32; 4usize],
}
#[test]
fn bindgen_test_layout__ctl_set_brightness_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_set_brightness_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_set_brightness_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ctl_set_brightness_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_set_brightness_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_set_brightness_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_set_brightness_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_set_brightness_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetBrightness) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_set_brightness_t),
            "::",
            stringify!(TargetBrightness)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SmoothTransitionTimeInMs) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_set_brightness_t),
            "::",
            stringify!(SmoothTransitionTimeInMs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_set_brightness_t),
            "::",
            stringify!(ReservedFields)
        )
    );
}
#[doc = "\n @brief Brightness settings for GET call"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_get_brightness_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The brightness level that the display is currently transitioning\n< to in milli-percentage. If not in a transition, this should equal the\n< current brightness. Range is 0-100000 (100%)"]
    pub TargetBrightness: u32,
    #[doc = "< [out] The current brightness level of the display in milli-percentage"]
    pub CurrentBrightness: u32,
    #[doc = "< [out] Reserved for future use"]
    pub ReservedFields: [u32; 4usize],
}
#[test]
fn bindgen_test_layout__ctl_get_brightness_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_get_brightness_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_get_brightness_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ctl_get_brightness_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_get_brightness_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_get_brightness_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_get_brightness_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_get_brightness_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetBrightness) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_get_brightness_t),
            "::",
            stringify!(TargetBrightness)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CurrentBrightness) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_get_brightness_t),
            "::",
            stringify!(CurrentBrightness)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_get_brightness_t),
            "::",
            stringify!(ReservedFields)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get Power optimization setting\n\n @details\n     - Returns power optimization setting for a specific feature\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pPowerOptimizationSettings`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_POWERFEATURE_OPTIMIZATION_FLAG - \"Unsupported PowerOptimizationFeature\"\n     - ::CTL_RESULT_ERROR_INVALID_POWERSOURCE_TYPE_FOR_DPST - \"DPST is supported only in DC Mode\""]
    pub fn ctlGetPowerOptimizationSetting(
        hDisplayOutput: ctl_display_output_handle_t,
        pPowerOptimizationSettings: *mut ctl_power_optimization_settings_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Set Power optimization setting\n\n @details\n     - Set power optimization setting for a specific feature\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pPowerOptimizationSettings`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_POWERFEATURE_OPTIMIZATION_FLAG - \"Unsupported PowerOptimizationFeature\"\n     - ::CTL_RESULT_ERROR_INVALID_POWERSOURCE_TYPE_FOR_DPST - \"DPST is supported only in DC Mode\""]
    pub fn ctlSetPowerOptimizationSetting(
        hDisplayOutput: ctl_display_output_handle_t,
        pPowerOptimizationSettings: *mut ctl_power_optimization_settings_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Set Brightness on companion display\n\n @details\n     - Set Brightness for a target display. Currently support is only for\n       companion display.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pSetBrightnessSetting`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_ARGUMENT - \"Invalid Brightness data passed as argument\"\n     - ::CTL_RESULT_ERROR_DISPLAY_NOT_ACTIVE - \"Display not active\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Currently Brightness API is supported only on companion display\""]
    pub fn ctlSetBrightnessSetting(
        hDisplayOutput: ctl_display_output_handle_t,
        pSetBrightnessSetting: *mut ctl_set_brightness_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get Brightness setting\n\n @details\n     - Get Brightness for a target display. Currently support is only for\n       companion display.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pGetBrightnessSetting`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_DISPLAY_NOT_ACTIVE - \"Display not active\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Currently Brightness API is supported only on companion display\""]
    pub fn ctlGetBrightnessSetting(
        hDisplayOutput: ctl_display_output_handle_t,
        pGetBrightnessSetting: *mut ctl_get_brightness_t,
    ) -> ctl_result_t;
}
#[doc = "\n @brief Pixtx pipe set configuration flags bitmasks"]
pub type ctl_pixtx_pipe_set_config_flags_t = u32;
#[doc = "< For maintaining persistance across power events"]
pub const _ctl_pixtx_pipe_set_config_flag_t_CTL_PIXTX_PIPE_SET_CONFIG_FLAG_PERSIST_ACROSS_POWER_EVENTS : _ctl_pixtx_pipe_set_config_flag_t = 1 ;
pub const _ctl_pixtx_pipe_set_config_flag_t_CTL_PIXTX_PIPE_SET_CONFIG_FLAG_MAX:
    _ctl_pixtx_pipe_set_config_flag_t = -2147483648;
pub type _ctl_pixtx_pipe_set_config_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_pixtx_pipe_set_config_flag_t as ctl_pixtx_pipe_set_config_flag_t;
#[doc = "< Block type 1D LUT"]
pub const _ctl_pixtx_block_type_t_CTL_PIXTX_BLOCK_TYPE_1D_LUT: _ctl_pixtx_block_type_t = 1;
#[doc = "< Block type 3D LUT"]
pub const _ctl_pixtx_block_type_t_CTL_PIXTX_BLOCK_TYPE_3D_LUT: _ctl_pixtx_block_type_t = 2;
#[doc = "< Block type 3x3 matrix"]
pub const _ctl_pixtx_block_type_t_CTL_PIXTX_BLOCK_TYPE_3X3_MATRIX: _ctl_pixtx_block_type_t = 3;
#[doc = "< Block type 3x3 matrix and offsets"]
pub const _ctl_pixtx_block_type_t_CTL_PIXTX_BLOCK_TYPE_3X3_MATRIX_AND_OFFSETS:
    _ctl_pixtx_block_type_t = 4;
pub const _ctl_pixtx_block_type_t_CTL_PIXTX_BLOCK_TYPE_MAX: _ctl_pixtx_block_type_t = 5;
#[doc = "\n @brief Pixel transformation block types"]
pub type _ctl_pixtx_block_type_t = ::std::os::raw::c_int;
#[doc = "\n @brief Pixel transformation block types"]
pub use self::_ctl_pixtx_block_type_t as ctl_pixtx_block_type_t;
#[doc = "< Uniform LUT sampling"]
pub const _ctl_pixtx_lut_sampling_type_t_CTL_PIXTX_LUT_SAMPLING_TYPE_UNIFORM:
    _ctl_pixtx_lut_sampling_type_t = 0;
#[doc = "< Non uniform LUT sampling, Required mainly in HDR mode"]
pub const _ctl_pixtx_lut_sampling_type_t_CTL_PIXTX_LUT_SAMPLING_TYPE_NONUNIFORM:
    _ctl_pixtx_lut_sampling_type_t = 1;
pub const _ctl_pixtx_lut_sampling_type_t_CTL_PIXTX_LUT_SAMPLING_TYPE_MAX:
    _ctl_pixtx_lut_sampling_type_t = 2;
#[doc = "\n @brief Pixel transformation LUT sampling types"]
pub type _ctl_pixtx_lut_sampling_type_t = ::std::os::raw::c_int;
#[doc = "\n @brief Pixel transformation LUT sampling types"]
pub use self::_ctl_pixtx_lut_sampling_type_t as ctl_pixtx_lut_sampling_type_t;
#[doc = "< Get complete pixel processing pipeline capability"]
pub const _ctl_pixtx_config_query_type_t_CTL_PIXTX_CONFIG_QUERY_TYPE_CAPABILITY:
    _ctl_pixtx_config_query_type_t = 0;
#[doc = "< Get the configuration set through last set call"]
pub const _ctl_pixtx_config_query_type_t_CTL_PIXTX_CONFIG_QUERY_TYPE_CURRENT:
    _ctl_pixtx_config_query_type_t = 1;
pub const _ctl_pixtx_config_query_type_t_CTL_PIXTX_CONFIG_QUERY_TYPE_MAX:
    _ctl_pixtx_config_query_type_t = 2;
#[doc = "\n @brief Configuration query types"]
pub type _ctl_pixtx_config_query_type_t = ::std::os::raw::c_int;
#[doc = "\n @brief Configuration query types"]
pub use self::_ctl_pixtx_config_query_type_t as ctl_pixtx_config_query_type_t;
#[doc = "< Restore block by block or entire pipe line. Use NumBlocks = 0 to\n< restore all."]
pub const _ctl_pixtx_config_opertaion_type_t_CTL_PIXTX_CONFIG_OPERTAION_TYPE_RESTORE_DEFAULT:
    _ctl_pixtx_config_opertaion_type_t = 1;
#[doc = "< Custom LUT or matrix can be set thorugh this option."]
pub const _ctl_pixtx_config_opertaion_type_t_CTL_PIXTX_CONFIG_OPERTAION_TYPE_SET_CUSTOM:
    _ctl_pixtx_config_opertaion_type_t = 2;
pub const _ctl_pixtx_config_opertaion_type_t_CTL_PIXTX_CONFIG_OPERTAION_TYPE_MAX:
    _ctl_pixtx_config_opertaion_type_t = 3;
#[doc = "\n @brief Configuration operation types"]
pub type _ctl_pixtx_config_opertaion_type_t = ::std::os::raw::c_int;
#[doc = "\n @brief Configuration operation types"]
pub use self::_ctl_pixtx_config_opertaion_type_t as ctl_pixtx_config_opertaion_type_t;
#[doc = "< Gamma encoding SRGB"]
pub const _ctl_pixtx_gamma_encoding_type_t_CTL_PIXTX_GAMMA_ENCODING_TYPE_SRGB:
    _ctl_pixtx_gamma_encoding_type_t = 0;
#[doc = "< Gamma encoding REC709, Applicable for REC2020 as well"]
pub const _ctl_pixtx_gamma_encoding_type_t_CTL_PIXTX_GAMMA_ENCODING_TYPE_REC709:
    _ctl_pixtx_gamma_encoding_type_t = 1;
#[doc = "< Gamma encoding ST2084"]
pub const _ctl_pixtx_gamma_encoding_type_t_CTL_PIXTX_GAMMA_ENCODING_TYPE_ST2084:
    _ctl_pixtx_gamma_encoding_type_t = 2;
#[doc = "< Gamma encoding HLG"]
pub const _ctl_pixtx_gamma_encoding_type_t_CTL_PIXTX_GAMMA_ENCODING_TYPE_HLG:
    _ctl_pixtx_gamma_encoding_type_t = 3;
#[doc = "< Gamma encoding linear"]
pub const _ctl_pixtx_gamma_encoding_type_t_CTL_PIXTX_GAMMA_ENCODING_TYPE_LINEAR:
    _ctl_pixtx_gamma_encoding_type_t = 4;
pub const _ctl_pixtx_gamma_encoding_type_t_CTL_PIXTX_GAMMA_ENCODING_TYPE_MAX:
    _ctl_pixtx_gamma_encoding_type_t = 5;
#[doc = "\n @brief Pixel transformation gamma encoding types"]
pub type _ctl_pixtx_gamma_encoding_type_t = ::std::os::raw::c_int;
#[doc = "\n @brief Pixel transformation gamma encoding types"]
pub use self::_ctl_pixtx_gamma_encoding_type_t as ctl_pixtx_gamma_encoding_type_t;
#[doc = "< Color space REC709"]
pub const _ctl_pixtx_color_space_t_CTL_PIXTX_COLOR_SPACE_REC709: _ctl_pixtx_color_space_t = 0;
#[doc = "< Color space REC2020"]
pub const _ctl_pixtx_color_space_t_CTL_PIXTX_COLOR_SPACE_REC2020: _ctl_pixtx_color_space_t = 1;
#[doc = "< Color space AdobeRGB"]
pub const _ctl_pixtx_color_space_t_CTL_PIXTX_COLOR_SPACE_ADOBE_RGB: _ctl_pixtx_color_space_t = 2;
#[doc = "< Color space P3_D65"]
pub const _ctl_pixtx_color_space_t_CTL_PIXTX_COLOR_SPACE_P3_D65: _ctl_pixtx_color_space_t = 3;
#[doc = "< Color space P3_DCI"]
pub const _ctl_pixtx_color_space_t_CTL_PIXTX_COLOR_SPACE_P3_DCI: _ctl_pixtx_color_space_t = 4;
#[doc = "< Color space P3_D60"]
pub const _ctl_pixtx_color_space_t_CTL_PIXTX_COLOR_SPACE_P3_D60: _ctl_pixtx_color_space_t = 5;
#[doc = "< Color space custom, Refer ::ctl_pixtx_color_primaries_t for color\n< primary details"]
pub const _ctl_pixtx_color_space_t_CTL_PIXTX_COLOR_SPACE_CUSTOM: _ctl_pixtx_color_space_t = 65535;
pub const _ctl_pixtx_color_space_t_CTL_PIXTX_COLOR_SPACE_MAX: _ctl_pixtx_color_space_t = 65536;
#[doc = "\n @brief Pixel transformation color space types"]
pub type _ctl_pixtx_color_space_t = ::std::os::raw::c_int;
#[doc = "\n @brief Pixel transformation color space types"]
pub use self::_ctl_pixtx_color_space_t as ctl_pixtx_color_space_t;
#[doc = "< Color model RGB full range"]
pub const _ctl_pixtx_color_model_t_CTL_PIXTX_COLOR_MODEL_RGB_FR: _ctl_pixtx_color_model_t = 0;
#[doc = "< Color model RGB limited range"]
pub const _ctl_pixtx_color_model_t_CTL_PIXTX_COLOR_MODEL_RGB_LR: _ctl_pixtx_color_model_t = 1;
#[doc = "< Color model YCBCR 422 full range"]
pub const _ctl_pixtx_color_model_t_CTL_PIXTX_COLOR_MODEL_YCBCR_422_FR: _ctl_pixtx_color_model_t = 2;
#[doc = "< Color model YCBCR 422 limited range"]
pub const _ctl_pixtx_color_model_t_CTL_PIXTX_COLOR_MODEL_YCBCR_422_LR: _ctl_pixtx_color_model_t = 3;
#[doc = "< Color model YCBCR 420 full range"]
pub const _ctl_pixtx_color_model_t_CTL_PIXTX_COLOR_MODEL_YCBCR_420_FR: _ctl_pixtx_color_model_t = 4;
#[doc = "< Color model YCBCR 420 limited range"]
pub const _ctl_pixtx_color_model_t_CTL_PIXTX_COLOR_MODEL_YCBCR_420_LR: _ctl_pixtx_color_model_t = 5;
pub const _ctl_pixtx_color_model_t_CTL_PIXTX_COLOR_MODEL_MAX: _ctl_pixtx_color_model_t = 6;
#[doc = "\n @brief Pixel transformation color model types"]
pub type _ctl_pixtx_color_model_t = ::std::os::raw::c_int;
#[doc = "\n @brief Pixel transformation color model types"]
pub use self::_ctl_pixtx_color_model_t as ctl_pixtx_color_model_t;
#[doc = "\n @brief Pixel transformation color primaries"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pixtx_color_primaries_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] CIE1931 x value with maximum red pixel value"]
    pub xR: f64,
    #[doc = "< [out] CIE1931 y value with maximum red pixel value"]
    pub yR: f64,
    #[doc = "< [out] CIE1931 x value with maximum green pixel value"]
    pub xG: f64,
    #[doc = "< [out] CIE1931 y value with maximum green pixel value"]
    pub yG: f64,
    #[doc = "< [out] CIE1931 x value with maximum blue pixel value"]
    pub xB: f64,
    #[doc = "< [out] CIE1931 y value with maximum blue pixel value"]
    pub yB: f64,
    #[doc = "< [out] CIE1931 x value with maximum white pixel value"]
    pub xW: f64,
    #[doc = "< [out] CIE1931 y value with maximum white pixel value"]
    pub yW: f64,
}
#[test]
fn bindgen_test_layout__ctl_pixtx_color_primaries_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_pixtx_color_primaries_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_pixtx_color_primaries_t>(),
        72usize,
        concat!("Size of: ", stringify!(_ctl_pixtx_color_primaries_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_pixtx_color_primaries_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_pixtx_color_primaries_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_color_primaries_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_color_primaries_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_color_primaries_t),
            "::",
            stringify!(xR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_color_primaries_t),
            "::",
            stringify!(yR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xG) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_color_primaries_t),
            "::",
            stringify!(xG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yG) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_color_primaries_t),
            "::",
            stringify!(yG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xB) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_color_primaries_t),
            "::",
            stringify!(xB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yB) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_color_primaries_t),
            "::",
            stringify!(yB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xW) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_color_primaries_t),
            "::",
            stringify!(xW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yW) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_color_primaries_t),
            "::",
            stringify!(yW)
        )
    );
}
#[doc = "\n @brief Pixel transformation pixel format"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pixtx_pixel_format_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Bits per color, It Will be 16 for FP16 case"]
    pub BitsPerColor: u32,
    #[doc = "< [out] Will be set for FP16 or other floating point encoding schemes"]
    pub IsFloat: bool,
    #[doc = "< [out] Encoding type"]
    pub EncodingType: ctl_pixtx_gamma_encoding_type_t,
    #[doc = "< [out] Color space"]
    pub ColorSpace: ctl_pixtx_color_space_t,
    #[doc = "< [out] Color model"]
    pub ColorModel: ctl_pixtx_color_model_t,
    #[doc = "< [out] Color primaries, Used mainly for custom color space"]
    pub ColorPrimaries: ctl_pixtx_color_primaries_t,
    #[doc = "< [out] Maximum brightness of pixel values. If no input is given,\n< default will be set to sRGB during set call. If panel capability is\n< not known get call will default to sRGB."]
    pub MaxBrightness: f64,
    #[doc = "< [out] Minimum brightness of pixel values"]
    pub MinBrightness: f64,
}
#[test]
fn bindgen_test_layout__ctl_pixtx_pixel_format_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_pixtx_pixel_format_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_pixtx_pixel_format_t>(),
        120usize,
        concat!("Size of: ", stringify!(_ctl_pixtx_pixel_format_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_pixtx_pixel_format_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_pixtx_pixel_format_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pixel_format_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pixel_format_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BitsPerColor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pixel_format_t),
            "::",
            stringify!(BitsPerColor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsFloat) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pixel_format_t),
            "::",
            stringify!(IsFloat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EncodingType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pixel_format_t),
            "::",
            stringify!(EncodingType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ColorSpace) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pixel_format_t),
            "::",
            stringify!(ColorSpace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ColorModel) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pixel_format_t),
            "::",
            stringify!(ColorModel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ColorPrimaries) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pixel_format_t),
            "::",
            stringify!(ColorPrimaries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxBrightness) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pixel_format_t),
            "::",
            stringify!(MaxBrightness)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinBrightness) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pixel_format_t),
            "::",
            stringify!(MinBrightness)
        )
    );
}
#[doc = "\n @brief Pixel transformation 1D LUT configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pixtx_1dlut_config_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Blocks with non-uniform sampling capability support unifrom\n< sampling also but not vice versa."]
    pub SamplingType: ctl_pixtx_lut_sampling_type_t,
    #[doc = "< [in,out] Number of samples per channel. Resampled internally based on\n< HW capability for uniformly sampled LUT.Maximum supported value is\n< MAX_NUM_SAMPLES_PER_CHANNEL_1D_LUT Caller needs to use exact sampling\n< position given in pSamplePositions for non-uniformly sampled LUTs."]
    pub NumSamplesPerChannel: u32,
    #[doc = "< [in,out] Number of channels, 1 for Grey scale LUT, 3 for RGB LUT"]
    pub NumChannels: u32,
    #[doc = "< [in,out] Pointer to sample values, R array followed by G and B arrays\n< in case of multi-channel LUT. Allocation size for pSampleValues should\n< be NumSamplesPerChannel * NumChannels * sizeof(double)"]
    pub pSampleValues: *mut f64,
    #[doc = "< [out] LUT (same for all channels) to represent sampling positions for\n< non-uniformly sampled LUTs.Can be NULL in case uniformly sampled LUTs"]
    pub pSamplePositions: *mut f64,
}
#[test]
fn bindgen_test_layout__ctl_pixtx_1dlut_config_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_pixtx_1dlut_config_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_pixtx_1dlut_config_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ctl_pixtx_1dlut_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_pixtx_1dlut_config_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_pixtx_1dlut_config_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_1dlut_config_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_1dlut_config_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SamplingType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_1dlut_config_t),
            "::",
            stringify!(SamplingType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumSamplesPerChannel) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_1dlut_config_t),
            "::",
            stringify!(NumSamplesPerChannel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumChannels) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_1dlut_config_t),
            "::",
            stringify!(NumChannels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pSampleValues) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_1dlut_config_t),
            "::",
            stringify!(pSampleValues)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pSamplePositions) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_1dlut_config_t),
            "::",
            stringify!(pSamplePositions)
        )
    );
}
#[doc = "\n @brief Pixel transformation matrix configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pixtx_matrix_config_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Pre offsets"]
    pub PreOffsets: [f64; 3usize],
    #[doc = "< [in,out] Post offsets"]
    pub PostOffsets: [f64; 3usize],
    #[doc = "< [in,out] 3x3 Matrix"]
    pub Matrix: [[f64; 3usize]; 3usize],
}
#[test]
fn bindgen_test_layout__ctl_pixtx_matrix_config_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_pixtx_matrix_config_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_pixtx_matrix_config_t>(),
        128usize,
        concat!("Size of: ", stringify!(_ctl_pixtx_matrix_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_pixtx_matrix_config_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_pixtx_matrix_config_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_matrix_config_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_matrix_config_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PreOffsets) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_matrix_config_t),
            "::",
            stringify!(PreOffsets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PostOffsets) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_matrix_config_t),
            "::",
            stringify!(PostOffsets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Matrix) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_matrix_config_t),
            "::",
            stringify!(Matrix)
        )
    );
}
#[doc = "\n @brief Pixel transformation 3D LUT sample. Samples are converted to integer\n        based on underlying HW capabilities. Hence slight precision loss will\n        be observed while getting sample values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pixtx_3dlut_sample_t {
    #[doc = "< [in,out] Red output value"]
    pub Red: f64,
    #[doc = "< [in,out] Green output value"]
    pub Green: f64,
    #[doc = "< [in,out] Blue output value"]
    pub Blue: f64,
}
#[test]
fn bindgen_test_layout__ctl_pixtx_3dlut_sample_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_pixtx_3dlut_sample_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_pixtx_3dlut_sample_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_pixtx_3dlut_sample_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_pixtx_3dlut_sample_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_pixtx_3dlut_sample_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Red) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_3dlut_sample_t),
            "::",
            stringify!(Red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Green) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_3dlut_sample_t),
            "::",
            stringify!(Green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Blue) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_3dlut_sample_t),
            "::",
            stringify!(Blue)
        )
    );
}
#[doc = "\n @brief Pixel transformation 3D LUT configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pixtx_3dlut_config_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Number of samples per channel"]
    pub NumSamplesPerChannel: u32,
    #[doc = "< [in,out] Pointer to sample values, R in outer most loop followed by G\n< and B"]
    pub pSampleValues: *mut ctl_pixtx_3dlut_sample_t,
}
#[test]
fn bindgen_test_layout__ctl_pixtx_3dlut_config_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_pixtx_3dlut_config_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_pixtx_3dlut_config_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_pixtx_3dlut_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_pixtx_3dlut_config_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_pixtx_3dlut_config_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_3dlut_config_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_3dlut_config_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumSamplesPerChannel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_3dlut_config_t),
            "::",
            stringify!(NumSamplesPerChannel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pSampleValues) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_3dlut_config_t),
            "::",
            stringify!(pSampleValues)
        )
    );
}
#[doc = "\n @brief Pixel transformation configuration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ctl_pixtx_config_t {
    #[doc = "< [in,out] 1D LUT configuration"]
    pub OneDLutConfig: ctl_pixtx_1dlut_config_t,
    #[doc = "< [in,out] 3D LUT configuration"]
    pub ThreeDLutConfig: ctl_pixtx_3dlut_config_t,
    #[doc = "< [in,out] Matrix configuration"]
    pub MatrixConfig: ctl_pixtx_matrix_config_t,
}
#[test]
fn bindgen_test_layout__ctl_pixtx_config_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_pixtx_config_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_pixtx_config_t>(),
        128usize,
        concat!("Size of: ", stringify!(_ctl_pixtx_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_pixtx_config_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_pixtx_config_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OneDLutConfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_config_t),
            "::",
            stringify!(OneDLutConfig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ThreeDLutConfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_config_t),
            "::",
            stringify!(ThreeDLutConfig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MatrixConfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_config_t),
            "::",
            stringify!(MatrixConfig)
        )
    );
}
#[doc = "\n @brief Pixel transformation configuration"]
pub type ctl_pixtx_config_t = _ctl_pixtx_config_t;
#[doc = "\n @brief Pixel transformation block configuration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_pixtx_block_config_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Unique ID for each pixel processing block. Id for a block is\n< fixed for a platform."]
    pub BlockId: u32,
    #[doc = "< [in,out] Block type"]
    pub BlockType: ctl_pixtx_block_type_t,
    #[doc = "< [in,out] Configuration"]
    pub Config: ctl_pixtx_config_t,
}
#[test]
fn bindgen_test_layout__ctl_pixtx_block_config_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_pixtx_block_config_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_pixtx_block_config_t>(),
        144usize,
        concat!("Size of: ", stringify!(_ctl_pixtx_block_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_pixtx_block_config_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_pixtx_block_config_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_block_config_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_block_config_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BlockId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_block_config_t),
            "::",
            stringify!(BlockId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BlockType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_block_config_t),
            "::",
            stringify!(BlockType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Config) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_block_config_t),
            "::",
            stringify!(Config)
        )
    );
}
#[doc = "\n @brief Pixel transformation pipe get configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pixtx_pipe_get_config_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Query operation type"]
    pub QueryType: ctl_pixtx_config_query_type_t,
    #[doc = "< [out] Input pixel format"]
    pub InputPixelFormat: ctl_pixtx_pixel_format_t,
    #[doc = "< [out] Output pixel format"]
    pub OutputPixelFormat: ctl_pixtx_pixel_format_t,
    #[doc = "< [out] Number of blocks"]
    pub NumBlocks: u32,
    #[doc = "< [out] Pointer to specific configs"]
    pub pBlockConfigs: *mut ctl_pixtx_block_config_t,
}
#[test]
fn bindgen_test_layout__ctl_pixtx_pipe_get_config_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_pixtx_pipe_get_config_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_pixtx_pipe_get_config_t>(),
        272usize,
        concat!("Size of: ", stringify!(_ctl_pixtx_pipe_get_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_pixtx_pipe_get_config_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_pixtx_pipe_get_config_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pipe_get_config_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pipe_get_config_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QueryType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pipe_get_config_t),
            "::",
            stringify!(QueryType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InputPixelFormat) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pipe_get_config_t),
            "::",
            stringify!(InputPixelFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OutputPixelFormat) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pipe_get_config_t),
            "::",
            stringify!(OutputPixelFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumBlocks) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pipe_get_config_t),
            "::",
            stringify!(NumBlocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pBlockConfigs) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pipe_get_config_t),
            "::",
            stringify!(pBlockConfigs)
        )
    );
}
#[doc = "\n @brief Pixel transformation pipe set configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pixtx_pipe_set_config_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Set operation type"]
    pub OpertaionType: ctl_pixtx_config_opertaion_type_t,
    #[doc = "< [in] Config flags. Refer ::ctl_pixtx_pipe_set_config_flag_t"]
    pub Flags: ctl_pixtx_pipe_set_config_flags_t,
    #[doc = "< [in] Number of blocks"]
    pub NumBlocks: u32,
    #[doc = "< [in,out] Array of block specific configs"]
    pub pBlockConfigs: *mut ctl_pixtx_block_config_t,
}
#[test]
fn bindgen_test_layout__ctl_pixtx_pipe_set_config_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_pixtx_pipe_set_config_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_pixtx_pipe_set_config_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ctl_pixtx_pipe_set_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_pixtx_pipe_set_config_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_pixtx_pipe_set_config_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pipe_set_config_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pipe_set_config_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OpertaionType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pipe_set_config_t),
            "::",
            stringify!(OpertaionType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pipe_set_config_t),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumBlocks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pipe_set_config_t),
            "::",
            stringify!(NumBlocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pBlockConfigs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pixtx_pipe_set_config_t),
            "::",
            stringify!(pBlockConfigs)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Pixel transformation get pipe configuration\n\n @details\n     - The application does pixel transformation get pipe configuration\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pPixTxGetConfigArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS - \"Insufficient permissions\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernal mode driver call failure\"\n     - ::CTL_RESULT_ERROR_INVALID_PIXTX_GET_CONFIG_QUERY_TYPE - \"Invalid query type\"\n     - ::CTL_RESULT_ERROR_INVALID_PIXTX_BLOCK_ID - \"Invalid block id\"\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PIXTX_BLOCK_CONFIG_MEMORY - \"Insufficient memery allocated for BlockConfigs\"\n     - ::CTL_RESULT_ERROR_3DLUT_INVALID_PIPE - \"Invalid pipe for 3dlut\"\n     - ::CTL_RESULT_ERROR_3DLUT_INVALID_DATA - \"Invalid 3dlut data\"\n     - ::CTL_RESULT_ERROR_3DLUT_NOT_SUPPORTED_IN_HDR - \"3dlut not supported in HDR\"\n     - ::CTL_RESULT_ERROR_3DLUT_INVALID_OPERATION - \"Invalid 3dlut operation\"\n     - ::CTL_RESULT_ERROR_3DLUT_UNSUCCESSFUL - \"3dlut call unsuccessful\""]
    pub fn ctlPixelTransformationGetConfig(
        hDisplayOutput: ctl_display_output_handle_t,
        pPixTxGetConfigArgs: *mut ctl_pixtx_pipe_get_config_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Pixel transformation set pipe configuration\n\n @details\n     - The application does pixel transformation set pipe configuration\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pPixTxSetConfigArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS - \"Insufficient permissions\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernal mode driver call failure\"\n     - ::CTL_RESULT_ERROR_INVALID_PIXTX_SET_CONFIG_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_INVALID_SET_CONFIG_NUMBER_OF_SAMPLES - \"Invalid number of samples\"\n     - ::CTL_RESULT_ERROR_INVALID_PIXTX_BLOCK_ID - \"Invalid block id\"\n     - ::CTL_RESULT_ERROR_PERSISTANCE_NOT_SUPPORTED - \"Persistance not supported\"\n     - ::CTL_RESULT_ERROR_3DLUT_INVALID_PIPE - \"Invalid pipe for 3dlut\"\n     - ::CTL_RESULT_ERROR_3DLUT_INVALID_DATA - \"Invalid 3dlut data\"\n     - ::CTL_RESULT_ERROR_3DLUT_NOT_SUPPORTED_IN_HDR - \"3dlut not supported in HDR\"\n     - ::CTL_RESULT_ERROR_3DLUT_INVALID_OPERATION - \"Invalid 3dlut operation\"\n     - ::CTL_RESULT_ERROR_3DLUT_UNSUCCESSFUL - \"3dlut call unsuccessful\""]
    pub fn ctlPixelTransformationSetConfig(
        hDisplayOutput: ctl_display_output_handle_t,
        pPixTxSetConfigArgs: *mut ctl_pixtx_pipe_set_config_t,
    ) -> ctl_result_t;
}
#[doc = "\n @brief Panel descriptor access arguments"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_panel_descriptor_access_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Operation type, 1 for Read, 2 for Write. App needs to run with\n< admin privileges for Write operation, Currently only Read operation is\n< supported"]
    pub OpType: ctl_operation_type_t,
    #[doc = "< [in] Block number, Need to provide only if acccessing EDID"]
    pub BlockNumber: u32,
    #[doc = "< [in] Descriptor data size, Should be 0 for querying the size and\n< should be DescriptorDataSize derived from query call otherwise"]
    pub DescriptorDataSize: u32,
    #[doc = "< [in,out] Panel descriptor data"]
    pub pDescriptorData: *mut u8,
}
#[test]
fn bindgen_test_layout__ctl_panel_descriptor_access_args_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_panel_descriptor_access_args_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_panel_descriptor_access_args_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ctl_panel_descriptor_access_args_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_panel_descriptor_access_args_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_panel_descriptor_access_args_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_panel_descriptor_access_args_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_panel_descriptor_access_args_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OpType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_panel_descriptor_access_args_t),
            "::",
            stringify!(OpType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).BlockNumber) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_panel_descriptor_access_args_t),
            "::",
            stringify!(BlockNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DescriptorDataSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_panel_descriptor_access_args_t),
            "::",
            stringify!(DescriptorDataSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pDescriptorData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_panel_descriptor_access_args_t),
            "::",
            stringify!(pDescriptorData)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Panel Descriptor Access\n\n @details\n     - The application does EDID or Display ID access\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pPanelDescriptorAccessArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS - \"Insufficient permissions\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernal mode driver call failure\""]
    pub fn ctlPanelDescriptorAccess(
        hDisplayOutput: ctl_display_output_handle_t,
        pPanelDescriptorAccessArgs: *mut ctl_panel_descriptor_access_args_t,
    ) -> ctl_result_t;
}
#[doc = "\n @brief  Retro Scaling Types"]
pub type ctl_retro_scaling_type_flags_t = u32;
#[doc = "< Integer Scaling"]
pub const _ctl_retro_scaling_type_flag_t_CTL_RETRO_SCALING_TYPE_FLAG_INTEGER:
    _ctl_retro_scaling_type_flag_t = 1;
#[doc = "< Nearest Neighbour Scaling"]
pub const _ctl_retro_scaling_type_flag_t_CTL_RETRO_SCALING_TYPE_FLAG_NEAREST_NEIGHBOUR:
    _ctl_retro_scaling_type_flag_t = 2;
pub const _ctl_retro_scaling_type_flag_t_CTL_RETRO_SCALING_TYPE_FLAG_MAX:
    _ctl_retro_scaling_type_flag_t = -2147483648;
pub type _ctl_retro_scaling_type_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_retro_scaling_type_flag_t as ctl_retro_scaling_type_flag_t;
#[doc = "\n @brief Set/Get Retro Scaling Type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_retro_scaling_settings_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in][release] Set to true to get current scaling . Set to False to Set\n< the scaling"]
    pub Get: bool,
    #[doc = "< [in,out] State of the scaler"]
    pub Enable: bool,
    #[doc = "< [out] Requested retro scaling types. Refer\n< ::ctl_retro_scaling_type_flag_t"]
    pub RetroScalingType: ctl_retro_scaling_type_flags_t,
}
#[test]
fn bindgen_test_layout__ctl_retro_scaling_settings_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_retro_scaling_settings_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_retro_scaling_settings_t>(),
        12usize,
        concat!("Size of: ", stringify!(_ctl_retro_scaling_settings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_retro_scaling_settings_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_retro_scaling_settings_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_retro_scaling_settings_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_retro_scaling_settings_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Get) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_retro_scaling_settings_t),
            "::",
            stringify!(Get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Enable) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_retro_scaling_settings_t),
            "::",
            stringify!(Enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RetroScalingType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_retro_scaling_settings_t),
            "::",
            stringify!(RetroScalingType)
        )
    );
}
#[doc = "\n @brief Retro Scaling caps"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_retro_scaling_caps_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Supported retro scaling types"]
    pub SupportedRetroScaling: ctl_retro_scaling_type_flags_t,
}
#[test]
fn bindgen_test_layout__ctl_retro_scaling_caps_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_retro_scaling_caps_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_retro_scaling_caps_t>(),
        12usize,
        concat!("Size of: ", stringify!(_ctl_retro_scaling_caps_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_retro_scaling_caps_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_retro_scaling_caps_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_retro_scaling_caps_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_retro_scaling_caps_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportedRetroScaling) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_retro_scaling_caps_t),
            "::",
            stringify!(SupportedRetroScaling)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get Supported Retro Scaling Types\n\n @details\n     - Returns supported retro scaling capabilities\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pRetroScalingCaps`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetSupportedRetroScalingCapability(
        hDAhandle: ctl_device_adapter_handle_t,
        pRetroScalingCaps: *mut ctl_retro_scaling_caps_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get/Set Retro Scaling\n\n @details\n     - Get or Set the status of retro scaling.This Api will do a physical\n       modeset resulting in flash on the screen\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pGetSetRetroScalingType`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetSetRetroScaling(
        hDAhandle: ctl_device_adapter_handle_t,
        pGetSetRetroScalingType: *mut ctl_retro_scaling_settings_t,
    ) -> ctl_result_t;
}
#[doc = "\n @brief Scaling Types"]
pub type ctl_scaling_type_flags_t = u32;
#[doc = "< No scaling is applied and display manages scaling itself when possible"]
pub const _ctl_scaling_type_flag_t_CTL_SCALING_TYPE_FLAG_IDENTITY: _ctl_scaling_type_flag_t = 1;
#[doc = "< Source is not scaled but place in the center of the target display"]
pub const _ctl_scaling_type_flag_t_CTL_SCALING_TYPE_FLAG_CENTERED: _ctl_scaling_type_flag_t = 2;
#[doc = "< Source is stretched to fit the target size"]
pub const _ctl_scaling_type_flag_t_CTL_SCALING_TYPE_FLAG_STRETCHED: _ctl_scaling_type_flag_t = 4;
#[doc = "< The aspect ratio is maintained with the source centered"]
pub const _ctl_scaling_type_flag_t_CTL_SCALING_TYPE_FLAG_ASPECT_RATIO_CENTERED_MAX:
    _ctl_scaling_type_flag_t = 8;
#[doc = "< None of the standard types match this .Additional parameters are\n< required which should be set via a private driver interface"]
pub const _ctl_scaling_type_flag_t_CTL_SCALING_TYPE_FLAG_CUSTOM: _ctl_scaling_type_flag_t = 16;
pub const _ctl_scaling_type_flag_t_CTL_SCALING_TYPE_FLAG_MAX: _ctl_scaling_type_flag_t =
    -2147483648;
pub type _ctl_scaling_type_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_scaling_type_flag_t as ctl_scaling_type_flag_t;
#[doc = "\n @brief Scaling caps"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_scaling_caps_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Supported scaling types. Refer ::ctl_scaling_type_flag_t"]
    pub SupportedScaling: ctl_scaling_type_flags_t,
}
#[test]
fn bindgen_test_layout__ctl_scaling_caps_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_scaling_caps_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_scaling_caps_t>(),
        12usize,
        concat!("Size of: ", stringify!(_ctl_scaling_caps_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_scaling_caps_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_scaling_caps_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_scaling_caps_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_scaling_caps_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SupportedScaling) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_scaling_caps_t),
            "::",
            stringify!(SupportedScaling)
        )
    );
}
#[doc = "\n @brief Set/Get Scaling type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_scaling_settings_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] State of the scaler"]
    pub Enable: bool,
    #[doc = "< [in,out] Requested scaling types. Refer ::ctl_scaling_type_flag_t"]
    pub ScalingType: ctl_scaling_type_flags_t,
    #[doc = "< [in,out] Custom Scaling X resolution"]
    pub CustomScalingX: u32,
    #[doc = "< [in,out] Custom Scaling Y resolution"]
    pub CustomScalingY: u32,
    #[doc = "< [in] Flag to indicate hardware modeset should be done to apply the\n< scaling.Setting this to true would result in a flash on the screen. If\n< this flag is set to false , API will request the OS to do a virtual\n< modeset , but the OS can ignore this request and do a hardware modeset\n< in some instances"]
    pub HardwareModeSet: bool,
}
#[test]
fn bindgen_test_layout__ctl_scaling_settings_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_scaling_settings_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_scaling_settings_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_scaling_settings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_scaling_settings_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_scaling_settings_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_scaling_settings_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_scaling_settings_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Enable) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_scaling_settings_t),
            "::",
            stringify!(Enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ScalingType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_scaling_settings_t),
            "::",
            stringify!(ScalingType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CustomScalingX) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_scaling_settings_t),
            "::",
            stringify!(CustomScalingX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CustomScalingY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_scaling_settings_t),
            "::",
            stringify!(CustomScalingY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HardwareModeSet) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_scaling_settings_t),
            "::",
            stringify!(HardwareModeSet)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get Supported Scaling Types\n\n @details\n     - Returns supported scaling capabilities\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pScalingCaps`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetSupportedScalingCapability(
        hDisplayOutput: ctl_display_output_handle_t,
        pScalingCaps: *mut ctl_scaling_caps_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get Current Scaling\n\n @details\n     - Returns current active scaling\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pGetCurrentScalingType`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetCurrentScaling(
        hDisplayOutput: ctl_display_output_handle_t,
        pGetCurrentScalingType: *mut ctl_scaling_settings_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Set Scaling Type\n\n @details\n     - Returns current active scaling\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pSetScalingType`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlSetCurrentScaling(
        hDisplayOutput: ctl_display_output_handle_t,
        pSetScalingType: *mut ctl_scaling_settings_t,
    ) -> ctl_result_t;
}
#[doc = "\n @brief Ambient light based enhancement table entry"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_lace_lux_aggr_map_entry_t {
    #[doc = "< [in,out] Ambient lux"]
    pub Lux: u32,
    #[doc = "< [in,out] Pixel boost agressiveness"]
    pub AggressivenessPercent: u8,
}
#[test]
fn bindgen_test_layout__ctl_lace_lux_aggr_map_entry_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_lace_lux_aggr_map_entry_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_lace_lux_aggr_map_entry_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ctl_lace_lux_aggr_map_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_lace_lux_aggr_map_entry_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_lace_lux_aggr_map_entry_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Lux) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_lace_lux_aggr_map_entry_t),
            "::",
            stringify!(Lux)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AggressivenessPercent) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_lace_lux_aggr_map_entry_t),
            "::",
            stringify!(AggressivenessPercent)
        )
    );
}
#[doc = "\n @brief Ambient light based enhancement table"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_lace_lux_aggr_map_t {
    #[doc = "< [out] Max Number of entries in mapping table supported"]
    pub MaxNumEntries: u32,
    #[doc = "< [in,out] Number of entries in the given mapping table"]
    pub NumEntries: u32,
    #[doc = "< [in] Max number of Entries which can be passed in\n< LuxToAggrMappingTable"]
    pub pLuxToAggrMappingTable: *mut ctl_lace_lux_aggr_map_entry_t,
}
#[test]
fn bindgen_test_layout__ctl_lace_lux_aggr_map_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_lace_lux_aggr_map_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_lace_lux_aggr_map_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ctl_lace_lux_aggr_map_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_lace_lux_aggr_map_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_lace_lux_aggr_map_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxNumEntries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_lace_lux_aggr_map_t),
            "::",
            stringify!(MaxNumEntries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumEntries) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_lace_lux_aggr_map_t),
            "::",
            stringify!(NumEntries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pLuxToAggrMappingTable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_lace_lux_aggr_map_t),
            "::",
            stringify!(pLuxToAggrMappingTable)
        )
    );
}
#[doc = "\n @brief Data specific to the mode caller is interested in"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ctl_lace_aggr_config_t {
    #[doc = "< [in,out] Fixed aggressiveness level, applicable for\n< CTL_LACE_MODE_FIXED_AGGR_LEVEL"]
    pub FixedAggressivenessLevelPercent: u8,
    #[doc = "< [in,out] Lux to enhancement mapping table, applicable for\n< CTL_LACE_MODE_AMBIENT_ADAPTIVE"]
    pub AggrLevelMap: ctl_lace_lux_aggr_map_t,
}
#[test]
fn bindgen_test_layout__ctl_lace_aggr_config_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_lace_aggr_config_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_lace_aggr_config_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ctl_lace_aggr_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_lace_aggr_config_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_lace_aggr_config_t))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).FixedAggressivenessLevelPercent) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_lace_aggr_config_t),
            "::",
            stringify!(FixedAggressivenessLevelPercent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AggrLevelMap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_lace_aggr_config_t),
            "::",
            stringify!(AggrLevelMap)
        )
    );
}
#[doc = "\n @brief Data specific to the mode caller is interested in"]
pub type ctl_lace_aggr_config_t = _ctl_lace_aggr_config_t;
#[doc = "\n @brief Get Operations used for additional settings"]
pub type ctl_get_operation_flags_t = u32;
#[doc = "< Get the details set through last set call"]
pub const _ctl_get_operation_flag_t_CTL_GET_OPERATION_FLAG_CURRENT: _ctl_get_operation_flag_t = 1;
#[doc = "< Get the driver default values"]
pub const _ctl_get_operation_flag_t_CTL_GET_OPERATION_FLAG_DEFAULT: _ctl_get_operation_flag_t = 2;
#[doc = "< Get capability"]
pub const _ctl_get_operation_flag_t_CTL_GET_OPERATION_FLAG_CAPABILITY: _ctl_get_operation_flag_t =
    4;
pub const _ctl_get_operation_flag_t_CTL_GET_OPERATION_FLAG_MAX: _ctl_get_operation_flag_t =
    -2147483648;
pub type _ctl_get_operation_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_get_operation_flag_t as ctl_get_operation_flag_t;
#[doc = "< Restore default values"]
pub const _ctl_set_operation_t_CTL_SET_OPERATION_RESTORE_DEFAULT: _ctl_set_operation_t = 0;
#[doc = "< Set custom values"]
pub const _ctl_set_operation_t_CTL_SET_OPERATION_CUSTOM: _ctl_set_operation_t = 1;
pub const _ctl_set_operation_t_CTL_SET_OPERATION_MAX: _ctl_set_operation_t = 2;
#[doc = "\n @brief Set Operations used for additional settings"]
pub type _ctl_set_operation_t = ::std::os::raw::c_int;
#[doc = "\n @brief Set Operations used for additional settings"]
pub use self::_ctl_set_operation_t as ctl_set_operation_t;
#[doc = "\n @brief  Lace Trigger Modes"]
pub type ctl_lace_trigger_flags_t = u32;
#[doc = "< LACE enhancement depends on Ambient light"]
pub const _ctl_lace_trigger_flag_t_CTL_LACE_TRIGGER_FLAG_AMBIENT_LIGHT: _ctl_lace_trigger_flag_t =
    1;
#[doc = "< LACE enhancement is as per given fixed aggressiveness level"]
pub const _ctl_lace_trigger_flag_t_CTL_LACE_TRIGGER_FLAG_FIXED_AGGRESSIVENESS:
    _ctl_lace_trigger_flag_t = 2;
pub const _ctl_lace_trigger_flag_t_CTL_LACE_TRIGGER_FLAG_MAX: _ctl_lace_trigger_flag_t =
    -2147483648;
pub type _ctl_lace_trigger_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_lace_trigger_flag_t as ctl_lace_trigger_flag_t;
#[doc = "\n @brief Set/Get LACE Config"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_lace_config_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Enable or disable LACE feature"]
    pub Enabled: bool,
    #[doc = "< [in] Get Operations used for additional settings"]
    pub OpTypeGet: ctl_get_operation_flags_t,
    #[doc = "< [in] Set Operations used for additional settings"]
    pub OpTypeSet: ctl_set_operation_t,
    #[doc = "< [in,out] LACE operating mode to be Triggerd"]
    pub Trigger: ctl_lace_trigger_flags_t,
    #[doc = "< [in,out] Data specific to the mode, caller is interested in"]
    pub LaceConfig: ctl_lace_aggr_config_t,
}
#[test]
fn bindgen_test_layout__ctl_lace_config_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_lace_config_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_lace_config_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ctl_lace_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_lace_config_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_lace_config_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_lace_config_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_lace_config_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Enabled) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_lace_config_t),
            "::",
            stringify!(Enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OpTypeGet) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_lace_config_t),
            "::",
            stringify!(OpTypeGet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OpTypeSet) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_lace_config_t),
            "::",
            stringify!(OpTypeSet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Trigger) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_lace_config_t),
            "::",
            stringify!(Trigger)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LaceConfig) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_lace_config_t),
            "::",
            stringify!(LaceConfig)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get LACE Config\n\n @details\n     - Returns current LACE Config\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pLaceConfig`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_LACE_INVALID_DATA_ARGUMENT_PASSED - \"Lace Incorrrect AggressivePercent data or LuxVsAggressive Map data passed by user\""]
    pub fn ctlGetLACEConfig(
        hDisplayOutput: ctl_display_output_handle_t,
        pLaceConfig: *mut ctl_lace_config_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Sets LACE Config\n\n @details\n     - Sets LACE Config\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pLaceConfig`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_LACE_INVALID_DATA_ARGUMENT_PASSED - \"Lace Incorrrect AggressivePercent data or LuxVsAggressive Map data passed by user\""]
    pub fn ctlSetLACEConfig(
        hDisplayOutput: ctl_display_output_handle_t,
        pLaceConfig: *mut ctl_lace_config_t,
    ) -> ctl_result_t;
}
#[doc = "\n @brief Get Software PSR status/Set Software PSR settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_sw_psr_settings_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in][release] Set to False to Get Software PSR status. Set to True to\n< Enable/Disable Software PSR"]
    pub Set: bool,
    #[doc = "< [out] When Get is True, returns if SW PSR is supported"]
    pub Supported: bool,
    #[doc = "< [in,out] When Get is True, returns current state of  Software PSR.\n< When Get is False, Enables/Diasbles Software PSR"]
    pub Enable: bool,
}
#[test]
fn bindgen_test_layout__ctl_sw_psr_settings_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_sw_psr_settings_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_sw_psr_settings_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ctl_sw_psr_settings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_sw_psr_settings_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_sw_psr_settings_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_sw_psr_settings_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_sw_psr_settings_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Set) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_sw_psr_settings_t),
            "::",
            stringify!(Set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Supported) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_sw_psr_settings_t),
            "::",
            stringify!(Supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Enable) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_sw_psr_settings_t),
            "::",
            stringify!(Enable)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get Software PSR caps/Set software PSR State\n\n @details\n     - Returns Software PSR status or Sets Software PSR capabilities. This is\n       a reserved capability. By default, software PSR is not supported/will\n       not be enabled, need application to activate it, please contact Intel\n       for activation.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pSoftwarePsrSetting`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlSoftwarePSR(
        hDisplayOutput: ctl_display_output_handle_t,
        pSoftwarePsrSetting: *mut ctl_sw_psr_settings_t,
    ) -> ctl_result_t;
}
#[doc = "\n @brief Intel Arc Sync Monitor Params"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_intel_arc_sync_monitor_params_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Intel Arc Sync support for the monitor"]
    pub IsIntelArcSyncSupported: bool,
    #[doc = "< [out] Minimum Intel Arc Sync refresh rate supported by the monitor"]
    pub MinimumRefreshRateInHz: f32,
    #[doc = "< [out] Maximum Intel Arc Sync refresh rate supported by the monitor"]
    pub MaximumRefreshRateInHz: f32,
    #[doc = "< [out] Max frame time increase in micro seconds from DID2.1 Adaptive\n< Sync block"]
    pub MaxFrameTimeIncreaseInUs: u32,
    #[doc = "< [out] Max frame time decrease in micro seconds from DID2.1 Adaptive\n< Sync block"]
    pub MaxFrameTimeDecreaseInUs: u32,
}
#[test]
fn bindgen_test_layout__ctl_intel_arc_sync_monitor_params_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_intel_arc_sync_monitor_params_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_intel_arc_sync_monitor_params_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_intel_arc_sync_monitor_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_intel_arc_sync_monitor_params_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_intel_arc_sync_monitor_params_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_intel_arc_sync_monitor_params_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_intel_arc_sync_monitor_params_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsIntelArcSyncSupported) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_intel_arc_sync_monitor_params_t),
            "::",
            stringify!(IsIntelArcSyncSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinimumRefreshRateInHz) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_intel_arc_sync_monitor_params_t),
            "::",
            stringify!(MinimumRefreshRateInHz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaximumRefreshRateInHz) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_intel_arc_sync_monitor_params_t),
            "::",
            stringify!(MaximumRefreshRateInHz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxFrameTimeIncreaseInUs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_intel_arc_sync_monitor_params_t),
            "::",
            stringify!(MaxFrameTimeIncreaseInUs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxFrameTimeDecreaseInUs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_intel_arc_sync_monitor_params_t),
            "::",
            stringify!(MaxFrameTimeDecreaseInUs)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get Intel Arc Sync information for monitor\n\n @details\n     - Returns Intel Arc Sync information for selected monitor\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pIntelArcSyncMonitorParams`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetIntelArcSyncInfoForMonitor(
        hDisplayOutput: ctl_display_output_handle_t,
        pIntelArcSyncMonitorParams: *mut ctl_intel_arc_sync_monitor_params_t,
    ) -> ctl_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_mux_output_handle_t {
    _unused: [u8; 0],
}
#[doc = "\n @brief Handle of a MUX output instance"]
pub type ctl_mux_output_handle_t = *mut _ctl_mux_output_handle_t;
extern "C" {
    #[doc = "\n @brief Enumerate Display MUX Devices on this system across adapters\n\n @details\n     - The application enumerates all MUX devices in the system\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hAPIHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`\n         + `nullptr == phMuxDevices`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlEnumerateMuxDevices(
        hAPIHandle: ctl_api_handle_t,
        pCount: *mut u32,
        phMuxDevices: *mut ctl_mux_output_handle_t,
    ) -> ctl_result_t;
}
#[doc = "\n @brief Display MUX device properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_mux_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] MUX ID of this MUX device enumerated"]
    pub MuxId: u8,
    #[doc = "< [in,out] Pointer to the number of display output instances this MUX\n< object can drive. If count is zero, then the api will update the value\n< with the total\n< number of outputs available. If count is non-zero, then the api will\n< only retrieve the number of outputs.\n< If count is larger than the number of display outputs MUX can drive,\n< then the api will update the value with the correct number of display\n< outputs MUX can driver."]
    pub Count: u32,
    #[doc = "< [in,out][range(0, *pCount)] Array of display output instance handles\n< this MUX device can drive"]
    pub phDisplayOutputs: *mut ctl_display_output_handle_t,
    #[doc = "< [out] [range(0, (Count-1))] This is the index into the\n< phDisplayOutputs list to the display output which currently owns the\n< MUX output. This doesn't mean display is active"]
    pub IndexOfDisplayOutputOwningMux: u8,
}
#[test]
fn bindgen_test_layout__ctl_mux_properties_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_mux_properties_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_mux_properties_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ctl_mux_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_mux_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_mux_properties_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mux_properties_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mux_properties_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MuxId) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mux_properties_t),
            "::",
            stringify!(MuxId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mux_properties_t),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phDisplayOutputs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mux_properties_t),
            "::",
            stringify!(phDisplayOutputs)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).IndexOfDisplayOutputOwningMux) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mux_properties_t),
            "::",
            stringify!(IndexOfDisplayOutputOwningMux)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get Display Mux properties\n\n @details\n     - Get the propeties of the Mux device\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hMuxDevice`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pMuxProperties`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetMuxProperties(
        hMuxDevice: ctl_mux_output_handle_t,
        pMuxProperties: *mut ctl_mux_properties_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Switch Mux output\n\n @details\n     - Switches the MUX output\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hMuxDevice`\n         + `nullptr == hInactiveDisplayOutput`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlSwitchMux(
        hMuxDevice: ctl_mux_output_handle_t,
        hInactiveDisplayOutput: ctl_display_output_handle_t,
    ) -> ctl_result_t;
}
#[doc = "< Invalid profile"]
pub const _ctl_intel_arc_sync_profile_t_CTL_INTEL_ARC_SYNC_PROFILE_INVALID:
    _ctl_intel_arc_sync_profile_t = 0;
#[doc = "< Default. Selects appropriate profile based on the monitor. COMPATIBLE\n< profile is applied if profile is not available for the monitor"]
pub const _ctl_intel_arc_sync_profile_t_CTL_INTEL_ARC_SYNC_PROFILE_RECOMMENDED:
    _ctl_intel_arc_sync_profile_t = 1;
#[doc = "< Unconstrained. Full VRR range of the monitor can be used"]
pub const _ctl_intel_arc_sync_profile_t_CTL_INTEL_ARC_SYNC_PROFILE_EXCELLENT:
    _ctl_intel_arc_sync_profile_t = 2;
#[doc = "< Some minor range constraints, unlikely to effect user experience but\n< can reduce flicker on some monitors"]
pub const _ctl_intel_arc_sync_profile_t_CTL_INTEL_ARC_SYNC_PROFILE_GOOD:
    _ctl_intel_arc_sync_profile_t = 3;
#[doc = "< Significant constraints that will reduce flicker considerably but are\n< likely to cause some level of judder onscreen especially when refresh\n< rates are changing rapidly"]
pub const _ctl_intel_arc_sync_profile_t_CTL_INTEL_ARC_SYNC_PROFILE_COMPATIBLE:
    _ctl_intel_arc_sync_profile_t = 4;
#[doc = "< Disable Intel Arc Sync on this monitor. This disables variable rate\n< flips on this monitor. All sync flips will occur at the OS requested\n< refresh rate"]
pub const _ctl_intel_arc_sync_profile_t_CTL_INTEL_ARC_SYNC_PROFILE_OFF:
    _ctl_intel_arc_sync_profile_t = 5;
#[doc = "< Applies vesa specified constraints if the monitor has provided them,\n< COMPATIBLE profile if not"]
pub const _ctl_intel_arc_sync_profile_t_CTL_INTEL_ARC_SYNC_PROFILE_VESA:
    _ctl_intel_arc_sync_profile_t = 6;
#[doc = "< Unlocks controls to set a custom Intel Arc Sync profile"]
pub const _ctl_intel_arc_sync_profile_t_CTL_INTEL_ARC_SYNC_PROFILE_CUSTOM:
    _ctl_intel_arc_sync_profile_t = 7;
pub const _ctl_intel_arc_sync_profile_t_CTL_INTEL_ARC_SYNC_PROFILE_MAX:
    _ctl_intel_arc_sync_profile_t = 8;
#[doc = "\n @brief Intel Arc Sync profile"]
pub type _ctl_intel_arc_sync_profile_t = ::std::os::raw::c_int;
#[doc = "\n @brief Intel Arc Sync profile"]
pub use self::_ctl_intel_arc_sync_profile_t as ctl_intel_arc_sync_profile_t;
#[doc = "\n @brief Intel Arc Sync Profile Params"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_intel_arc_sync_profile_params_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Intel Arc Sync profile used by driver. Refer\n< ::ctl_intel_arc_sync_profile_t"]
    pub IntelArcSyncProfile: ctl_intel_arc_sync_profile_t,
    #[doc = "< [in,out] Maximum refresh rate utilized by the driver"]
    pub MaxRefreshRateInHz: f32,
    #[doc = "< [in,out] Minimum refresh rate utilized by the driver"]
    pub MinRefreshRateInHz: f32,
    #[doc = "< [in,out] Maximum frame time increase (in micro seconds) imposed by the\n< driver"]
    pub MaxFrameTimeIncreaseInUs: u32,
    #[doc = "< [in,out] Maximum frame time decrease (in micro seconds) imposed by the\n< driver"]
    pub MaxFrameTimeDecreaseInUs: u32,
}
#[test]
fn bindgen_test_layout__ctl_intel_arc_sync_profile_params_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_intel_arc_sync_profile_params_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_intel_arc_sync_profile_params_t>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_intel_arc_sync_profile_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_intel_arc_sync_profile_params_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_intel_arc_sync_profile_params_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_intel_arc_sync_profile_params_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_intel_arc_sync_profile_params_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IntelArcSyncProfile) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_intel_arc_sync_profile_params_t),
            "::",
            stringify!(IntelArcSyncProfile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxRefreshRateInHz) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_intel_arc_sync_profile_params_t),
            "::",
            stringify!(MaxRefreshRateInHz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MinRefreshRateInHz) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_intel_arc_sync_profile_params_t),
            "::",
            stringify!(MinRefreshRateInHz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxFrameTimeIncreaseInUs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_intel_arc_sync_profile_params_t),
            "::",
            stringify!(MaxFrameTimeIncreaseInUs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxFrameTimeDecreaseInUs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_intel_arc_sync_profile_params_t),
            "::",
            stringify!(MaxFrameTimeDecreaseInUs)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get Intel Arc Sync profile\n\n @details\n     - Returns Intel Arc Sync profile for selected monitor\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pIntelArcSyncProfileParams`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetIntelArcSyncProfile(
        hDisplayOutput: ctl_display_output_handle_t,
        pIntelArcSyncProfileParams: *mut ctl_intel_arc_sync_profile_params_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Set Intel Arc Sync profile\n\n @details\n     - Sets Intel Arc Sync profile for selected monitor. In a mux situation,\n       this API should be called for all display IDs associated with a\n       physical display.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pIntelArcSyncProfileParams`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlSetIntelArcSyncProfile(
        hDisplayOutput: ctl_display_output_handle_t,
        pIntelArcSyncProfileParams: *mut ctl_intel_arc_sync_profile_params_t,
    ) -> ctl_result_t;
}
#[doc = "< This operation type is to read an output's EDID. Set edid_type input\n< arg to read MONITOR EDID or previously OVERRIDDEN EDID or CURRENT\n< active EDID. Read EDID is a 2 pass call. First call with size = 0,\n< pEdidBuf = nullptr to get the size, then call with allocated buffer to\n< get the EDID data. READ operation is applicable for any normal, edid\n< locked or edid overridden display output device."]
pub const _ctl_edid_management_optype_t_CTL_EDID_MANAGEMENT_OPTYPE_READ_EDID:
    _ctl_edid_management_optype_t = 1;
#[doc = "< To make an output always connected with OVERRIDE or MONITOR EDID\n< across reboots. When output isn't connected call with OVERRIDE EDID;\n< when connected, either set OVERRIDE and provide pEdidBuf or set\n< MONITOR and driver will use monitor's EDID. There is no change to EDID\n< stored in Monitor. Cannot be called when override is active. Any OS\n< EDID override will take precedence over IGCL override."]
pub const _ctl_edid_management_optype_t_CTL_EDID_MANAGEMENT_OPTYPE_LOCK_EDID:
    _ctl_edid_management_optype_t = 2;
#[doc = "< To undo lock EDID operation, i.e. it makes output as detached in\n< response to unplug. This operation removes past supplied EDID; output\n< status is reported to OS as it is; output restores back to monitor's\n< EDID when it is connected"]
pub const _ctl_edid_management_optype_t_CTL_EDID_MANAGEMENT_OPTYPE_UNLOCK_EDID:
    _ctl_edid_management_optype_t = 3;
#[doc = "< To replace an output's EDID with supplied one (pEdidBuf) only when\n< physical display is connected. There is no change to EDID stored in\n< Monitor. Cannot apply this operation on locked output. When no output\n< device attached, the supplied EDID will be persisted in driver for\n< future use. Any OS EDID override will take precedence over IGCL\n< override."]
pub const _ctl_edid_management_optype_t_CTL_EDID_MANAGEMENT_OPTYPE_OVERRIDE_EDID:
    _ctl_edid_management_optype_t = 4;
#[doc = "< To undo override EDID operation, that is remove previously overridden\n< EDID on an output. Output restores back to monitor's EDID when it is\n< connected"]
pub const _ctl_edid_management_optype_t_CTL_EDID_MANAGEMENT_OPTYPE_UNDO_OVERRIDE_EDID:
    _ctl_edid_management_optype_t = 5;
pub const _ctl_edid_management_optype_t_CTL_EDID_MANAGEMENT_OPTYPE_MAX:
    _ctl_edid_management_optype_t = 6;
#[doc = "\n @brief EDID Management operation type"]
pub type _ctl_edid_management_optype_t = ::std::os::raw::c_int;
#[doc = "\n @brief EDID Management operation type"]
pub use self::_ctl_edid_management_optype_t as ctl_edid_management_optype_t;
#[doc = "< [in] Used to return currently active EDID in READ_EDID call."]
pub const _ctl_edid_type_t_CTL_EDID_TYPE_CURRENT: _ctl_edid_type_t = 1;
#[doc = "< [in] Is it user supplied EDID. Used in LOCK_EDID call with Supplied\n< EDID or in READ_EDID to get Supplied EDID."]
pub const _ctl_edid_type_t_CTL_EDID_TYPE_OVERRIDE: _ctl_edid_type_t = 2;
#[doc = "< [in] Is it Monitor's EDID. Used in LOCK_EDID and READ_EDID calls."]
pub const _ctl_edid_type_t_CTL_EDID_TYPE_MONITOR: _ctl_edid_type_t = 3;
pub const _ctl_edid_type_t_CTL_EDID_TYPE_MAX: _ctl_edid_type_t = 4;
#[doc = "\n @brief EDID type. Used in LOCK_EDID and READ_EDID calls."]
pub type _ctl_edid_type_t = ::std::os::raw::c_int;
#[doc = "\n @brief EDID type. Used in LOCK_EDID and READ_EDID calls."]
pub use self::_ctl_edid_type_t as ctl_edid_type_t;
#[doc = "\n @brief Edid management operation Out Flags"]
pub type ctl_edid_management_out_flags_t = u32;
#[doc = "< [out] If OS was notified about a connection change. App will need to\n< wait for the OS action to complete."]
pub const _ctl_edid_management_out_flag_t_CTL_EDID_MANAGEMENT_OUT_FLAG_OS_CONN_NOTIFICATION:
    _ctl_edid_management_out_flag_t = 1;
#[doc = "< [out] Is it previously supplied EDID, set for READ_EDID(CURRENT)."]
pub const _ctl_edid_management_out_flag_t_CTL_EDID_MANAGEMENT_OUT_FLAG_SUPPLIED_EDID:
    _ctl_edid_management_out_flag_t = 2;
#[doc = "< [out] Is it Monitor's EDID, set for READ_EDID(CURRENT)."]
pub const _ctl_edid_management_out_flag_t_CTL_EDID_MANAGEMENT_OUT_FLAG_MONITOR_EDID:
    _ctl_edid_management_out_flag_t = 4;
#[doc = "< [out] Is Monitor physically connected"]
pub const _ctl_edid_management_out_flag_t_CTL_EDID_MANAGEMENT_OUT_FLAG_DISPLAY_CONNECTED:
    _ctl_edid_management_out_flag_t = 8;
pub const _ctl_edid_management_out_flag_t_CTL_EDID_MANAGEMENT_OUT_FLAG_MAX:
    _ctl_edid_management_out_flag_t = -2147483648;
pub type _ctl_edid_management_out_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_edid_management_out_flag_t as ctl_edid_management_out_flag_t;
#[doc = "\n @brief EDID management"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_edid_management_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] EDID managmeent operation type"]
    pub OpType: ctl_edid_management_optype_t,
    #[doc = "< [in] EDID Type, Monitor or Supplied"]
    pub EdidType: ctl_edid_type_t,
    #[doc = "< [in,out] EDID Size, should be 0 for querying the size of EDID, should\n< be previously returned size to read EDID. if buffer isn't big enough\n< to fit EDID, returns size of EDID bytes."]
    pub EdidSize: u32,
    #[doc = "< [in,out] buffer holding EDID data"]
    pub pEdidBuf: *mut u8,
    #[doc = "< [out] Output flags to inform about status of EDID management\n< operations"]
    pub OutFlags: ctl_edid_management_out_flags_t,
}
#[test]
fn bindgen_test_layout__ctl_edid_management_args_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_edid_management_args_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_edid_management_args_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ctl_edid_management_args_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_edid_management_args_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_edid_management_args_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_edid_management_args_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_edid_management_args_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OpType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_edid_management_args_t),
            "::",
            stringify!(OpType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EdidType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_edid_management_args_t),
            "::",
            stringify!(EdidType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EdidSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_edid_management_args_t),
            "::",
            stringify!(EdidSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pEdidBuf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_edid_management_args_t),
            "::",
            stringify!(pEdidBuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OutFlags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_edid_management_args_t),
            "::",
            stringify!(OutFlags)
        )
    );
}
extern "C" {
    #[doc = "\n @brief EDID Management allows managing an output's EDID or Plugged Status.\n\n @details\n     - To manage output's EDID or Display ID. Supports native DP SST and HDMI\n       Display types.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pEdidManagementArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernal mode driver call failure\"\n     - ::CTL_RESULT_ERROR_INVALID_ARGUMENT - \"Invalid combination of parameters\"\n     - ::CTL_RESULT_ERROR_DISPLAY_NOT_ATTACHED - \"Error for Output Device not attached\"\n     - ::CTL_RESULT_ERROR_OUT_OF_DEVICE_MEMORY - \"Insufficient device memory to satisfy call\"\n     - ::CTL_RESULT_ERROR_DATA_NOT_FOUND - \"Requested EDID data not present.\""]
    pub fn ctlEdidManagement(
        hDisplayOutput: ctl_display_output_handle_t,
        pEdidManagementArgs: *mut ctl_edid_management_args_t,
    ) -> ctl_result_t;
}
#[doc = "< Get details of all previous applied custom modes if any."]
pub const _ctl_custom_mode_operation_types_t_CTL_CUSTOM_MODE_OPERATION_TYPES_GET_CUSTOM_SOURCE_MODES : _ctl_custom_mode_operation_types_t = 0 ;
#[doc = "< Add a new mode. Allows only single mode adition at a time."]
pub const _ctl_custom_mode_operation_types_t_CTL_CUSTOM_MODE_OPERATION_TYPES_ADD_CUSTOM_SOURCE_MODE : _ctl_custom_mode_operation_types_t = 1 ;
#[doc = "< Remove previously added custom mode. Allows single or multiple mode\n< removal at a time."]
pub const _ctl_custom_mode_operation_types_t_CTL_CUSTOM_MODE_OPERATION_TYPES_REMOVE_CUSTOM_SOURCE_MODES : _ctl_custom_mode_operation_types_t = 2 ;
pub const _ctl_custom_mode_operation_types_t_CTL_CUSTOM_MODE_OPERATION_TYPES_MAX:
    _ctl_custom_mode_operation_types_t = 3;
#[doc = "\n @brief Custom mode operation types"]
pub type _ctl_custom_mode_operation_types_t = ::std::os::raw::c_int;
#[doc = "\n @brief Custom mode operation types"]
pub use self::_ctl_custom_mode_operation_types_t as ctl_custom_mode_operation_types_t;
#[doc = "\n @brief Get/Set Custom Mode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_get_set_custom_mode_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Custom mode operation type"]
    pub CustomModeOpType: ctl_custom_mode_operation_types_t,
    #[doc = "< [in,out] Number of Custom Src Modes to be added/removed/Read."]
    pub NumOfModes: u32,
    #[doc = "< [in,out] Custom mode source list which holds source modes to be\n< added/removed/Read."]
    pub pCustomSrcModeList: *mut ctl_custom_src_mode_t,
}
#[test]
fn bindgen_test_layout__ctl_get_set_custom_mode_args_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_get_set_custom_mode_args_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_get_set_custom_mode_args_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_get_set_custom_mode_args_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_get_set_custom_mode_args_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_get_set_custom_mode_args_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_get_set_custom_mode_args_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_get_set_custom_mode_args_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CustomModeOpType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_get_set_custom_mode_args_t),
            "::",
            stringify!(CustomModeOpType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumOfModes) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_get_set_custom_mode_args_t),
            "::",
            stringify!(NumOfModes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCustomSrcModeList) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_get_set_custom_mode_args_t),
            "::",
            stringify!(pCustomSrcModeList)
        )
    );
}
#[doc = "\n @brief Get/Set Custom Mode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_custom_src_mode_t {
    #[doc = "< [in,out] CustomMode Source X Size"]
    pub SourceX: u32,
    #[doc = "< [in,out] CustomMode Source Y Size"]
    pub SourceY: u32,
}
#[test]
fn bindgen_test_layout__ctl_custom_src_mode_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_custom_src_mode_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_custom_src_mode_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ctl_custom_src_mode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_custom_src_mode_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_custom_src_mode_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SourceX) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_custom_src_mode_t),
            "::",
            stringify!(SourceX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SourceY) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_custom_src_mode_t),
            "::",
            stringify!(SourceY)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get/Set Custom mode.\n\n @details\n     - To get or set custom mode.\n     - Add custom source mode operation supports only single mode additon at\n       a time.\n     - Remove custom source mode operation supports single or multiple mode\n       removal at a time.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDisplayOutput`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCustomModeArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernal mode driver call failure\"\n     - ::CTL_RESULT_ERROR_INVALID_ARGUMENT - \"Invalid combination of parameters\"\n     - ::CTL_RESULT_ERROR_CUSTOM_MODE_STANDARD_CUSTOM_MODE_EXISTS - \"Standard custom mode exists\"\n     - ::CTL_RESULT_ERROR_CUSTOM_MODE_NON_CUSTOM_MATCHING_MODE_EXISTS - \"Non custom matching mode exists\"\n     - ::CTL_RESULT_ERROR_CUSTOM_MODE_INSUFFICIENT_MEMORY - \"Custom mode insufficent memory\""]
    pub fn ctlGetSetCustomMode(
        hDisplayOutput: ctl_display_output_handle_t,
        pCustomModeArgs: *mut ctl_get_set_custom_mode_args_t,
    ) -> ctl_result_t;
}
#[doc = "< To check whether given outputs can form a combined display, no changes\n< are applied"]
pub const _ctl_combined_display_optype_t_CTL_COMBINED_DISPLAY_OPTYPE_IS_SUPPORTED_CONFIG:
    _ctl_combined_display_optype_t = 1;
#[doc = "< To setup and enable a combined display"]
pub const _ctl_combined_display_optype_t_CTL_COMBINED_DISPLAY_OPTYPE_ENABLE:
    _ctl_combined_display_optype_t = 2;
#[doc = "< To disable combined display"]
pub const _ctl_combined_display_optype_t_CTL_COMBINED_DISPLAY_OPTYPE_DISABLE:
    _ctl_combined_display_optype_t = 3;
#[doc = "< To query combined display configuration"]
pub const _ctl_combined_display_optype_t_CTL_COMBINED_DISPLAY_OPTYPE_QUERY_CONFIG:
    _ctl_combined_display_optype_t = 4;
pub const _ctl_combined_display_optype_t_CTL_COMBINED_DISPLAY_OPTYPE_MAX:
    _ctl_combined_display_optype_t = 5;
#[doc = "\n @brief Combined Display operation type"]
pub type _ctl_combined_display_optype_t = ::std::os::raw::c_int;
#[doc = "\n @brief Combined Display operation type"]
pub use self::_ctl_combined_display_optype_t as ctl_combined_display_optype_t;
#[doc = "\n @brief Combined Display's child display target mode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_child_display_target_mode_t {
    #[doc = "< [in,out] Width"]
    pub Width: u32,
    #[doc = "< [in,out] Height"]
    pub Height: u32,
    #[doc = "< [in,out] Refresh Rate"]
    pub RefreshRate: f32,
    #[doc = "< [out] Reserved field of 16 bytes"]
    pub ReservedFields: [u32; 4usize],
}
#[test]
fn bindgen_test_layout__ctl_child_display_target_mode_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_child_display_target_mode_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_child_display_target_mode_t>(),
        28usize,
        concat!("Size of: ", stringify!(_ctl_child_display_target_mode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_child_display_target_mode_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_child_display_target_mode_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_child_display_target_mode_t),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_child_display_target_mode_t),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RefreshRate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_child_display_target_mode_t),
            "::",
            stringify!(RefreshRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_child_display_target_mode_t),
            "::",
            stringify!(ReservedFields)
        )
    );
}
#[doc = "\n @brief Combined Display's child display information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_combined_display_child_info_t {
    #[doc = "< [in,out] Display output handle under combined display configuration"]
    pub hDisplayOutput: ctl_display_output_handle_t,
    #[doc = "< [in,out] FrameBuffer source's RECT within Combined Display respective"]
    pub FbSrc: ctl_rect_t,
    #[doc = "< [in,out] FrameBuffer target's RECT within output size"]
    pub FbPos: ctl_rect_t,
    #[doc = "< [in,out] 0/180 Degree Display orientation (rotation)"]
    pub DisplayOrientation: ctl_display_orientation_t,
    #[doc = "< [in,out] Desired target mode (width, height, refresh)"]
    pub TargetMode: ctl_child_display_target_mode_t,
}
#[test]
fn bindgen_test_layout__ctl_combined_display_child_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_combined_display_child_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_combined_display_child_info_t>(),
        72usize,
        concat!("Size of: ", stringify!(_ctl_combined_display_child_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_combined_display_child_info_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_combined_display_child_info_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hDisplayOutput) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_combined_display_child_info_t),
            "::",
            stringify!(hDisplayOutput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FbSrc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_combined_display_child_info_t),
            "::",
            stringify!(FbSrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FbPos) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_combined_display_child_info_t),
            "::",
            stringify!(FbPos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DisplayOrientation) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_combined_display_child_info_t),
            "::",
            stringify!(DisplayOrientation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetMode) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_combined_display_child_info_t),
            "::",
            stringify!(TargetMode)
        )
    );
}
#[doc = "\n @brief Combined Display arguments"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_combined_display_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Combined display operation type"]
    pub OpType: ctl_combined_display_optype_t,
    #[doc = "< [out] Returns yes/no in response to IS_SUPPORTED_CONFIG command"]
    pub IsSupported: bool,
    #[doc = "< [in,out] Number of outputs part of desired combined display\n< configuration"]
    pub NumOutputs: u8,
    #[doc = "< [in,out] Width of desired combined display configuration"]
    pub CombinedDesktopWidth: u32,
    #[doc = "< [in,out] Height of desired combined display configuration"]
    pub CombinedDesktopHeight: u32,
    #[doc = "< [in,out] List of child display information respective to each output"]
    pub pChildInfo: *mut ctl_combined_display_child_info_t,
    #[doc = "< [in,out] Handle to combined display output"]
    pub hCombinedDisplayOutput: ctl_display_output_handle_t,
}
#[test]
fn bindgen_test_layout__ctl_combined_display_args_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_combined_display_args_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_combined_display_args_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ctl_combined_display_args_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_combined_display_args_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_combined_display_args_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_combined_display_args_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_combined_display_args_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OpType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_combined_display_args_t),
            "::",
            stringify!(OpType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsSupported) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_combined_display_args_t),
            "::",
            stringify!(IsSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumOutputs) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_combined_display_args_t),
            "::",
            stringify!(NumOutputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CombinedDesktopWidth) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_combined_display_args_t),
            "::",
            stringify!(CombinedDesktopWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CombinedDesktopHeight) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_combined_display_args_t),
            "::",
            stringify!(CombinedDesktopHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pChildInfo) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_combined_display_args_t),
            "::",
            stringify!(pChildInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hCombinedDisplayOutput) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_combined_display_args_t),
            "::",
            stringify!(hCombinedDisplayOutput)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get/Set Combined Display\n\n @details\n     - To get or set combined display.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceAdapter`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCombinedDisplayArgs`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_OPERATION_TYPE - \"Invalid operation type\"\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS - \"Insufficient permissions\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernel mode driver call failure\"\n     - ::CTL_RESULT_ERROR_FEATURE_NOT_SUPPORTED - \"Combined Display feature is not supported in this platform\""]
    pub fn ctlGetSetCombinedDisplay(
        hDeviceAdapter: ctl_device_adapter_handle_t,
        pCombinedDisplayArgs: *mut ctl_combined_display_args_t,
    ) -> ctl_result_t;
}
#[doc = "< Get details of GENLOCK support and timing information"]
pub const _ctl_genlock_operation_t_CTL_GENLOCK_OPERATION_GET_TIMING_DETAILS:
    _ctl_genlock_operation_t = 0;
#[doc = "< Driver to verify that the topology is Genlock capable"]
pub const _ctl_genlock_operation_t_CTL_GENLOCK_OPERATION_VALIDATE: _ctl_genlock_operation_t = 1;
#[doc = "< Enable GENLOCK"]
pub const _ctl_genlock_operation_t_CTL_GENLOCK_OPERATION_ENABLE: _ctl_genlock_operation_t = 2;
#[doc = "< Disable GENLOCK"]
pub const _ctl_genlock_operation_t_CTL_GENLOCK_OPERATION_DISABLE: _ctl_genlock_operation_t = 3;
#[doc = "< Get details of the current Genlock topology that is applied"]
pub const _ctl_genlock_operation_t_CTL_GENLOCK_OPERATION_GET_TOPOLOGY: _ctl_genlock_operation_t = 4;
pub const _ctl_genlock_operation_t_CTL_GENLOCK_OPERATION_MAX: _ctl_genlock_operation_t = 5;
#[doc = "\n @brief Display Genlock Operations"]
pub type _ctl_genlock_operation_t = ::std::os::raw::c_int;
#[doc = "\n @brief Display Genlock Operations"]
pub use self::_ctl_genlock_operation_t as ctl_genlock_operation_t;
#[doc = "\n @brief Display Genlock Info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_genlock_display_info_t {
    #[doc = "< [in,out] Display output handle under Genlock topology"]
    pub hDisplayOutput: ctl_display_output_handle_t,
    #[doc = "< [in,out] Genlock Primary"]
    pub IsPrimary: bool,
}
#[test]
fn bindgen_test_layout__ctl_genlock_display_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_genlock_display_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_genlock_display_info_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ctl_genlock_display_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_genlock_display_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_genlock_display_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hDisplayOutput) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_genlock_display_info_t),
            "::",
            stringify!(hDisplayOutput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsPrimary) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_genlock_display_info_t),
            "::",
            stringify!(IsPrimary)
        )
    );
}
#[doc = "\n @brief Genlock Target Mode List"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_genlock_target_mode_list_t {
    #[doc = "< [in] Display output handle for whom target mode list is required"]
    pub hDisplayOutput: ctl_display_output_handle_t,
    #[doc = "< [in,out] Number of supported Modes that is returned from a driver"]
    pub NumModes: u32,
    #[doc = "< [out] Display Genlock operation and information"]
    pub pTargetModes: *mut ctl_display_timing_t,
}
#[test]
fn bindgen_test_layout__ctl_genlock_target_mode_list_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_genlock_target_mode_list_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_genlock_target_mode_list_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_genlock_target_mode_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_genlock_target_mode_list_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_genlock_target_mode_list_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hDisplayOutput) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_genlock_target_mode_list_t),
            "::",
            stringify!(hDisplayOutput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumModes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_genlock_target_mode_list_t),
            "::",
            stringify!(NumModes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pTargetModes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_genlock_target_mode_list_t),
            "::",
            stringify!(pTargetModes)
        )
    );
}
#[doc = "\n @brief Genlock Topology"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_genlock_topology_t {
    #[doc = "< [in,out] Number of Genlock displays"]
    pub NumGenlockDisplays: u8,
    #[doc = "< [in,out] Primary Genlock system"]
    pub IsPrimaryGenlockSystem: bool,
    #[doc = "< [in] Common target mode"]
    pub CommonTargetMode: ctl_display_timing_t,
    #[doc = "< [in,out] List of Genlock display info"]
    pub pGenlockDisplayInfo: *mut ctl_genlock_display_info_t,
    #[doc = "< [out] List of Genlock target modes"]
    pub pGenlockModeList: *mut ctl_genlock_target_mode_list_t,
}
#[test]
fn bindgen_test_layout__ctl_genlock_topology_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_genlock_topology_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_genlock_topology_t>(),
        88usize,
        concat!("Size of: ", stringify!(_ctl_genlock_topology_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_genlock_topology_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_genlock_topology_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumGenlockDisplays) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_genlock_topology_t),
            "::",
            stringify!(NumGenlockDisplays)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsPrimaryGenlockSystem) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_genlock_topology_t),
            "::",
            stringify!(IsPrimaryGenlockSystem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CommonTargetMode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_genlock_topology_t),
            "::",
            stringify!(CommonTargetMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pGenlockDisplayInfo) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_genlock_topology_t),
            "::",
            stringify!(pGenlockDisplayInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pGenlockModeList) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_genlock_topology_t),
            "::",
            stringify!(pGenlockModeList)
        )
    );
}
#[doc = "\n @brief Display Genlock Arg type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_genlock_args_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Display Genlock Operation"]
    pub Operation: ctl_genlock_operation_t,
    #[doc = "< [in,out] Display Genlock array of topology structures"]
    pub GenlockTopology: ctl_genlock_topology_t,
    #[doc = "< [out] Whether the feature is currently enabled or not"]
    pub IsGenlockEnabled: bool,
    #[doc = "< [out] Indicates if Genlock can be enabled/disabled with the given\n< topology"]
    pub IsGenlockPossible: bool,
}
#[test]
fn bindgen_test_layout__ctl_genlock_args_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_genlock_args_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_genlock_args_t>(),
        112usize,
        concat!("Size of: ", stringify!(_ctl_genlock_args_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_genlock_args_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_genlock_args_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_genlock_args_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_genlock_args_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Operation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_genlock_args_t),
            "::",
            stringify!(Operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GenlockTopology) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_genlock_args_t),
            "::",
            stringify!(GenlockTopology)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsGenlockEnabled) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_genlock_args_t),
            "::",
            stringify!(IsGenlockEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IsGenlockPossible) as usize - ptr as usize },
        105usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_genlock_args_t),
            "::",
            stringify!(IsGenlockPossible)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get/Set Display Genlock\n\n @details\n     - To get or set Display Genlock.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == hDeviceAdapter`\n         + `nullptr == pGenlockArgs`\n         + `nullptr == hFailureDeviceAdapter`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\"\n     - ::CTL_RESULT_ERROR_INVALID_NULL_POINTER - \"Invalid null pointer\"\n     - ::CTL_RESULT_ERROR_NULL_OS_DISPLAY_OUTPUT_HANDLE - \"Null OS display output handle\"\n     - ::CTL_RESULT_ERROR_NULL_OS_INTERFACE - \"Null OS interface\"\n     - ::CTL_RESULT_ERROR_NULL_OS_ADAPATER_HANDLE - \"Null OS adapter handle\"\n     - ::CTL_RESULT_ERROR_INVALID_SIZE - \"Invalid topology structure size\"\n     - ::CTL_RESULT_ERROR_KMD_CALL - \"Kernel mode driver call failure\""]
    pub fn ctlGetSetDisplayGenlock(
        hDeviceAdapter: *mut ctl_device_adapter_handle_t,
        pGenlockArgs: *mut *mut ctl_genlock_args_t,
        AdapterCount: u32,
        hFailureDeviceAdapter: *mut ctl_device_adapter_handle_t,
    ) -> ctl_result_t;
}
#[doc = "< Access information about all engines combined."]
pub const _ctl_engine_group_t_CTL_ENGINE_GROUP_GT: _ctl_engine_group_t = 0;
#[doc = "< Access information about all render and compute engines combined."]
pub const _ctl_engine_group_t_CTL_ENGINE_GROUP_RENDER: _ctl_engine_group_t = 1;
#[doc = "< Access information about all media engines combined."]
pub const _ctl_engine_group_t_CTL_ENGINE_GROUP_MEDIA: _ctl_engine_group_t = 2;
pub const _ctl_engine_group_t_CTL_ENGINE_GROUP_MAX: _ctl_engine_group_t = 3;
#[doc = "\n @brief Accelerator engine groups"]
pub type _ctl_engine_group_t = ::std::os::raw::c_int;
#[doc = "\n @brief Accelerator engine groups"]
pub use self::_ctl_engine_group_t as ctl_engine_group_t;
#[doc = "\n @brief Engine group properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_engine_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The engine group"]
    pub type_: ctl_engine_group_t,
}
#[test]
fn bindgen_test_layout__ctl_engine_properties_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_engine_properties_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_engine_properties_t>(),
        12usize,
        concat!("Size of: ", stringify!(_ctl_engine_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_engine_properties_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_engine_properties_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_engine_properties_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_engine_properties_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_engine_properties_t),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = "\n @brief Engine activity counters\n\n @details\n     - Percent utilization is calculated by taking two snapshots (s1, s2) and\n       using the equation: %util = (s2.activeTime - s1.activeTime) /\n       (s2.timestamp - s1.timestamp)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_engine_stats_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Monotonic counter for time in microseconds that this resource is\n< actively running workloads."]
    pub activeTime: u64,
    #[doc = "< [out] Monotonic timestamp counter in microseconds when activeTime\n< counter was sampled.\n< This timestamp should only be used to calculate delta time between\n< snapshots of this structure.\n< Never take the delta of this timestamp with the timestamp from a\n< different structure since they are not guaranteed to have the same base.\n< The absolute value of the timestamp is only valid during within the\n< application and may be different on the next execution."]
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout__ctl_engine_stats_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_engine_stats_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_engine_stats_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_engine_stats_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_engine_stats_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_engine_stats_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_engine_stats_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_engine_stats_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activeTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_engine_stats_t),
            "::",
            stringify!(activeTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_engine_stats_t),
            "::",
            stringify!(timestamp)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get handle of engine groups\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`"]
    pub fn ctlEnumEngineGroups(
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phEngine: *mut ctl_engine_handle_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get engine group properties\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hEngine`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`"]
    pub fn ctlEngineGetProperties(
        hEngine: ctl_engine_handle_t,
        pProperties: *mut ctl_engine_properties_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get the activity stats for an engine group\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hEngine`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pStats`"]
    pub fn ctlEngineGetActivity(
        hEngine: ctl_engine_handle_t,
        pStats: *mut ctl_engine_stats_t,
    ) -> ctl_result_t;
}
#[doc = "< The fan speed is operating using the hardware default settings"]
pub const _ctl_fan_speed_mode_t_CTL_FAN_SPEED_MODE_DEFAULT: _ctl_fan_speed_mode_t = 0;
#[doc = "< The fan speed is currently set to a fixed value"]
pub const _ctl_fan_speed_mode_t_CTL_FAN_SPEED_MODE_FIXED: _ctl_fan_speed_mode_t = 1;
#[doc = "< The fan speed is currently controlled dynamically by hardware based on\n< a temp/speed table"]
pub const _ctl_fan_speed_mode_t_CTL_FAN_SPEED_MODE_TABLE: _ctl_fan_speed_mode_t = 2;
pub const _ctl_fan_speed_mode_t_CTL_FAN_SPEED_MODE_MAX: _ctl_fan_speed_mode_t = 3;
#[doc = "\n @brief Fan resource speed mode"]
pub type _ctl_fan_speed_mode_t = ::std::os::raw::c_int;
#[doc = "\n @brief Fan resource speed mode"]
pub use self::_ctl_fan_speed_mode_t as ctl_fan_speed_mode_t;
#[doc = "< The fan speed is in units of revolutions per minute (rpm)"]
pub const _ctl_fan_speed_units_t_CTL_FAN_SPEED_UNITS_RPM: _ctl_fan_speed_units_t = 0;
#[doc = "< The fan speed is a percentage of the maximum speed of the fan"]
pub const _ctl_fan_speed_units_t_CTL_FAN_SPEED_UNITS_PERCENT: _ctl_fan_speed_units_t = 1;
pub const _ctl_fan_speed_units_t_CTL_FAN_SPEED_UNITS_MAX: _ctl_fan_speed_units_t = 2;
#[doc = "\n @brief Fan speed units"]
pub type _ctl_fan_speed_units_t = ::std::os::raw::c_int;
#[doc = "\n @brief Fan speed units"]
pub use self::_ctl_fan_speed_units_t as ctl_fan_speed_units_t;
#[doc = "\n @brief Fan speed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_fan_speed_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] The speed of the fan. On output, a value of -1 indicates that\n< there is no fixed fan speed setting."]
    pub speed: i32,
    #[doc = "< [in,out] The units that the fan speed is expressed in. On output, if\n< fan speed is -1 then units should be ignored."]
    pub units: ctl_fan_speed_units_t,
}
#[test]
fn bindgen_test_layout__ctl_fan_speed_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_fan_speed_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_fan_speed_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ctl_fan_speed_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_fan_speed_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_fan_speed_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_speed_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_speed_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_speed_t),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).units) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_speed_t),
            "::",
            stringify!(units)
        )
    );
}
#[doc = "\n @brief Fan temperature/speed pair"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_fan_temp_speed_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Temperature in degrees Celsius."]
    pub temperature: u32,
    #[doc = "< [in,out] The speed of the fan"]
    pub speed: ctl_fan_speed_t,
}
#[test]
fn bindgen_test_layout__ctl_fan_temp_speed_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_fan_temp_speed_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_fan_temp_speed_t>(),
        28usize,
        concat!("Size of: ", stringify!(_ctl_fan_temp_speed_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_fan_temp_speed_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_fan_temp_speed_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_temp_speed_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_temp_speed_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temperature) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_temp_speed_t),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speed) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_temp_speed_t),
            "::",
            stringify!(speed)
        )
    );
}
#[doc = "\n @brief Fan speed table"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_fan_speed_table_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] The number of valid points in the fan speed table. 0 means\n< that there is no fan speed table configured. -1 means that a fan speed\n< table is not supported by the hardware."]
    pub numPoints: i32,
    #[doc = "< [in,out] Array of temperature/fan speed pairs. The table is ordered\n< based on temperature from lowest to highest."]
    pub table: [ctl_fan_temp_speed_t; 32usize],
}
#[test]
fn bindgen_test_layout__ctl_fan_speed_table_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_fan_speed_table_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_fan_speed_table_t>(),
        908usize,
        concat!("Size of: ", stringify!(_ctl_fan_speed_table_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_fan_speed_table_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_fan_speed_table_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_speed_table_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_speed_table_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numPoints) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_speed_table_t),
            "::",
            stringify!(numPoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).table) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_speed_table_t),
            "::",
            stringify!(table)
        )
    );
}
#[doc = "\n @brief Fan properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_fan_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Indicates if software can control the fan speed assuming the\n< user has permissions"]
    pub canControl: bool,
    #[doc = "< [out] Bitfield of supported fan configuration modes\n< (1<<::ctl_fan_speed_mode_t)"]
    pub supportedModes: u32,
    #[doc = "< [out] Bitfield of supported fan speed units\n< (1<<::ctl_fan_speed_units_t)"]
    pub supportedUnits: u32,
    #[doc = "< [out] The maximum RPM of the fan. A value of -1 means that this\n< property is unknown."]
    pub maxRPM: i32,
    #[doc = "< [out] The maximum number of points in the fan temp/speed table. A\n< value of -1 means that this fan doesn't support providing a temp/speed\n< table."]
    pub maxPoints: i32,
}
#[test]
fn bindgen_test_layout__ctl_fan_properties_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_fan_properties_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_fan_properties_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_fan_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_fan_properties_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_fan_properties_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_properties_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_properties_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).canControl) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_properties_t),
            "::",
            stringify!(canControl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supportedModes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_properties_t),
            "::",
            stringify!(supportedModes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supportedUnits) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_properties_t),
            "::",
            stringify!(supportedUnits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxRPM) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_properties_t),
            "::",
            stringify!(maxRPM)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxPoints) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_properties_t),
            "::",
            stringify!(maxPoints)
        )
    );
}
#[doc = "\n @brief Fan configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_fan_config_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] The fan speed mode (fixed, temp-speed table)"]
    pub mode: ctl_fan_speed_mode_t,
    #[doc = "< [in,out] The current fixed fan speed setting"]
    pub speedFixed: ctl_fan_speed_t,
    #[doc = "< [out] A table containing temperature/speed pairs"]
    pub speedTable: ctl_fan_speed_table_t,
}
#[test]
fn bindgen_test_layout__ctl_fan_config_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_fan_config_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_fan_config_t>(),
        936usize,
        concat!("Size of: ", stringify!(_ctl_fan_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_fan_config_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_fan_config_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_config_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_config_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_config_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speedFixed) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_config_t),
            "::",
            stringify!(speedFixed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speedTable) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_fan_config_t),
            "::",
            stringify!(speedTable)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get handle of fans\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`"]
    pub fn ctlEnumFans(
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phFan: *mut ctl_fan_handle_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get fan properties\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFan`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`"]
    pub fn ctlFanGetProperties(
        hFan: ctl_fan_handle_t,
        pProperties: *mut ctl_fan_properties_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get fan configurations and the current fan speed mode (default, fixed,\n        temp-speed table)\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFan`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pConfig`"]
    pub fn ctlFanGetConfig(hFan: ctl_fan_handle_t, pConfig: *mut ctl_fan_config_t) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Configure the fan to run with hardware factory settings (set mode to\n        ::CTL_FAN_SPEED_MODE_DEFAULT)\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFan`\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS\n         + User does not have permissions to make these modifications."]
    pub fn ctlFanSetDefaultMode(hFan: ctl_fan_handle_t) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Configure the fan to rotate at a fixed speed (set mode to\n        ::CTL_FAN_SPEED_MODE_FIXED)\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFan`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == speed`\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS\n         + User does not have permissions to make these modifications.\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_FEATURE\n         + Fixing the fan speed not supported by the hardware or the fan speed units are not supported. See ::ctl_fan_properties_t.supportedModes and ::ctl_fan_properties_t.supportedUnits."]
    pub fn ctlFanSetFixedSpeedMode(
        hFan: ctl_fan_handle_t,
        speed: *const ctl_fan_speed_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Configure the fan to adjust speed based on a temperature/speed table\n        (set mode to ::CTL_FAN_SPEED_MODE_TABLE)\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFan`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == speedTable`\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS\n         + User does not have permissions to make these modifications.\n     - ::CTL_RESULT_ERROR_INVALID_ARGUMENT\n         + The temperature/speed pairs in the array are not sorted on temperature from lowest to highest.\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_FEATURE\n         + Fan speed table not supported by the hardware or the fan speed units are not supported. See ::ctl_fan_properties_t.supportedModes and ::ctl_fan_properties_t.supportedUnits."]
    pub fn ctlFanSetSpeedTableMode(
        hFan: ctl_fan_handle_t,
        speedTable: *const ctl_fan_speed_table_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get current state of a fan - current mode and speed\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFan`\n     - CTL_RESULT_ERROR_INVALID_ENUMERATION\n         + `::CTL_FAN_SPEED_UNITS_PERCENT < units`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pSpeed`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_FEATURE\n         + The requested fan speed units are not supported. See ::ctl_fan_properties_t.supportedUnits."]
    pub fn ctlFanGetState(
        hFan: ctl_fan_handle_t,
        units: ctl_fan_speed_units_t,
        pSpeed: *mut i32,
    ) -> ctl_result_t;
}
#[doc = "< GPU Core Domain."]
pub const _ctl_freq_domain_t_CTL_FREQ_DOMAIN_GPU: _ctl_freq_domain_t = 0;
#[doc = "< Local Memory Domain."]
pub const _ctl_freq_domain_t_CTL_FREQ_DOMAIN_MEMORY: _ctl_freq_domain_t = 1;
pub const _ctl_freq_domain_t_CTL_FREQ_DOMAIN_MAX: _ctl_freq_domain_t = 2;
#[doc = "\n @brief Frequency domains."]
pub type _ctl_freq_domain_t = ::std::os::raw::c_int;
#[doc = "\n @brief Frequency domains."]
pub use self::_ctl_freq_domain_t as ctl_freq_domain_t;
#[doc = "\n @brief Frequency properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_freq_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The hardware block that this frequency domain controls (GPU,\n< memory, ...)"]
    pub type_: ctl_freq_domain_t,
    #[doc = "< [out] Indicates if software can control the frequency of this domain\n< assuming the user has permissions"]
    pub canControl: bool,
    #[doc = "< [out] The minimum hardware clock frequency in units of MHz."]
    pub min: f64,
    #[doc = "< [out] The maximum non-overclock hardware clock frequency in units of\n< MHz."]
    pub max: f64,
}
#[test]
fn bindgen_test_layout__ctl_freq_properties_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_freq_properties_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_freq_properties_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ctl_freq_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_freq_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_freq_properties_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_properties_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_properties_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_properties_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).canControl) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_properties_t),
            "::",
            stringify!(canControl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_properties_t),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_properties_t),
            "::",
            stringify!(max)
        )
    );
}
#[doc = "\n @brief Frequency range between which the hardware can operate. The limits can\n        be above or below the hardware limits - the hardware will clamp\n        appropriately."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_freq_range_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] The min frequency in MHz below which hardware frequency\n< management will not request frequencies. On input, setting to 0 will\n< permit the frequency to go down to the hardware minimum. On output, a\n< negative value indicates that no external minimum frequency limit is\n< in effect."]
    pub min: f64,
    #[doc = "< [in,out] The max frequency in MHz above which hardware frequency\n< management will not request frequencies. On input, setting to 0 or a\n< very big number will permit the frequency to go all the way up to the\n< hardware maximum. On output, a negative number indicates that no\n< external maximum frequency limit is in effect."]
    pub max: f64,
}
#[test]
fn bindgen_test_layout__ctl_freq_range_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_freq_range_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_freq_range_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_freq_range_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_freq_range_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_freq_range_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_range_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_range_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_range_t),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_range_t),
            "::",
            stringify!(max)
        )
    );
}
#[doc = "\n @brief Frequency throttle reasons"]
pub type ctl_freq_throttle_reason_flags_t = u32;
#[doc = "< frequency throttled due to average power excursion (PL1)"]
pub const _ctl_freq_throttle_reason_flag_t_CTL_FREQ_THROTTLE_REASON_FLAG_AVE_PWR_CAP:
    _ctl_freq_throttle_reason_flag_t = 1;
#[doc = "< frequency throttled due to burst power excursion (PL2)"]
pub const _ctl_freq_throttle_reason_flag_t_CTL_FREQ_THROTTLE_REASON_FLAG_BURST_PWR_CAP:
    _ctl_freq_throttle_reason_flag_t = 2;
#[doc = "< frequency throttled due to current excursion (PL4)"]
pub const _ctl_freq_throttle_reason_flag_t_CTL_FREQ_THROTTLE_REASON_FLAG_CURRENT_LIMIT:
    _ctl_freq_throttle_reason_flag_t = 4;
#[doc = "< frequency throttled due to thermal excursion (T > TjMax)"]
pub const _ctl_freq_throttle_reason_flag_t_CTL_FREQ_THROTTLE_REASON_FLAG_THERMAL_LIMIT:
    _ctl_freq_throttle_reason_flag_t = 8;
#[doc = "< frequency throttled due to power supply assertion"]
pub const _ctl_freq_throttle_reason_flag_t_CTL_FREQ_THROTTLE_REASON_FLAG_PSU_ALERT:
    _ctl_freq_throttle_reason_flag_t = 16;
#[doc = "< frequency throttled due to software supplied frequency range"]
pub const _ctl_freq_throttle_reason_flag_t_CTL_FREQ_THROTTLE_REASON_FLAG_SW_RANGE:
    _ctl_freq_throttle_reason_flag_t = 32;
#[doc = "< frequency throttled due to a sub block that has a lower frequency\n< range when it receives clocks"]
pub const _ctl_freq_throttle_reason_flag_t_CTL_FREQ_THROTTLE_REASON_FLAG_HW_RANGE:
    _ctl_freq_throttle_reason_flag_t = 64;
pub const _ctl_freq_throttle_reason_flag_t_CTL_FREQ_THROTTLE_REASON_FLAG_MAX:
    _ctl_freq_throttle_reason_flag_t = -2147483648;
pub type _ctl_freq_throttle_reason_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_freq_throttle_reason_flag_t as ctl_freq_throttle_reason_flag_t;
#[doc = "\n @brief Frequency state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_freq_state_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Current voltage in Volts. A negative value indicates that this\n< property is not known."]
    pub currentVoltage: f64,
    #[doc = "< [out] The current frequency request in MHz. A negative value indicates\n< that this property is not known."]
    pub request: f64,
    #[doc = "< [out] The maximum frequency in MHz supported under the current TDP\n< conditions. This fluctuates dynamically based on the power and thermal\n< limits of the part. A negative value indicates that this property is\n< not known."]
    pub tdp: f64,
    #[doc = "< [out] The efficient minimum frequency in MHz. A negative value\n< indicates that this property is not known."]
    pub efficient: f64,
    #[doc = "< [out] The resolved frequency in MHz. A negative value indicates that\n< this property is not known."]
    pub actual: f64,
    #[doc = "< [out] The reasons that the frequency is being limited by the hardware.\n< Returns 0 (frequency not throttled) or a combination of ::ctl_freq_throttle_reason_flag_t."]
    pub throttleReasons: ctl_freq_throttle_reason_flags_t,
}
#[test]
fn bindgen_test_layout__ctl_freq_state_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_freq_state_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_freq_state_t>(),
        56usize,
        concat!("Size of: ", stringify!(_ctl_freq_state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_freq_state_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_freq_state_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_state_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_state_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currentVoltage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_state_t),
            "::",
            stringify!(currentVoltage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_state_t),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tdp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_state_t),
            "::",
            stringify!(tdp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).efficient) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_state_t),
            "::",
            stringify!(efficient)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actual) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_state_t),
            "::",
            stringify!(actual)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).throttleReasons) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_state_t),
            "::",
            stringify!(throttleReasons)
        )
    );
}
#[doc = "\n @brief Frequency throttle time snapshot\n\n @details\n     - Percent time throttled is calculated by taking two snapshots (s1, s2)\n       and using the equation: %throttled = (s2.throttleTime -\n       s1.throttleTime) / (s2.timestamp - s1.timestamp)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_freq_throttle_time_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The monotonic counter of time in microseconds that the frequency\n< has been limited by the hardware."]
    pub throttleTime: u64,
    #[doc = "< [out] Microsecond timestamp when throttleTime was captured.\n< This timestamp should only be used to calculate delta time between\n< snapshots of this structure.\n< Never take the delta of this timestamp with the timestamp from a\n< different structure since they are not guaranteed to have the same base.\n< The absolute value of the timestamp is only valid during within the\n< application and may be different on the next execution."]
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout__ctl_freq_throttle_time_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_freq_throttle_time_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_freq_throttle_time_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_freq_throttle_time_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_freq_throttle_time_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_freq_throttle_time_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_throttle_time_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_throttle_time_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).throttleTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_throttle_time_t),
            "::",
            stringify!(throttleTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_freq_throttle_time_t),
            "::",
            stringify!(timestamp)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get handle of frequency domains\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`"]
    pub fn ctlEnumFrequencyDomains(
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phFrequency: *mut ctl_freq_handle_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get frequency properties - available frequencies\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFrequency`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`"]
    pub fn ctlFrequencyGetProperties(
        hFrequency: ctl_freq_handle_t,
        pProperties: *mut ctl_freq_properties_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get available non-overclocked hardware clock frequencies for the\n        frequency domain\n\n @details\n     - The list of available frequencies is returned in order of slowest to\n       fastest.\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFrequency`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`"]
    pub fn ctlFrequencyGetAvailableClocks(
        hFrequency: ctl_freq_handle_t,
        pCount: *mut u32,
        phFrequency: *mut f64,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get current frequency limits\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFrequency`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pLimits`"]
    pub fn ctlFrequencyGetRange(
        hFrequency: ctl_freq_handle_t,
        pLimits: *mut ctl_freq_range_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Set frequency range between which the hardware can operate.\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFrequency`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pLimits`\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS\n         + User does not have permissions to make these modifications."]
    pub fn ctlFrequencySetRange(
        hFrequency: ctl_freq_handle_t,
        pLimits: *const ctl_freq_range_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get current frequency state - frequency request, actual frequency, TDP\n        limits\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFrequency`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pState`"]
    pub fn ctlFrequencyGetState(
        hFrequency: ctl_freq_handle_t,
        pState: *mut ctl_freq_state_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get frequency throttle time\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hFrequency`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pThrottleTime`"]
    pub fn ctlFrequencyGetThrottleTime(
        hFrequency: ctl_freq_handle_t,
        pThrottleTime: *mut ctl_freq_throttle_time_t,
    ) -> ctl_result_t;
}
#[doc = "< Film mode detection.  Contains CTL_PROPERTY_VALUE_TYPE_BOOL ValueType."]
pub const _ctl_video_processing_feature_t_CTL_VIDEO_PROCESSING_FEATURE_FILM_MODE_DETECTION:
    _ctl_video_processing_feature_t = 0;
#[doc = "< Noise reduction.  Contains CTL_PROPERTY_VALUE_TYPE_CUSTOM type field\n< using struct ::ctl_video_processing_noise_reduction_t."]
pub const _ctl_video_processing_feature_t_CTL_VIDEO_PROCESSING_FEATURE_NOISE_REDUCTION:
    _ctl_video_processing_feature_t = 1;
#[doc = "< Sharpness.  Contains CTL_PROPERTY_VALUE_TYPE_UINT32 ValueType."]
pub const _ctl_video_processing_feature_t_CTL_VIDEO_PROCESSING_FEATURE_SHARPNESS:
    _ctl_video_processing_feature_t = 2;
#[doc = "< Adaptive contrast enhancement.  Contains\n< CTL_PROPERTY_VALUE_TYPE_CUSTOM type field using struct\n< ::ctl_video_processing_adaptive_contrast_enhancement_t."]
pub const _ctl_video_processing_feature_t_CTL_VIDEO_PROCESSING_FEATURE_ADAPTIVE_CONTRAST_ENHANCEMENT : _ctl_video_processing_feature_t = 3 ;
#[doc = "< Super resolution.  Contains CTL_PROPERTY_VALUE_TYPE_CUSTOM ValueType\n< using ::ctl_video_processing_super_resolution_t. By defaut, Super\n< resolution is not active, need application to activate it, please\n< contact Intel for super resolution activation."]
pub const _ctl_video_processing_feature_t_CTL_VIDEO_PROCESSING_FEATURE_SUPER_RESOLUTION:
    _ctl_video_processing_feature_t = 4;
#[doc = "< Standard color correction.  Controls Hue, Saturation, Contrast,\n< Brightness.  Contains CTL_PROPERTY_VALUE_TYPE_CUSTOM type field using\n< struct ::ctl_video_processing_standard_color_correction_t."]
pub const _ctl_video_processing_feature_t_CTL_VIDEO_PROCESSING_FEATURE_STANDARD_COLOR_CORRECTION:
    _ctl_video_processing_feature_t = 5;
#[doc = "< Total color correction.  Controls Red, Green, Blue, Yellow, Cyan,\n< Magenta.  Contains CTL_PROPERTY_VALUE_TYPE_CUSTOM type field using\n< struct ::ctl_video_processing_total_color_correction_t."]
pub const _ctl_video_processing_feature_t_CTL_VIDEO_PROCESSING_FEATURE_TOTAL_COLOR_CORRECTION:
    _ctl_video_processing_feature_t = 6;
#[doc = "< Skin tone enhancement.  Contains CTL_PROPERTY_VALUE_TYPE_UINT32\n< ValueType."]
pub const _ctl_video_processing_feature_t_CTL_VIDEO_PROCESSING_FEATURE_SKIN_TONE_ENHANCEMENT:
    _ctl_video_processing_feature_t = 7;
pub const _ctl_video_processing_feature_t_CTL_VIDEO_PROCESSING_FEATURE_MAX:
    _ctl_video_processing_feature_t = 8;
#[doc = "\n @brief Feature type"]
pub type _ctl_video_processing_feature_t = ::std::os::raw::c_int;
#[doc = "\n @brief Feature type"]
pub use self::_ctl_video_processing_feature_t as ctl_video_processing_feature_t;
#[doc = "\n @brief Super resolution values possible"]
pub type ctl_video_processing_super_resolution_flags_t = u32;
#[doc = "< Disable"]
pub const _ctl_video_processing_super_resolution_flag_t_CTL_VIDEO_PROCESSING_SUPER_RESOLUTION_FLAG_DISABLE : _ctl_video_processing_super_resolution_flag_t = 1 ;
#[doc = "< Enable with default super resolution mode"]
pub const _ctl_video_processing_super_resolution_flag_t_CTL_VIDEO_PROCESSING_SUPER_RESOLUTION_FLAG_ENABLE_DEFAULT_SCENARIO_MODE : _ctl_video_processing_super_resolution_flag_t = 2 ;
#[doc = "< Super resolution mode targeted at video conference content"]
pub const _ctl_video_processing_super_resolution_flag_t_CTL_VIDEO_PROCESSING_SUPER_RESOLUTION_FLAG_ENABLE_CONFERENCE_SCENARIO_MODE : _ctl_video_processing_super_resolution_flag_t = 4 ;
#[doc = "< Super resolution mode targeted at camera capture content (e.g.\n< security camera)"]
pub const _ctl_video_processing_super_resolution_flag_t_CTL_VIDEO_PROCESSING_SUPER_RESOLUTION_FLAG_ENABLE_CAMERA_SCENARIO_MODE : _ctl_video_processing_super_resolution_flag_t = 8 ;
pub const _ctl_video_processing_super_resolution_flag_t_CTL_VIDEO_PROCESSING_SUPER_RESOLUTION_FLAG_MAX : _ctl_video_processing_super_resolution_flag_t = - 2147483648 ;
pub type _ctl_video_processing_super_resolution_flag_t = ::std::os::raw::c_int;
pub use self::_ctl_video_processing_super_resolution_flag_t as ctl_video_processing_super_resolution_flag_t;
#[doc = "\n @brief Super Resolution feature details structure to be used with\n        SUPER_RESOLUTION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_video_processing_super_resolution_info_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] SUPER_RESOLUTION flag"]
    pub super_resolution_flag: ctl_video_processing_super_resolution_flags_t,
    #[doc = "< [in,out] The range of input width information(min, max, default and\n< step size)which super resolution is capable of supporting."]
    pub super_resolution_range_in_width: ctl_property_info_uint_t,
    #[doc = "< [in,out] The range of input height information(min, max, default and\n< step size)which super resolution is capable of supporting."]
    pub super_resolution_range_in_height: ctl_property_info_uint_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[test]
fn bindgen_test_layout__ctl_video_processing_super_resolution_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_video_processing_super_resolution_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_video_processing_super_resolution_info_t>(),
        116usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_video_processing_super_resolution_info_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_video_processing_super_resolution_info_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_video_processing_super_resolution_info_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_super_resolution_info_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_super_resolution_info_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).super_resolution_flag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_super_resolution_info_t),
            "::",
            stringify!(super_resolution_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).super_resolution_range_in_width) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_super_resolution_info_t),
            "::",
            stringify!(super_resolution_range_in_width)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).super_resolution_range_in_height) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_super_resolution_info_t),
            "::",
            stringify!(super_resolution_range_in_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_super_resolution_info_t),
            "::",
            stringify!(ReservedFields)
        )
    );
}
#[doc = "\n @brief Super Resolution Get/Set structure to be used with SUPER_RESOLUTION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_video_processing_super_resolution_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] SUPER_RESOLUTION flag"]
    pub super_resolution_flag: ctl_video_processing_super_resolution_flags_t,
    #[doc = "< [in,out] The enabling of maximum input width and height limition. If\n< enabled, super resolution will always take effect if the input\n< resolution is smaller than the below specified max resolution;\n< otherwise, super_resolution_max_in_width and\n< super_resolution_max_in_height will be ignored"]
    pub super_resolution_max_in_enabled: bool,
    #[doc = "< [in,out] The maximum input width limition value setting which super\n< resolution will be allowed to enabled."]
    pub super_resolution_max_in_width: u32,
    #[doc = "< [in,out] The maximum input height limiation value setting which super\n< resolution will be allowed to enabled."]
    pub super_resolution_max_in_height: u32,
    #[doc = "< [in,out] Resetting of super resolution after rebooting."]
    pub super_resolution_reboot_reset: bool,
    #[doc = "< [out] Reserved field of 60 bytes"]
    pub ReservedFields: [u32; 15usize],
    #[doc = "< [out] Reserved field of 3 bytes"]
    pub ReservedBytes: [::std::os::raw::c_char; 3usize],
}
#[test]
fn bindgen_test_layout__ctl_video_processing_super_resolution_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_video_processing_super_resolution_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_video_processing_super_resolution_t>(),
        92usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_video_processing_super_resolution_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_video_processing_super_resolution_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_video_processing_super_resolution_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_super_resolution_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_super_resolution_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).super_resolution_flag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_super_resolution_t),
            "::",
            stringify!(super_resolution_flag)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).super_resolution_max_in_enabled) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_super_resolution_t),
            "::",
            stringify!(super_resolution_max_in_enabled)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).super_resolution_max_in_width) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_super_resolution_t),
            "::",
            stringify!(super_resolution_max_in_width)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).super_resolution_max_in_height) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_super_resolution_t),
            "::",
            stringify!(super_resolution_max_in_height)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).super_resolution_reboot_reset) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_super_resolution_t),
            "::",
            stringify!(super_resolution_reboot_reset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_super_resolution_t),
            "::",
            stringify!(ReservedFields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedBytes) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_super_resolution_t),
            "::",
            stringify!(ReservedBytes)
        )
    );
}
#[doc = "\n @brief Noise Reduction feature details structure to be used with\n        NOISE_REDUCTION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_video_processing_noise_reduction_info_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Noise reduction min, max, default and step size information"]
    pub noise_reduction: ctl_property_info_uint_t,
    #[doc = "< [in,out] Noise reduction Auto Detect is supported; only valid if\n< NOISE_REDUCTION is enabled.  If enabled, noise reduction level is\n< automatically determined and set value is not used."]
    pub noise_reduction_auto_detect_supported: bool,
    #[doc = "< [in,out] Noise reduction auto detect default information"]
    pub noise_reduction_auto_detect: ctl_property_info_boolean_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[test]
fn bindgen_test_layout__ctl_video_processing_noise_reduction_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_video_processing_noise_reduction_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_video_processing_noise_reduction_info_t>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_video_processing_noise_reduction_info_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_video_processing_noise_reduction_info_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_video_processing_noise_reduction_info_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_noise_reduction_info_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_noise_reduction_info_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noise_reduction) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_noise_reduction_info_t),
            "::",
            stringify!(noise_reduction)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).noise_reduction_auto_detect_supported) as usize
                - ptr as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_noise_reduction_info_t),
            "::",
            stringify!(noise_reduction_auto_detect_supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noise_reduction_auto_detect) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_noise_reduction_info_t),
            "::",
            stringify!(noise_reduction_auto_detect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_noise_reduction_info_t),
            "::",
            stringify!(ReservedFields)
        )
    );
}
#[doc = "\n @brief Noise Reduction Get/Set structure to be used with NOISE_REDUCTION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_video_processing_noise_reduction_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Noise reduction enable and value setting"]
    pub noise_reduction: ctl_property_uint_t,
    #[doc = "< [in,out] Noise reduction auto detect setting"]
    pub noise_reduction_auto_detect: ctl_property_boolean_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[test]
fn bindgen_test_layout__ctl_video_processing_noise_reduction_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_video_processing_noise_reduction_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_video_processing_noise_reduction_t>(),
        84usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_video_processing_noise_reduction_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_video_processing_noise_reduction_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_video_processing_noise_reduction_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_noise_reduction_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_noise_reduction_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noise_reduction) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_noise_reduction_t),
            "::",
            stringify!(noise_reduction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noise_reduction_auto_detect) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_noise_reduction_t),
            "::",
            stringify!(noise_reduction_auto_detect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_noise_reduction_t),
            "::",
            stringify!(ReservedFields)
        )
    );
}
#[doc = "\n @brief Adaptive Contrast Enhancement feature details structure to be used\n        with ADAPTIVE_CONTRAST_ENHANCEMENT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_video_processing_adaptive_contrast_enhancement_info_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Adaptive Contrast Enhancement min, max, default and step size\n< information"]
    pub adaptive_contrast_enhancement: ctl_property_info_uint_t,
    #[doc = "< [in,out] Adaptive contrast enhancement coexistance is supported; only\n< valid if ADAPTIVE_CONTRAST_ENHANCEMENT is enabled.  If enabled, Video\n< adaptive contrast ehancement will be allowed to be enabled and coexist\n< with Display adaptive contrast ehancement feature."]
    pub adaptive_contrast_enhancement_coexistence_supported: bool,
    #[doc = "< [in,out] Adaptive contrast enhancement coexistence default information"]
    pub adaptive_contrast_enhancement_coexistence: ctl_property_info_boolean_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[test]
fn bindgen_test_layout__ctl_video_processing_adaptive_contrast_enhancement_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<
        _ctl_video_processing_adaptive_contrast_enhancement_info_t,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_video_processing_adaptive_contrast_enhancement_info_t>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_video_processing_adaptive_contrast_enhancement_info_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_video_processing_adaptive_contrast_enhancement_info_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_video_processing_adaptive_contrast_enhancement_info_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_adaptive_contrast_enhancement_info_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_adaptive_contrast_enhancement_info_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).adaptive_contrast_enhancement) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_adaptive_contrast_enhancement_info_t),
            "::",
            stringify!(adaptive_contrast_enhancement)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).adaptive_contrast_enhancement_coexistence_supported)
                as usize
                - ptr as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_adaptive_contrast_enhancement_info_t),
            "::",
            stringify!(adaptive_contrast_enhancement_coexistence_supported)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).adaptive_contrast_enhancement_coexistence) as usize
                - ptr as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_adaptive_contrast_enhancement_info_t),
            "::",
            stringify!(adaptive_contrast_enhancement_coexistence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_adaptive_contrast_enhancement_info_t),
            "::",
            stringify!(ReservedFields)
        )
    );
}
#[doc = "\n @brief Adaptive Contrast Enhancement Get/Set structure to be used with\n        ADAPTIVE_CONTRAST_ENHANCEMENT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_video_processing_adaptive_contrast_enhancement_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Adaptive Contrast Enhancement enable and value setting"]
    pub adaptive_contrast_enhancement: ctl_property_uint_t,
    #[doc = "< [in,out] Adaptive contrast enhancement coexistance setting"]
    pub adaptive_contrast_enhancement_coexistence: ctl_property_boolean_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[test]
fn bindgen_test_layout__ctl_video_processing_adaptive_contrast_enhancement_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_video_processing_adaptive_contrast_enhancement_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_video_processing_adaptive_contrast_enhancement_t>(),
        84usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_video_processing_adaptive_contrast_enhancement_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_video_processing_adaptive_contrast_enhancement_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_video_processing_adaptive_contrast_enhancement_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_adaptive_contrast_enhancement_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_adaptive_contrast_enhancement_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).adaptive_contrast_enhancement) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_adaptive_contrast_enhancement_t),
            "::",
            stringify!(adaptive_contrast_enhancement)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).adaptive_contrast_enhancement_coexistence) as usize
                - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_adaptive_contrast_enhancement_t),
            "::",
            stringify!(adaptive_contrast_enhancement_coexistence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_adaptive_contrast_enhancement_t),
            "::",
            stringify!(ReservedFields)
        )
    );
}
#[doc = "\n @brief Standard Color Correction feature details structure to be used with\n        STANDARD_COLOR_CORRECTION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_video_processing_standard_color_correction_info_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] STANDARD_COLOR_CORRECTION default enable setting.  This\n< global settings controls all of Hue, Saturation, Contrast, Brightness\n< enabling.  Individual Enable controls shall be ignored."]
    pub standard_color_correction_default_enable: bool,
    #[doc = "< [in,out] Brightness min, max, default and step size information"]
    pub brightness: ctl_property_info_float_t,
    #[doc = "< [in,out] Contrast min, max, default and step size information"]
    pub contrast: ctl_property_info_float_t,
    #[doc = "< [in,out] Hue min, max, default and step size information"]
    pub hue: ctl_property_info_float_t,
    #[doc = "< [in,out] Saturation min, max, default and step size information"]
    pub saturation: ctl_property_info_float_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[test]
fn bindgen_test_layout__ctl_video_processing_standard_color_correction_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_video_processing_standard_color_correction_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_video_processing_standard_color_correction_info_t>(),
        152usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_video_processing_standard_color_correction_info_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_video_processing_standard_color_correction_info_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_video_processing_standard_color_correction_info_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_standard_color_correction_info_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_standard_color_correction_info_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).standard_color_correction_default_enable) as usize
                - ptr as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_standard_color_correction_info_t),
            "::",
            stringify!(standard_color_correction_default_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).brightness) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_standard_color_correction_info_t),
            "::",
            stringify!(brightness)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contrast) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_standard_color_correction_info_t),
            "::",
            stringify!(contrast)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hue) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_standard_color_correction_info_t),
            "::",
            stringify!(hue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).saturation) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_standard_color_correction_info_t),
            "::",
            stringify!(saturation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_standard_color_correction_info_t),
            "::",
            stringify!(ReservedFields)
        )
    );
}
#[doc = "\n @brief Standard Color Correction Get/Set structure to be used with\n        STANDARD_COLOR_CORRECTION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_video_processing_standard_color_correction_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] STANDARD_COLOR_CORRECTION enable setting.  This global\n< setting controls all of Hue, Saturation, Contrast, Brightness\n< enabling."]
    pub standard_color_correction_enable: bool,
    #[doc = "< [in,out] Brightness value"]
    pub brightness: f32,
    #[doc = "< [in,out] Contrast value"]
    pub contrast: f32,
    #[doc = "< [in,out] Hue value"]
    pub hue: f32,
    #[doc = "< [in,out] Saturation value"]
    pub saturation: f32,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[test]
fn bindgen_test_layout__ctl_video_processing_standard_color_correction_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_video_processing_standard_color_correction_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_video_processing_standard_color_correction_t>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_video_processing_standard_color_correction_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_video_processing_standard_color_correction_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_video_processing_standard_color_correction_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_standard_color_correction_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_standard_color_correction_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).standard_color_correction_enable) as usize - ptr as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_standard_color_correction_t),
            "::",
            stringify!(standard_color_correction_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).brightness) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_standard_color_correction_t),
            "::",
            stringify!(brightness)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contrast) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_standard_color_correction_t),
            "::",
            stringify!(contrast)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hue) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_standard_color_correction_t),
            "::",
            stringify!(hue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).saturation) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_standard_color_correction_t),
            "::",
            stringify!(saturation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_standard_color_correction_t),
            "::",
            stringify!(ReservedFields)
        )
    );
}
#[doc = "\n @brief Total Color Correction Get/Set structure to be used with\n        TOTAL_COLOR_CORRECTION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_video_processing_total_color_correction_info_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] TOTAL_COLOR_CORRECTION enable setting.  This global setting\n< controls all of Red, Green, Blue, Yellow, Cyan, Magenta enabling.\n< Individual Enable controls shall be ignored."]
    pub total_color_correction_default_enable: bool,
    #[doc = "< [in,out] Red min, max, default and step size information"]
    pub red: ctl_property_info_uint_t,
    #[doc = "< [in,out] Green min, max, default and step size information"]
    pub green: ctl_property_info_uint_t,
    #[doc = "< [in,out] Blue min, max, default and step size information"]
    pub blue: ctl_property_info_uint_t,
    #[doc = "< [in,out] Yellow min, max, default and step size information"]
    pub yellow: ctl_property_info_uint_t,
    #[doc = "< [in,out] Cyan min, max, default and step size information"]
    pub cyan: ctl_property_info_uint_t,
    #[doc = "< [in,out] Magenta min, max, default and step size information"]
    pub magenta: ctl_property_info_uint_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[test]
fn bindgen_test_layout__ctl_video_processing_total_color_correction_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_video_processing_total_color_correction_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_video_processing_total_color_correction_info_t>(),
        192usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_video_processing_total_color_correction_info_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_video_processing_total_color_correction_info_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_video_processing_total_color_correction_info_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_info_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_info_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).total_color_correction_default_enable) as usize
                - ptr as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_info_t),
            "::",
            stringify!(total_color_correction_default_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_info_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_info_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_info_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yellow) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_info_t),
            "::",
            stringify!(yellow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cyan) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_info_t),
            "::",
            stringify!(cyan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magenta) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_info_t),
            "::",
            stringify!(magenta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_info_t),
            "::",
            stringify!(ReservedFields)
        )
    );
}
#[doc = "\n @brief Total Color Correction Get/Set structure to be used with\n        TOTAL_COLOR_CORRECTION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_video_processing_total_color_correction_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] TOTAL_COLOR_CORRECTION enable setting.  This global setting\n< controls all of Red, Green, Blue, Yellow, Cyan, Magenta enabling."]
    pub total_color_correction_enable: bool,
    #[doc = "< [in,out] Red value"]
    pub red: u32,
    #[doc = "< [in,out] Green value"]
    pub green: u32,
    #[doc = "< [in,out] Blue value"]
    pub blue: u32,
    #[doc = "< [in,out] Yellow value"]
    pub yellow: u32,
    #[doc = "< [in,out] Cyan value"]
    pub cyan: u32,
    #[doc = "< [in,out] Magenta value"]
    pub magenta: u32,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[test]
fn bindgen_test_layout__ctl_video_processing_total_color_correction_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_video_processing_total_color_correction_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_video_processing_total_color_correction_t>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_video_processing_total_color_correction_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_video_processing_total_color_correction_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_video_processing_total_color_correction_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).total_color_correction_enable) as usize - ptr as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_t),
            "::",
            stringify!(total_color_correction_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yellow) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_t),
            "::",
            stringify!(yellow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cyan) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_t),
            "::",
            stringify!(cyan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magenta) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_t),
            "::",
            stringify!(magenta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_total_color_correction_t),
            "::",
            stringify!(ReservedFields)
        )
    );
}
#[doc = "\n @brief Video Processing feature details which will have range supported and\n        default values"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_video_processing_feature_details_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Video processing feature type"]
    pub FeatureType: ctl_video_processing_feature_t,
    #[doc = "< [out] Type of value"]
    pub ValueType: ctl_property_value_type_t,
    #[doc = "< [out] Union of various type of values for Video Processing features.\n< For enum types this can be noise reduction, color control etc. This\n< member is valid iff ValueType is not CTL_PROPERTY_VALUE_TYPE_CUSTOM"]
    pub Value: ctl_property_info_t,
    #[doc = "< [in] CustomValue buffer size"]
    pub CustomValueSize: i32,
    #[doc = "< [in,out] Pointer to a custom structure. Features that use CustomType,\n< after the first query for all of the supported features the user needs\n< to allocate this buffer and then query again just this specific\n< feature for the structure to be filled in. Caller should allocate this\n< buffer with known custom feature structure size. This member is valid\n< iff ValueType is CTL_PROPERTY_VALUE_TYPE_CUSTOM."]
    pub pCustomValue: *mut ::std::os::raw::c_void,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[test]
fn bindgen_test_layout__ctl_video_processing_feature_details_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_video_processing_feature_details_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_video_processing_feature_details_t>(),
        120usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_video_processing_feature_details_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_video_processing_feature_details_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_video_processing_feature_details_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_details_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_details_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FeatureType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_details_t),
            "::",
            stringify!(FeatureType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValueType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_details_t),
            "::",
            stringify!(ValueType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_details_t),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CustomValueSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_details_t),
            "::",
            stringify!(CustomValueSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCustomValue) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_details_t),
            "::",
            stringify!(pCustomValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_details_t),
            "::",
            stringify!(ReservedFields)
        )
    );
}
#[doc = "\n @brief Video Processing features which are controllable"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_video_processing_feature_caps_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Number of elements in supported features array"]
    pub NumSupportedFeatures: u32,
    #[doc = "< [in,out] Array of supported features and their details"]
    pub pFeatureDetails: *mut ctl_video_processing_feature_details_t,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[test]
fn bindgen_test_layout__ctl_video_processing_feature_caps_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_video_processing_feature_caps_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_video_processing_feature_caps_t>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_video_processing_feature_caps_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_video_processing_feature_caps_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_video_processing_feature_caps_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_caps_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_caps_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumSupportedFeatures) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_caps_t),
            "::",
            stringify!(NumSupportedFeatures)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pFeatureDetails) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_caps_t),
            "::",
            stringify!(pFeatureDetails)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_caps_t),
            "::",
            stringify!(ReservedFields)
        )
    );
}
#[doc = "\n @brief Video Processing feature for get/set"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_video_processing_feature_getset_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in] Features interested in"]
    pub FeatureType: ctl_video_processing_feature_t,
    #[doc = "< [in] Application name for which the property type is applicable. If\n< this is an empty string then this will get/set global settings for the\n< given adapter. Note that this should contain only the name of the\n< application and not the system specific path.  [This is not currently\n< supported and should be an empty string.]"]
    pub ApplicationName: *mut ::std::os::raw::c_char,
    #[doc = "< [in] Length of ApplicationName string"]
    pub ApplicationNameLength: i8,
    #[doc = "< [in] Set this if it's a set call"]
    pub bSet: bool,
    #[doc = "< [in] Type of value. Caller has to ensure it provides the right value\n< type which decides how one read the union structure below"]
    pub ValueType: ctl_property_value_type_t,
    #[doc = "< [in,out] Union of various type of values for Video Processing\n< features. For enum types this can be noise reduction, color control\n< etc. This member is valid iff ValueType is not\n< CTL_PROPERTY_VALUE_TYPE_CUSTOM"]
    pub Value: ctl_property_t,
    #[doc = "< [in] CustomValue buffer size.  For a feature requiring custom struct,\n< caller will know of it upfront the struct to use based on the feautre\n< and can provide the right size info here"]
    pub CustomValueSize: i32,
    #[doc = "< [in,out] Pointer to a custom structure. Caller should allocate this\n< buffer with known custom feature structure size. This member is valid\n< iff ValueType is CTL_PROPERTY_VALUE_TYPE_CUSTOM"]
    pub pCustomValue: *mut ::std::os::raw::c_void,
    #[doc = "< [out] Reserved field of 64 bytes"]
    pub ReservedFields: [u32; 16usize],
}
#[test]
fn bindgen_test_layout__ctl_video_processing_feature_getset_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_video_processing_feature_getset_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_video_processing_feature_getset_t>(),
        120usize,
        concat!(
            "Size of: ",
            stringify!(_ctl_video_processing_feature_getset_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_video_processing_feature_getset_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ctl_video_processing_feature_getset_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_getset_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_getset_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FeatureType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_getset_t),
            "::",
            stringify!(FeatureType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApplicationName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_getset_t),
            "::",
            stringify!(ApplicationName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ApplicationNameLength) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_getset_t),
            "::",
            stringify!(ApplicationNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bSet) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_getset_t),
            "::",
            stringify!(bSet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValueType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_getset_t),
            "::",
            stringify!(ValueType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_getset_t),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CustomValueSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_getset_t),
            "::",
            stringify!(CustomValueSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCustomValue) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_getset_t),
            "::",
            stringify!(pCustomValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReservedFields) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_video_processing_feature_getset_t),
            "::",
            stringify!(ReservedFields)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get Video Processing capabilities\n\n @details\n     - The application gets Video Processing properties\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pFeatureCaps`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetSupportedVideoProcessingCapabilities(
        hDAhandle: ctl_device_adapter_handle_t,
        pFeatureCaps: *mut ctl_video_processing_feature_caps_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get/Set Video Processing feature details\n\n @details\n     - Video Processing feature details\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pFeature`\n     - ::CTL_RESULT_ERROR_UNSUPPORTED_VERSION - \"Unsupported version\""]
    pub fn ctlGetSetVideoProcessingFeature(
        hDAhandle: ctl_device_adapter_handle_t,
        pFeature: *mut ctl_video_processing_feature_getset_t,
    ) -> ctl_result_t;
}
#[doc = "< HBM memory"]
pub const _ctl_mem_type_t_CTL_MEM_TYPE_HBM: _ctl_mem_type_t = 0;
#[doc = "< DDR memory"]
pub const _ctl_mem_type_t_CTL_MEM_TYPE_DDR: _ctl_mem_type_t = 1;
#[doc = "< DDR3 memory"]
pub const _ctl_mem_type_t_CTL_MEM_TYPE_DDR3: _ctl_mem_type_t = 2;
#[doc = "< DDR4 memory"]
pub const _ctl_mem_type_t_CTL_MEM_TYPE_DDR4: _ctl_mem_type_t = 3;
#[doc = "< DDR5 memory"]
pub const _ctl_mem_type_t_CTL_MEM_TYPE_DDR5: _ctl_mem_type_t = 4;
#[doc = "< LPDDR memory"]
pub const _ctl_mem_type_t_CTL_MEM_TYPE_LPDDR: _ctl_mem_type_t = 5;
#[doc = "< LPDDR3 memory"]
pub const _ctl_mem_type_t_CTL_MEM_TYPE_LPDDR3: _ctl_mem_type_t = 6;
#[doc = "< LPDDR4 memory"]
pub const _ctl_mem_type_t_CTL_MEM_TYPE_LPDDR4: _ctl_mem_type_t = 7;
#[doc = "< LPDDR5 memory"]
pub const _ctl_mem_type_t_CTL_MEM_TYPE_LPDDR5: _ctl_mem_type_t = 8;
#[doc = "< GDDR4 memory"]
pub const _ctl_mem_type_t_CTL_MEM_TYPE_GDDR4: _ctl_mem_type_t = 9;
#[doc = "< GDDR5 memory"]
pub const _ctl_mem_type_t_CTL_MEM_TYPE_GDDR5: _ctl_mem_type_t = 10;
#[doc = "< GDDR5X memory"]
pub const _ctl_mem_type_t_CTL_MEM_TYPE_GDDR5X: _ctl_mem_type_t = 11;
#[doc = "< GDDR6 memory"]
pub const _ctl_mem_type_t_CTL_MEM_TYPE_GDDR6: _ctl_mem_type_t = 12;
#[doc = "< GDDR6X memory"]
pub const _ctl_mem_type_t_CTL_MEM_TYPE_GDDR6X: _ctl_mem_type_t = 13;
#[doc = "< GDDR7 memory"]
pub const _ctl_mem_type_t_CTL_MEM_TYPE_GDDR7: _ctl_mem_type_t = 14;
#[doc = "< UNKNOWN memory"]
pub const _ctl_mem_type_t_CTL_MEM_TYPE_UNKNOWN: _ctl_mem_type_t = 15;
pub const _ctl_mem_type_t_CTL_MEM_TYPE_MAX: _ctl_mem_type_t = 16;
#[doc = "\n @brief Memory module types"]
pub type _ctl_mem_type_t = ::std::os::raw::c_int;
#[doc = "\n @brief Memory module types"]
pub use self::_ctl_mem_type_t as ctl_mem_type_t;
#[doc = "< System memory"]
pub const _ctl_mem_loc_t_CTL_MEM_LOC_SYSTEM: _ctl_mem_loc_t = 0;
#[doc = "< On board local device memory"]
pub const _ctl_mem_loc_t_CTL_MEM_LOC_DEVICE: _ctl_mem_loc_t = 1;
pub const _ctl_mem_loc_t_CTL_MEM_LOC_MAX: _ctl_mem_loc_t = 2;
#[doc = "\n @brief Memory module location"]
pub type _ctl_mem_loc_t = ::std::os::raw::c_int;
#[doc = "\n @brief Memory module location"]
pub use self::_ctl_mem_loc_t as ctl_mem_loc_t;
#[doc = "\n @brief Memory properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_mem_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The memory type"]
    pub type_: ctl_mem_type_t,
    #[doc = "< [out] Location of this memory (system, device)"]
    pub location: ctl_mem_loc_t,
    #[doc = "< [out] Physical memory size in bytes. A value of 0 indicates that this\n< property is not known. However, a call to ::ctlMemoryGetState() will\n< correctly return the total size of usable memory."]
    pub physicalSize: u64,
    #[doc = "< [out] Width of the memory bus. A value of -1 means that this property\n< is unknown."]
    pub busWidth: i32,
    #[doc = "< [out] The number of memory channels. A value of -1 means that this\n< property is unknown."]
    pub numChannels: i32,
}
#[test]
fn bindgen_test_layout__ctl_mem_properties_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_mem_properties_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_mem_properties_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ctl_mem_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_mem_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_mem_properties_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mem_properties_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mem_properties_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mem_properties_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mem_properties_t),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).physicalSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mem_properties_t),
            "::",
            stringify!(physicalSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).busWidth) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mem_properties_t),
            "::",
            stringify!(busWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numChannels) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mem_properties_t),
            "::",
            stringify!(numChannels)
        )
    );
}
#[doc = "\n @brief Memory state - health, allocated\n\n @details\n     - Percent allocation is given by 100 * (size - free / size.\n     - Percent free is given by 100 * free / size."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_mem_state_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The free memory in bytes"]
    pub free: u64,
    #[doc = "< [out] The total allocatable memory in bytes (can be less than\n< ::ctl_mem_properties_t.physicalSize)"]
    pub size: u64,
}
#[test]
fn bindgen_test_layout__ctl_mem_state_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_mem_state_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_mem_state_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_mem_state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_mem_state_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_mem_state_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mem_state_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mem_state_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mem_state_t),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mem_state_t),
            "::",
            stringify!(size)
        )
    );
}
#[doc = "\n @brief Memory bandwidth\n\n @details\n     - Percent bandwidth is calculated by taking two snapshots (s1, s2) and\n       using the equation: %bw = 10^6 * ((s2.readCounter - s1.readCounter) +\n       (s2.writeCounter - s1.writeCounter)) / (s2.maxBandwidth *\n       (s2.timestamp - s1.timestamp))"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_mem_bandwidth_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Current maximum bandwidth in units of bytes/sec"]
    pub maxBandwidth: u64,
    #[doc = "< [out] The timestamp (in microseconds) when these measurements were sampled.\n< This timestamp should only be used to calculate delta time between\n< snapshots of this structure.\n< Never take the delta of this timestamp with the timestamp from a\n< different structure since they are not guaranteed to have the same base.\n< The absolute value of the timestamp is only valid during within the\n< application and may be different on the next execution."]
    pub timestamp: u64,
    #[doc = "< [out] Total bytes read from memory. Supported only for Version > 0"]
    pub readCounter: u64,
    #[doc = "< [out] Total bytes written to memory. Supported only for Version > 0"]
    pub writeCounter: u64,
}
#[test]
fn bindgen_test_layout__ctl_mem_bandwidth_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_mem_bandwidth_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_mem_bandwidth_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ctl_mem_bandwidth_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_mem_bandwidth_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_mem_bandwidth_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mem_bandwidth_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mem_bandwidth_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxBandwidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mem_bandwidth_t),
            "::",
            stringify!(maxBandwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mem_bandwidth_t),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readCounter) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mem_bandwidth_t),
            "::",
            stringify!(readCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writeCounter) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_mem_bandwidth_t),
            "::",
            stringify!(writeCounter)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get handle of memory modules\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`"]
    pub fn ctlEnumMemoryModules(
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phMemory: *mut ctl_mem_handle_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get memory properties\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hMemory`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`"]
    pub fn ctlMemoryGetProperties(
        hMemory: ctl_mem_handle_t,
        pProperties: *mut ctl_mem_properties_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get memory state - health, allocated\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hMemory`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pState`"]
    pub fn ctlMemoryGetState(
        hMemory: ctl_mem_handle_t,
        pState: *mut ctl_mem_state_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get memory bandwidth\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hMemory`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pBandwidth`\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS\n         + User does not have permissions to query this telemetry."]
    pub fn ctlMemoryGetBandwidth(
        hMemory: ctl_mem_handle_t,
        pBandwidth: *mut ctl_mem_bandwidth_t,
    ) -> ctl_result_t;
}
#[doc = "\n @brief Telemetry Item for each telemetry property\n\n @details\n     - If the supported field is true, then the entire structure has valid\n       information.\n     - The ::ctl_data_value_t is of type ::ctl_data_type_t and units\n       ::ctl_units_t"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_oc_telemetry_item_t {
    #[doc = "< [out] Indicates if the value is supported."]
    pub bSupported: bool,
    #[doc = "< [out] Indicates the units of the value."]
    pub units: ctl_units_t,
    #[doc = "< [out] Indicates the data type."]
    pub type_: ctl_data_type_t,
    #[doc = "< [out] The value of type ::ctl_data_type_t and units ::ctl_units_t."]
    pub value: ctl_data_value_t,
}
#[test]
fn bindgen_test_layout__ctl_oc_telemetry_item_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_oc_telemetry_item_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_oc_telemetry_item_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_oc_telemetry_item_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_oc_telemetry_item_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_oc_telemetry_item_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bSupported) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_telemetry_item_t),
            "::",
            stringify!(bSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).units) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_telemetry_item_t),
            "::",
            stringify!(units)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_telemetry_item_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_telemetry_item_t),
            "::",
            stringify!(value)
        )
    );
}
#[doc = "\n @brief Overclocking Control Information\n\n @details\n     - Whether the device supports overclocking.\n     - The\n       bSupported/bRelative/bReference/units/min/max/step/default/reference\n       values for the available overclock controls\n     - The idea is to facilitate the way the applications present overclock\n       settings to the user. If bSupported is false, the corresponding\n       overclock control is not supported\n     - The setting units will be an enum that enables the application to know\n       the units for the control setting e.g. MHz. The min and max settings\n       give the limits for the control.\n     - The step setting gives the minimum change in the control value (plus\n       or minus) - if a control is not changed by at least this amount, the\n       hardware may round up or down.\n     - The default values gives the manufacturing setting for the control.\n       Some controls such as frequency offset and voltage offset are\n       relative; in this case, bRelative will be true, otherwise the control\n       settings are absolute values.\n     - For relative controls and if bReference is true, the reference value\n       gives the absolute value at the default setting.\n     - If bReference is false, the absolute value of the default setting is\n       no not known and it is probably better to display the setting to users\n       as percentage offsets."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_oc_control_info_t {
    #[doc = "< [out] Indicates if the values are known."]
    pub bSupported: bool,
    #[doc = "< [out] Indicates if the values are meant to be taken as relative values\n< instead of absolut values."]
    pub bRelative: bool,
    #[doc = "< [out] For relative values, this indicates if a reference is available."]
    pub bReference: bool,
    #[doc = "< [out] Units for the values."]
    pub units: ctl_units_t,
    #[doc = "< [out] Minimum Value."]
    pub min: f64,
    #[doc = "< [out] Maximum Value."]
    pub max: f64,
    #[doc = "< [out] Step Value."]
    pub step: f64,
    #[doc = "< [out] Default Value."]
    pub Default: f64,
    #[doc = "< [out] Reference Value if the bReference is true."]
    pub reference: f64,
}
#[test]
fn bindgen_test_layout__ctl_oc_control_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_oc_control_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_oc_control_info_t>(),
        48usize,
        concat!("Size of: ", stringify!(_ctl_oc_control_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_oc_control_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_oc_control_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bSupported) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_control_info_t),
            "::",
            stringify!(bSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bRelative) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_control_info_t),
            "::",
            stringify!(bRelative)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bReference) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_control_info_t),
            "::",
            stringify!(bReference)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).units) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_control_info_t),
            "::",
            stringify!(units)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_control_info_t),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_control_info_t),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_control_info_t),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Default) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_control_info_t),
            "::",
            stringify!(Default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reference) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_control_info_t),
            "::",
            stringify!(reference)
        )
    );
}
#[doc = "\n @brief Overclock properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_oc_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Indicates if the adapter supports overclocking."]
    pub bSupported: bool,
    #[doc = "< [out] related to function ::ctlOverclockGpuFrequencyOffsetSet"]
    pub gpuFrequencyOffset: ctl_oc_control_info_t,
    #[doc = "< [out] related to function ::ctlOverclockGpuVoltageOffsetSet"]
    pub gpuVoltageOffset: ctl_oc_control_info_t,
    #[doc = "< [out] related to function ::ctlOverclockVramFrequencyOffsetSet"]
    pub vramFrequencyOffset: ctl_oc_control_info_t,
    #[doc = "< [out] related to function ::ctlOverclockVramVoltageOffsetSet"]
    pub vramVoltageOffset: ctl_oc_control_info_t,
    #[doc = "< [out] related to function ::ctlOverclockPowerLimitSet"]
    pub powerLimit: ctl_oc_control_info_t,
    #[doc = "< [out] related to function ::ctlOverclockTemperatureLimitSet"]
    pub temperatureLimit: ctl_oc_control_info_t,
}
#[test]
fn bindgen_test_layout__ctl_oc_properties_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_oc_properties_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_oc_properties_t>(),
        296usize,
        concat!("Size of: ", stringify!(_ctl_oc_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_oc_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_oc_properties_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_properties_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_properties_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bSupported) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_properties_t),
            "::",
            stringify!(bSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuFrequencyOffset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_properties_t),
            "::",
            stringify!(gpuFrequencyOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuVoltageOffset) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_properties_t),
            "::",
            stringify!(gpuVoltageOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vramFrequencyOffset) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_properties_t),
            "::",
            stringify!(vramFrequencyOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vramVoltageOffset) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_properties_t),
            "::",
            stringify!(vramVoltageOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).powerLimit) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_properties_t),
            "::",
            stringify!(powerLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temperatureLimit) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_properties_t),
            "::",
            stringify!(temperatureLimit)
        )
    );
}
#[doc = "\n @brief Overclock Voltage Frequency Pair"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_oc_vf_pair_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Voltage component of the pair in mV."]
    pub Voltage: f64,
    #[doc = "< [in,out] Frequency component of the pair in MHz."]
    pub Frequency: f64,
}
#[test]
fn bindgen_test_layout__ctl_oc_vf_pair_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_oc_vf_pair_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_oc_vf_pair_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_oc_vf_pair_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_oc_vf_pair_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_oc_vf_pair_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_vf_pair_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_vf_pair_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Voltage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_vf_pair_t),
            "::",
            stringify!(Voltage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Frequency) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_oc_vf_pair_t),
            "::",
            stringify!(Frequency)
        )
    );
}
#[doc = "< Type of the PSU is unknown."]
pub const _ctl_psu_type_t_CTL_PSU_TYPE_PSU_NONE: _ctl_psu_type_t = 0;
#[doc = "< Type of the PSU is PCIe"]
pub const _ctl_psu_type_t_CTL_PSU_TYPE_PSU_PCIE: _ctl_psu_type_t = 1;
#[doc = "< Type of the PSU is 6 PIN"]
pub const _ctl_psu_type_t_CTL_PSU_TYPE_PSU_6PIN: _ctl_psu_type_t = 2;
#[doc = "< Type of the PSU is 8 PIN"]
pub const _ctl_psu_type_t_CTL_PSU_TYPE_PSU_8PIN: _ctl_psu_type_t = 3;
pub const _ctl_psu_type_t_CTL_PSU_TYPE_MAX: _ctl_psu_type_t = 4;
#[doc = "\n @brief PSU Type."]
pub type _ctl_psu_type_t = ::std::os::raw::c_int;
#[doc = "\n @brief PSU Type."]
pub use self::_ctl_psu_type_t as ctl_psu_type_t;
#[doc = "\n @brief PSU Info"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_psu_info_t {
    #[doc = "< [out] Indicates if this PSU entry is supported."]
    pub bSupported: bool,
    #[doc = "< [out] Type of the PSU."]
    pub psuType: ctl_psu_type_t,
    #[doc = "< [out] Snapshot of the monotonic energy counter maintained by hardware.\n< It measures the total energy consumed this power source. By taking the\n< delta between two snapshots and dividing by the delta time in seconds,\n< an application can compute the average power."]
    pub energyCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the voltage of this power source."]
    pub voltage: ctl_oc_telemetry_item_t,
}
#[test]
fn bindgen_test_layout__ctl_psu_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_psu_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_psu_info_t>(),
        56usize,
        concat!("Size of: ", stringify!(_ctl_psu_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_psu_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_psu_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bSupported) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_psu_info_t),
            "::",
            stringify!(bSupported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).psuType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_psu_info_t),
            "::",
            stringify!(psuType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).energyCounter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_psu_info_t),
            "::",
            stringify!(energyCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).voltage) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_psu_info_t),
            "::",
            stringify!(voltage)
        )
    );
}
#[doc = "\n @brief Power Telemetry"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ctl_power_telemetry_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Snapshot of the timestamp counter that measures the total time\n< since Jan 1, 1970 UTC. It is a decimal value in seconds with a minimum\n< accuracy of 1 millisecond."]
    pub timeStamp: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Snapshot of the monotonic energy counter maintained by hardware.\n< It measures the total energy consumed by the GPU chip. By taking the\n< delta between two snapshots and dividing by the delta time in seconds,\n< an application can compute the average power."]
    pub gpuEnergyCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the voltage feeding the GPU chip. It\n< is measured at the power supply output - chip input will be lower."]
    pub gpuVoltage: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the GPU chip frequency."]
    pub gpuCurrentClockFrequency: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the GPU chip temperature, read from\n< the sensor reporting the highest value."]
    pub gpuCurrentTemperature: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Snapshot of the monotonic global activity counter. It measures\n< the time in seconds (accurate down to 1 millisecond) that any GPU\n< engine is busy. By taking the delta between two snapshots and dividing\n< by the delta time in seconds, an application can compute the average\n< percentage utilization of the GPU.."]
    pub globalActivityCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Snapshot of the monotonic 3D/compute activity counter. It\n< measures the time in seconds (accurate down to 1 millisecond) that any\n< 3D render/compute engine is busy. By taking the delta between two\n< snapshots and dividing by the delta time in seconds, an application\n< can compute the average percentage utilization of all 3D\n< render/compute blocks in the GPU."]
    pub renderComputeActivityCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Snapshot of the monotonic media activity counter. It measures\n< the time in seconds (accurate down to 1 millisecond) that any media\n< engine is busy. By taking the delta between two snapshots and dividing\n< by the delta time in seconds, an application can compute the average\n< percentage utilization of all media blocks in the GPU."]
    pub mediaActivityCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous indication that the desired GPU frequency is being\n< throttled because the GPU chip is exceeding the maximum power limits.\n< Increasing the power limits using ::ctlOverclockPowerLimitSet() is one\n< way to remove this limitation."]
    pub gpuPowerLimited: bool,
    #[doc = "< [out] Instantaneous indication that the desired GPU frequency is being\n< throttled because the GPU chip is exceeding the temperature limits.\n< Increasing the temperature limits using\n< ::ctlOverclockTemperatureLimitSet() is one way to reduce this\n< limitation. Improving the cooling solution is another way."]
    pub gpuTemperatureLimited: bool,
    #[doc = "< [out] Instantaneous indication that the desired GPU frequency is being\n< throttled because the GPU chip has exceeded the power supply current\n< limits. A better power supply is required to reduce this limitation."]
    pub gpuCurrentLimited: bool,
    #[doc = "< [out] Instantaneous indication that the GPU frequency cannot be\n< increased because the voltage limits have been reached. Increase the\n< voltage offset using ::ctlOverclockGpuVoltageOffsetSet() is one way to\n< reduce this limitation."]
    pub gpuVoltageLimited: bool,
    #[doc = "< [out] Instantaneous indication that due to lower GPU utilization, the\n< hardware has lowered the GPU frequency."]
    pub gpuUtilizationLimited: bool,
    #[doc = "< [out] Snapshot of the monotonic energy counter maintained by hardware.\n< It measures the total energy consumed by the local memory modules. By\n< taking the delta between two snapshots and dividing by the delta time\n< in seconds, an application can compute the average power."]
    pub vramEnergyCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the voltage feeding the memory\n< modules."]
    pub vramVoltage: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the raw clock frequency driving the\n< memory modules."]
    pub vramCurrentClockFrequency: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the effective data transfer rate that\n< the memory modules can sustain based on the current clock frequency.."]
    pub vramCurrentEffectiveFrequency: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the monotonic counter that measures\n< the read traffic from the memory modules. By taking the delta between\n< two snapshots and dividing by the delta time in seconds, an\n< application can compute the average read bandwidth."]
    pub vramReadBandwidthCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the monotonic counter that measures\n< the write traffic to the memory modules. By taking the delta between\n< two snapshots and dividing by the delta time in seconds, an\n< application can compute the average write bandwidth."]
    pub vramWriteBandwidthCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous snapshot of the GPU chip temperature, read from\n< the sensor reporting the highest value."]
    pub vramCurrentTemperature: ctl_oc_telemetry_item_t,
    #[doc = "< [out] Instantaneous indication that the memory frequency is being\n< throttled because the memory modules are exceeding the maximum power\n< limits."]
    pub vramPowerLimited: bool,
    #[doc = "< [out] Instantaneous indication that the memory frequency is being\n< throttled because the memory modules are exceeding the temperature\n< limits."]
    pub vramTemperatureLimited: bool,
    #[doc = "< [out] Instantaneous indication that the memory frequency is being\n< throttled because the memory modules have exceeded the power supply\n< current limits."]
    pub vramCurrentLimited: bool,
    #[doc = "< [out] Instantaneous indication that the memory frequency cannot be\n< increased because the voltage limits have been reached."]
    pub vramVoltageLimited: bool,
    #[doc = "< [out] Instantaneous indication that due to lower memory traffic, the\n< hardware has lowered the memory frequency."]
    pub vramUtilizationLimited: bool,
    #[doc = "< [out] Total Card Energy Counter."]
    pub totalCardEnergyCounter: ctl_oc_telemetry_item_t,
    #[doc = "< [out] PSU voltage and power."]
    pub psu: [ctl_psu_info_t; 5usize],
    #[doc = "< [out] Fan speed."]
    pub fanSpeed: [ctl_oc_telemetry_item_t; 5usize],
}
#[test]
fn bindgen_test_layout__ctl_power_telemetry_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_power_telemetry_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_power_telemetry_t>(),
        808usize,
        concat!("Size of: ", stringify!(_ctl_power_telemetry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_power_telemetry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_power_telemetry_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuEnergyCounter) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(gpuEnergyCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuVoltage) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(gpuVoltage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuCurrentClockFrequency) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(gpuCurrentClockFrequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuCurrentTemperature) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(gpuCurrentTemperature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).globalActivityCounter) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(globalActivityCounter)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).renderComputeActivityCounter) as usize - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(renderComputeActivityCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mediaActivityCounter) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(mediaActivityCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuPowerLimited) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(gpuPowerLimited)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuTemperatureLimited) as usize - ptr as usize },
        201usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(gpuTemperatureLimited)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuCurrentLimited) as usize - ptr as usize },
        202usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(gpuCurrentLimited)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuVoltageLimited) as usize - ptr as usize },
        203usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(gpuVoltageLimited)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpuUtilizationLimited) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(gpuUtilizationLimited)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vramEnergyCounter) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(vramEnergyCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vramVoltage) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(vramVoltage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vramCurrentClockFrequency) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(vramCurrentClockFrequency)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).vramCurrentEffectiveFrequency) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(vramCurrentEffectiveFrequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vramReadBandwidthCounter) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(vramReadBandwidthCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vramWriteBandwidthCounter) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(vramWriteBandwidthCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vramCurrentTemperature) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(vramCurrentTemperature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vramPowerLimited) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(vramPowerLimited)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vramTemperatureLimited) as usize - ptr as usize },
        377usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(vramTemperatureLimited)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vramCurrentLimited) as usize - ptr as usize },
        378usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(vramCurrentLimited)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vramVoltageLimited) as usize - ptr as usize },
        379usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(vramVoltageLimited)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vramUtilizationLimited) as usize - ptr as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(vramUtilizationLimited)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalCardEnergyCounter) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(totalCardEnergyCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).psu) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(psu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fanSpeed) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_telemetry_t),
            "::",
            stringify!(fanSpeed)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get overclock properties - available properties.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pOcProperties`"]
    pub fn ctlOverclockGetProperties(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pOcProperties: *mut ctl_oc_properties_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Overclock Waiver - Warranty Waiver.\n\n @details\n     - Most of the overclock functions will return an error if the waiver is\n       not set. This is because most overclock settings will increase the\n       electric/thermal stress on the part and thus reduce its lifetime.\n     - By setting the waiver, the user is indicate that they are accepting a\n       reduction in the lifetime of the part.\n     - It is the responsibility of overclock applications to notify each user\n       at least once with a popup of the dangers and requiring acceptance.\n     - Only once the user has accepted should this function be called by the\n       application.\n     - It is acceptable for the application to cache the user choice and call\n       this function on future executions without issuing the popup.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`"]
    pub fn ctlOverclockWaiverSet(hDeviceHandle: ctl_device_adapter_handle_t) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get the Overclock Frequency Offset for the GPU in MHz.\n\n @details\n     - Determine the current frequency offset in effect (refer to\n       ::ctlOverclockGpuFrequencyOffsetSet() for details).\n     - The value returned may be different from the value that was previously\n       set by the application depending on hardware limitations or if the\n       function ::ctlOverclockGpuFrequencyOffsetSet() has been called or\n       another application that has changed the value.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pOcFrequencyOffset`"]
    pub fn ctlOverclockGpuFrequencyOffsetGet(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pOcFrequencyOffset: *mut f64,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Set the Overclock Frequency Offset for the GPU in MHZ.\n\n @details\n     - The purpose of this function is to increase/decrease the frequency at\n       which typical workloads will run within the same thermal budget.\n     - The frequency offset is expressed in units of 1MHz.\n     - The actual operating frequency for each workload is not guaranteed to\n       change exactly by the specified offset.\n     - For positive frequency offsets, the factory maximum frequency may\n       increase by up to the specified amount.\n     - For negative frequency offsets, the overclock waiver must have been\n       set since this can result in running the part at voltages beyond the\n       part warrantee limits. An error is returned if the waiver has not been\n       set.\n     - Specifying large values for the frequency offset can lead to\n       instability. It is recommended that changes are made in small\n       increments and stability/performance measured running intense GPU\n       workloads before increasing further.\n     - This setting is not persistent through system reboots or driver\n       resets/hangs. It is up to the overclock application to reapply the\n       settings in those cases.\n     - This setting can cause system/device instability. It is up to the\n       overclock application to detect if the system has rebooted\n       unexpectedly or the device was restarted. When this occurs, the\n       application should not reapply the overclock settings automatically\n       but instead return to previously known good settings or notify the\n       user that the settings are not being applied.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`"]
    pub fn ctlOverclockGpuFrequencyOffsetSet(
        hDeviceHandle: ctl_device_adapter_handle_t,
        ocFrequencyOffset: f64,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get the Overclock Gpu Voltage Offset in mV.\n\n @details\n     - Determine the current voltage offset in effect on the hardware (refer\n       to ::ctlOverclockGpuVoltageOffsetSet for details).\n     - The value returned may be different from the value that was previously\n       set by the application depending on hardware limitations or if the\n       function ::ctlOverclockGpuVoltageOffsetSet has been called or another\n       application that has changed the value.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pOcVoltageOffset`"]
    pub fn ctlOverclockGpuVoltageOffsetGet(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pOcVoltageOffset: *mut f64,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Set the Overclock Gpu Voltage Offset in mV.\n\n @details\n     - The purpose of this function is to attempt to run the GPU up to higher\n       voltages beyond the part warrantee limits. This can permit running at\n       even higher frequencies than can be obtained using the frequency\n       offset setting, but at the risk of reducing the lifetime of the part.\n     - The voltage offset is expressed in units of millivolts with values\n       permitted down to a resolution of 1 millivolt.\n     - The overclock waiver must be set before calling this function\n       otherwise and error will be returned.\n     - There is no guarantee that a workload can operate at the higher\n       frequencies permitted by this setting. Significantly more heat will be\n       generated at these high frequencies/voltages which will necessitate a\n       good cooling solution.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`"]
    pub fn ctlOverclockGpuVoltageOffsetSet(
        hDeviceHandle: ctl_device_adapter_handle_t,
        ocVoltageOffset: f64,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Gets the Locked GPU Voltage for Overclocking in mV.\n\n @details\n     - The purpose of this function is to determine if the current values of\n       the frequency/voltage lock.\n     - If the lock is not currently active, will return 0 for frequency and\n       voltage.\n     - Note that the operating frequency/voltage may be lower than these\n       settings if power/thermal limits are exceeded.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pVfPair`"]
    pub fn ctlOverclockGpuLockGet(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pVfPair: *mut ctl_oc_vf_pair_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Locks the GPU voltage for Overclocking in mV.\n\n @details\n     - The purpose of this function is to provide an interface for scanners\n       to lock the frequency and voltage to fixed values.\n     - The frequency is expressed in units of MHz with a resolution of 1MHz.\n     - The voltage is expressed in units of millivolts with values\n       permitted down to a resolution of 1 millivolt.\n     - The overclock waiver must be set since fixing the voltage at a high\n       value puts unnecessary stress on the part.\n     - The actual frequency may reduce depending on power/thermal\n       limitations.\n     - Requesting a frequency and/or voltage of 0 will return the hardware to\n       dynamic frequency/voltage management with any previous frequency\n       offset or voltage offset settings reapplied.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`"]
    pub fn ctlOverclockGpuLockSet(
        hDeviceHandle: ctl_device_adapter_handle_t,
        vFPair: ctl_oc_vf_pair_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get the current Vram Frequency Offset in GT/s.\n\n @details\n     - The purpose of this function is to return the current VRAM frequency\n       offset in units of GT/s.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pOcFrequencyOffset`"]
    pub fn ctlOverclockVramFrequencyOffsetGet(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pOcFrequencyOffset: *mut f64,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Set the desired Vram frquency Offset in GT/s\n\n @details\n     - The purpose of this function is to increase/decrease the frequency of\n       VRAM.\n     - The frequency offset is expressed in units of GT/s with a minimum step\n       size given by ::ctlOverclockGetProperties.\n     - The actual operating frequency for each workload is not guaranteed to\n       change exactly by the specified offset.\n     - The waiver must be set using clibOverclockWaiverSet() before this\n       function can be called.\n     - This setting is not persistent through system reboots or driver\n       resets/hangs. It is up to the overclock application to reapply the\n       settings in those cases.\n     - This setting can cause system/device instability. It is up to the\n       overclock application to detect if the system has rebooted\n       unexpectedly or the device was restarted. When this occurs, the\n       application should not reapply the overclock settings automatically\n       but instead return to previously known good settings or notify the\n       user that the settings are not being applied.\n     - If the memory controller doesn't support changes to frequency on the\n       fly, one of the following return codes will be given:\n     - ::CTL_RESULT_ERROR_RESET_DEVICE_REQUIRED: The requested memory\n       overclock will be applied when the device is reset or the system is\n       rebooted. In this case, the overclock software should check if the\n       overclock request was applied after the reset/reboot. If it was and\n       when the overclock application shuts down gracefully and if the\n       overclock application wants the setting to be persistent, the\n       application should request the same overclock settings again so that\n       they will be applied on the next reset/reboot. If this is not done,\n       then every time the device is reset and overclock is requested, the\n       device needs to be reset a second time.\n     - ::CTL_RESULT_ERROR_FULL_REBOOT_REQUIRED: The requested memory\n       overclock will be applied when the system is rebooted. In this case,\n       the overclock software should check if the overclock request was\n       applied after the reboot. If it was and when the overclock application\n       shuts down gracefully and if the overclock application wants the\n       setting to be persistent, the application should request the same\n       overclock settings again so that they will be applied on the next\n       reset/reboot. If this is not done and the overclock setting is\n       requested after the reboot has occurred, a second reboot will be\n       required.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`"]
    pub fn ctlOverclockVramFrequencyOffsetSet(
        hDeviceHandle: ctl_device_adapter_handle_t,
        ocFrequencyOffset: f64,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get the Overclock Vram Voltage Offset in mV.\n\n @details\n     - The purpose of this function is to increase/decrease the voltage of\n       VRAM.\n     - The voltage offset is expressed in units of millivolts with a minimum\n       step size given by ::ctlOverclockGetProperties.\n     - The waiver must be set using ::ctlOverclockWaiverSet before this\n       function can be called.\n     - This setting is not persistent through system reboots or driver\n       resets/hangs. It is up to the overclock application to reapply the\n       settings in those cases.\n     - This setting can cause system/device instability. It is up to the\n       overclock application to detect if the system has rebooted\n       unexpectedly or the device was restarted. When this occurs, the\n       application should not reapply the overclock settings automatically\n       but instead return to previously known good settings or notify the\n       user that the settings are not being applied.\n     - If the memory controller doesn't support changes to voltage on the\n       fly, one of the following return codes will be given:\n     - ::CTL_RESULT_ERROR_RESET_DEVICE_REQUIRED: The requested memory\n       overclock will be applied when the device is reset or the system is\n       rebooted. In this case, the overclock software should check if the\n       overclock request was applied after the reset/reboot. If it was and\n       when the overclock application shuts down gracefully and if the\n       overclock application wants the setting to be persistent, the\n       application should request the same overclock settings again so that\n       they will be applied on the next reset/reboot. If this is not done,\n       then every time the device is reset and overclock is requested, the\n       device needs to be reset a second time.\n     - ::CTL_RESULT_ERROR_FULL_REBOOT_REQUIRED: The requested memory\n       overclock will be applied when the system is rebooted. In this case,\n       the overclock software should check if the overclock request was\n       applied after the reboot. If it was and when the overclock application\n       shuts down gracefully and if the overclock application wants the\n       setting to be persistent, the application should request the same\n       overclock settings again so that they will be applied on the next\n       reset/reboot. If this is not done and the overclock setting is\n       requested after the reboot has occurred, a second reboot will be\n       required.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pVoltage`"]
    pub fn ctlOverclockVramVoltageOffsetGet(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pVoltage: *mut f64,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Set the Overclock Vram Voltage Offset in mV.\n\n @details\n     - The purpose of this function is to set the maximum sustained power\n       limit. If the average GPU power averaged over a few seconds exceeds\n       this value, the frequency of the GPU will be throttled.\n     - Set a value of 0 to disable this power limit. In this case, the GPU\n       frequency will not throttle due to average power but may hit other\n       limits.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`"]
    pub fn ctlOverclockVramVoltageOffsetSet(
        hDeviceHandle: ctl_device_adapter_handle_t,
        voltage: f64,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get the sustained power limit in mW.\n\n @details\n     - The purpose of this function is to read the current sustained power\n       limit.\n     - A value of 0 means that the limit is disabled - the GPU frequency can\n       run as high as possible until other limits are hit.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pSustainedPowerLimit`"]
    pub fn ctlOverclockPowerLimitGet(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pSustainedPowerLimit: *mut f64,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Set the sustained power limit in mW.\n\n @details\n     - The purpose of this function is to set the maximum sustained power\n       limit. If the average GPU power averaged over a few seconds exceeds\n       this value, the frequency of the GPU will be throttled.\n     - Set a value of 0 to disable this power limit. In this case, the GPU\n       frequency will not throttle due to average power but may hit other\n       limits.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`"]
    pub fn ctlOverclockPowerLimitSet(
        hDeviceHandle: ctl_device_adapter_handle_t,
        sustainedPowerLimit: f64,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get the current temperature limit in Celsius.\n\n @details\n     - The purpose of this function is to read the current thermal limit.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pTemperatureLimit`"]
    pub fn ctlOverclockTemperatureLimitGet(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pTemperatureLimit: *mut f64,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Set the temperature limit in Celsius.\n\n @details\n     - The purpose of this function is to change the maximum thermal limit.\n       When the GPU temperature exceeds this value, the GPU frequency will be\n       throttled.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`"]
    pub fn ctlOverclockTemperatureLimitSet(
        hDeviceHandle: ctl_device_adapter_handle_t,
        temperatureLimit: f64,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get Power Telemetry.\n\n @details\n     - Limited rate of 50 ms, any call under 50 ms will return the same\n       information.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDeviceHandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pTelemetryInfo`"]
    pub fn ctlPowerTelemetryGet(
        hDeviceHandle: ctl_device_adapter_handle_t,
        pTelemetryInfo: *mut ctl_power_telemetry_t,
    ) -> ctl_result_t;
}
#[doc = "\n @brief PCI address"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pci_address_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] BDF domain"]
    pub domain: u32,
    #[doc = "< [out] BDF bus"]
    pub bus: u32,
    #[doc = "< [out] BDF device"]
    pub device: u32,
    #[doc = "< [out] BDF function"]
    pub function: u32,
}
#[test]
fn bindgen_test_layout__ctl_pci_address_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_pci_address_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_pci_address_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_pci_address_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_pci_address_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_pci_address_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_address_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_address_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_address_t),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bus) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_address_t),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_address_t),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_address_t),
            "::",
            stringify!(function)
        )
    );
}
#[doc = "\n @brief PCI speed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pci_speed_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The link generation. A value of -1 means that this property is\n< unknown."]
    pub gen: i32,
    #[doc = "< [out] The number of lanes. A value of -1 means that this property is\n< unknown."]
    pub width: i32,
    #[doc = "< [out] The maximum bandwidth in bytes/sec (sum of all lanes). A value\n< of -1 means that this property is unknown."]
    pub maxBandwidth: i64,
}
#[test]
fn bindgen_test_layout__ctl_pci_speed_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_pci_speed_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_pci_speed_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_pci_speed_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_pci_speed_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_pci_speed_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_speed_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_speed_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_speed_t),
            "::",
            stringify!(gen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_speed_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxBandwidth) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_speed_t),
            "::",
            stringify!(maxBandwidth)
        )
    );
}
#[doc = "\n @brief Static PCI properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pci_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The BDF address"]
    pub address: ctl_pci_address_t,
    #[doc = "< [out] Fastest port configuration supported by the device (sum of all\n< lanes)"]
    pub maxSpeed: ctl_pci_speed_t,
    #[doc = "< [out] Support for Resizable Bar on this device."]
    pub resizable_bar_supported: bool,
    #[doc = "< [out] Resizable Bar enabled on this device"]
    pub resizable_bar_enabled: bool,
}
#[test]
fn bindgen_test_layout__ctl_pci_properties_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_pci_properties_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_pci_properties_t>(),
        64usize,
        concat!("Size of: ", stringify!(_ctl_pci_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_pci_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_pci_properties_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_properties_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_properties_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_properties_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSpeed) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_properties_t),
            "::",
            stringify!(maxSpeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resizable_bar_supported) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_properties_t),
            "::",
            stringify!(resizable_bar_supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resizable_bar_enabled) as usize - ptr as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_properties_t),
            "::",
            stringify!(resizable_bar_enabled)
        )
    );
}
#[doc = "\n @brief Dynamic PCI state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_pci_state_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The current port configure speed"]
    pub speed: ctl_pci_speed_t,
}
#[test]
fn bindgen_test_layout__ctl_pci_state_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_pci_state_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_pci_state_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ctl_pci_state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_pci_state_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_pci_state_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_state_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_state_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_pci_state_t),
            "::",
            stringify!(speed)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get PCI properties - address, max speed\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`"]
    pub fn ctlPciGetProperties(
        hDAhandle: ctl_device_adapter_handle_t,
        pProperties: *mut ctl_pci_properties_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get current PCI state - current speed\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pState`"]
    pub fn ctlPciGetState(
        hDAhandle: ctl_device_adapter_handle_t,
        pState: *mut ctl_pci_state_t,
    ) -> ctl_result_t;
}
#[doc = "\n @brief Properties related to device power settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_power_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Software can change the power limits of this domain assuming the\n< user has permissions."]
    pub canControl: bool,
    #[doc = "< [out] The factory default TDP power limit of the part in milliwatts. A\n< value of -1 means that this is not known."]
    pub defaultLimit: i32,
    #[doc = "< [out] The minimum power limit in milliwatts that can be requested."]
    pub minLimit: i32,
    #[doc = "< [out] The maximum power limit in milliwatts that can be requested."]
    pub maxLimit: i32,
}
#[test]
fn bindgen_test_layout__ctl_power_properties_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_power_properties_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_power_properties_t>(),
        20usize,
        concat!("Size of: ", stringify!(_ctl_power_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_power_properties_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_power_properties_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_properties_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_properties_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).canControl) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_properties_t),
            "::",
            stringify!(canControl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defaultLimit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_properties_t),
            "::",
            stringify!(defaultLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minLimit) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_properties_t),
            "::",
            stringify!(minLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxLimit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_properties_t),
            "::",
            stringify!(maxLimit)
        )
    );
}
#[doc = "\n @brief Energy counter snapshot\n\n @details\n     - Average power is calculated by taking two snapshots (s1, s2) and using\n       the equation: PowerWatts = (s2.energy - s1.energy) / (s2.timestamp -\n       s1.timestamp)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_power_energy_counter_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] The monotonic energy counter in microjoules."]
    pub energy: u64,
    #[doc = "< [out] Microsecond timestamp when energy was captured.\n< This timestamp should only be used to calculate delta time between\n< snapshots of this structure.\n< Never take the delta of this timestamp with the timestamp from a\n< different structure since they are not guaranteed to have the same base.\n< The absolute value of the timestamp is only valid during within the\n< application and may be different on the next execution."]
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout__ctl_power_energy_counter_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_power_energy_counter_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_power_energy_counter_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_power_energy_counter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_power_energy_counter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_power_energy_counter_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_energy_counter_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_energy_counter_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).energy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_energy_counter_t),
            "::",
            stringify!(energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_energy_counter_t),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = "\n @brief Sustained power limits\n\n @details\n     - The power controller (Punit) will throttle the operating frequency if\n       the power averaged over a window (typically seconds) exceeds this\n       limit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_power_sustained_limit_t {
    #[doc = "< [in,out] indicates if the limit is enabled (true) or ignored (false)"]
    pub enabled: bool,
    #[doc = "< [in,out] power limit in milliwatts"]
    pub power: i32,
    #[doc = "< [in,out] power averaging window (Tau) in milliseconds"]
    pub interval: i32,
}
#[test]
fn bindgen_test_layout__ctl_power_sustained_limit_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_power_sustained_limit_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_power_sustained_limit_t>(),
        12usize,
        concat!("Size of: ", stringify!(_ctl_power_sustained_limit_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_power_sustained_limit_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_power_sustained_limit_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_sustained_limit_t),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).power) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_sustained_limit_t),
            "::",
            stringify!(power)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_sustained_limit_t),
            "::",
            stringify!(interval)
        )
    );
}
#[doc = "\n @brief Burst power limit\n\n @details\n     - The power controller (Punit) will throttle the operating frequency of\n       the device if the power averaged over a few milliseconds exceeds a\n       limit known as PL2. Typically PL2 > PL1 so that it permits the\n       frequency to burst higher for short periods than would be otherwise\n       permitted by PL1."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_power_burst_limit_t {
    #[doc = "< [in,out] indicates if the limit is enabled (true) or ignored (false)"]
    pub enabled: bool,
    #[doc = "< [in,out] power limit in milliwatts"]
    pub power: i32,
}
#[test]
fn bindgen_test_layout__ctl_power_burst_limit_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_power_burst_limit_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_power_burst_limit_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ctl_power_burst_limit_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_power_burst_limit_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_power_burst_limit_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_burst_limit_t),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).power) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_burst_limit_t),
            "::",
            stringify!(power)
        )
    );
}
#[doc = "\n @brief Peak power limit\n\n @details\n     - The power controller (Punit) will preemptively throttle the operating\n       frequency of the device when the instantaneous power exceeds this\n       limit. The limit is known as PL4. It expresses the maximum power that\n       can be drawn from the power supply.\n     - If this power limit is removed or set too high, the power supply will\n       generate an interrupt when it detects an overcurrent condition and the\n       power controller will throttle the device frequencies down to min. It\n       is thus better to tune the PL4 value in order to avoid such\n       excursions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_power_peak_limit_t {
    #[doc = "< [in,out] power limit in milliwatts for the AC power source."]
    pub powerAC: i32,
    #[doc = "< [in,out] power limit in milliwatts for the DC power source. On input,\n< this is ignored if the product does not have a battery. On output,\n< this will be -1 if the product does not have a battery."]
    pub powerDC: i32,
}
#[test]
fn bindgen_test_layout__ctl_power_peak_limit_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_power_peak_limit_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_power_peak_limit_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ctl_power_peak_limit_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_power_peak_limit_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_power_peak_limit_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).powerAC) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_peak_limit_t),
            "::",
            stringify!(powerAC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).powerDC) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_peak_limit_t),
            "::",
            stringify!(powerDC)
        )
    );
}
#[doc = "\n @brief Power limits"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_power_limits_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] sustained power limit."]
    pub sustainedPowerLimit: ctl_power_sustained_limit_t,
    #[doc = "< [in,out] burst power limit."]
    pub burstPowerLimit: ctl_power_burst_limit_t,
    #[doc = "< [in,out] peak power limit."]
    pub peakPowerLimits: ctl_power_peak_limit_t,
}
#[test]
fn bindgen_test_layout__ctl_power_limits_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_power_limits_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_power_limits_t>(),
        36usize,
        concat!("Size of: ", stringify!(_ctl_power_limits_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_power_limits_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ctl_power_limits_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_limits_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_limits_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sustainedPowerLimit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_limits_t),
            "::",
            stringify!(sustainedPowerLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).burstPowerLimit) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_limits_t),
            "::",
            stringify!(burstPowerLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).peakPowerLimits) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_power_limits_t),
            "::",
            stringify!(peakPowerLimits)
        )
    );
}
#[doc = "\n @brief Energy threshold\n\n @details\n     - ."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_energy_threshold_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [in,out] Indicates if the energy threshold is enabled."]
    pub enable: bool,
    #[doc = "< [in,out] The energy threshold in Joules. Will be 0.0 if no threshold\n< has been set."]
    pub threshold: f64,
    #[doc = "< [in,out] The host process ID that set the energy threshold. Will be\n< 0xFFFFFFFF if no threshold has been set."]
    pub processId: u32,
}
#[test]
fn bindgen_test_layout__ctl_energy_threshold_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_energy_threshold_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_energy_threshold_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_energy_threshold_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_energy_threshold_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_energy_threshold_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_energy_threshold_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_energy_threshold_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_energy_threshold_t),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_energy_threshold_t),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_energy_threshold_t),
            "::",
            stringify!(processId)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get handle of power domains\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`"]
    pub fn ctlEnumPowerDomains(
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phPower: *mut ctl_pwr_handle_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get properties related to a power domain\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hPower`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`"]
    pub fn ctlPowerGetProperties(
        hPower: ctl_pwr_handle_t,
        pProperties: *mut ctl_power_properties_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get energy counter\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hPower`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pEnergy`"]
    pub fn ctlPowerGetEnergyCounter(
        hPower: ctl_pwr_handle_t,
        pEnergy: *mut ctl_power_energy_counter_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get power limits\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hPower`"]
    pub fn ctlPowerGetLimits(
        hPower: ctl_pwr_handle_t,
        pPowerLimits: *mut ctl_power_limits_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Set power limits\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hPower`\n     - ::CTL_RESULT_ERROR_INSUFFICIENT_PERMISSIONS\n         + User does not have permissions to make these modifications.\n     - ::CTL_RESULT_ERROR_NOT_AVAILABLE\n         + The device is in use, meaning that the GPU is under Over clocking, applying power limits under overclocking is not supported."]
    pub fn ctlPowerSetLimits(
        hPower: ctl_pwr_handle_t,
        pPowerLimits: *const ctl_power_limits_t,
    ) -> ctl_result_t;
}
#[doc = "< The maximum temperature across all device sensors"]
pub const _ctl_temp_sensors_t_CTL_TEMP_SENSORS_GLOBAL: _ctl_temp_sensors_t = 0;
#[doc = "< The maximum temperature across all sensors in the GPU"]
pub const _ctl_temp_sensors_t_CTL_TEMP_SENSORS_GPU: _ctl_temp_sensors_t = 1;
#[doc = "< The maximum temperature across all sensors in the local memory"]
pub const _ctl_temp_sensors_t_CTL_TEMP_SENSORS_MEMORY: _ctl_temp_sensors_t = 2;
#[doc = "< The minimum temperature across all device sensors"]
pub const _ctl_temp_sensors_t_CTL_TEMP_SENSORS_GLOBAL_MIN: _ctl_temp_sensors_t = 3;
#[doc = "< The minimum temperature across all sensors in the GPU"]
pub const _ctl_temp_sensors_t_CTL_TEMP_SENSORS_GPU_MIN: _ctl_temp_sensors_t = 4;
#[doc = "< The minimum temperature across all sensors in the local device memory"]
pub const _ctl_temp_sensors_t_CTL_TEMP_SENSORS_MEMORY_MIN: _ctl_temp_sensors_t = 5;
pub const _ctl_temp_sensors_t_CTL_TEMP_SENSORS_MAX: _ctl_temp_sensors_t = 6;
#[doc = "\n @brief Temperature sensors"]
pub type _ctl_temp_sensors_t = ::std::os::raw::c_int;
#[doc = "\n @brief Temperature sensors"]
pub use self::_ctl_temp_sensors_t as ctl_temp_sensors_t;
#[doc = "\n @brief Temperature sensor properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ctl_temp_properties_t {
    #[doc = "< [in] size of this structure"]
    pub Size: u32,
    #[doc = "< [in] version of this structure"]
    pub Version: u8,
    #[doc = "< [out] Which part of the device the temperature sensor measures"]
    pub type_: ctl_temp_sensors_t,
    #[doc = "< [out] Will contain the maximum temperature for the specific device in\n< degrees Celsius."]
    pub maxTemperature: f64,
}
#[test]
fn bindgen_test_layout__ctl_temp_properties_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ctl_temp_properties_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ctl_temp_properties_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ctl_temp_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ctl_temp_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ctl_temp_properties_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_temp_properties_t),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_temp_properties_t),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_temp_properties_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTemperature) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ctl_temp_properties_t),
            "::",
            stringify!(maxTemperature)
        )
    );
}
extern "C" {
    #[doc = "\n @brief Get handle of temperature sensors\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hDAhandle`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pCount`"]
    pub fn ctlEnumTemperatureSensors(
        hDAhandle: ctl_device_adapter_handle_t,
        pCount: *mut u32,
        phTemperature: *mut ctl_temp_handle_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get temperature sensor properties\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hTemperature`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pProperties`"]
    pub fn ctlTemperatureGetProperties(
        hTemperature: ctl_temp_handle_t,
        pProperties: *mut ctl_temp_properties_t,
    ) -> ctl_result_t;
}
extern "C" {
    #[doc = "\n @brief Get the temperature from a specified sensor\n\n @details\n     - The application may call this function from simultaneous threads.\n     - The implementation of this function should be lock-free.\n\n @returns\n     - CTL_RESULT_SUCCESS\n     - CTL_RESULT_ERROR_UNINITIALIZED\n     - CTL_RESULT_ERROR_DEVICE_LOST\n     - CTL_RESULT_ERROR_INVALID_NULL_HANDLE\n         + `nullptr == hTemperature`\n     - CTL_RESULT_ERROR_INVALID_NULL_POINTER\n         + `nullptr == pTemperature`"]
    pub fn ctlTemperatureGetState(
        hTemperature: ctl_temp_handle_t,
        pTemperature: *mut f64,
    ) -> ctl_result_t;
}
#[doc = "\n @brief Function-pointer for ctlInit"]
pub type ctl_pfnInit_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ctl_init_args_t, arg2: *mut ctl_api_handle_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlClose"]
pub type ctl_pfnClose_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ctl_api_handle_t) -> ctl_result_t>;
#[doc = "\n @brief Function-pointer for ctlSetRuntimePath"]
pub type ctl_pfnSetRuntimePath_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ctl_runtime_path_args_t) -> ctl_result_t>;
#[doc = "\n @brief Function-pointer for ctlWaitForPropertyChange"]
pub type ctl_pfnWaitForPropertyChange_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_wait_property_change_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlReservedCall"]
pub type ctl_pfnReservedCall_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_reserved_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSupported3DCapabilities"]
pub type ctl_pfnGetSupported3DCapabilities_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_3d_feature_caps_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSet3DFeature"]
pub type ctl_pfnGetSet3DFeature_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_3d_feature_getset_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlCheckDriverVersion"]
pub type ctl_pfnCheckDriverVersion_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: ctl_version_info_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumerateDevices"]
pub type ctl_pfnEnumerateDevices_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_api_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_device_adapter_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumerateDisplayOutputs"]
pub type ctl_pfnEnumerateDisplayOutputs_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_display_output_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetDeviceProperties"]
pub type ctl_pfnGetDeviceProperties_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_device_adapter_properties_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetDisplayProperties"]
pub type ctl_pfnGetDisplayProperties_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_display_properties_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetAdaperDisplayEncoderProperties"]
pub type ctl_pfnGetAdaperDisplayEncoderProperties_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_adapter_display_encoder_properties_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetZeDevice"]
pub type ctl_pfnGetZeDevice_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut *mut ::std::os::raw::c_void,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSharpnessCaps"]
pub type ctl_pfnGetSharpnessCaps_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_sharpness_caps_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetCurrentSharpness"]
pub type ctl_pfnGetCurrentSharpness_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_sharpness_settings_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlSetCurrentSharpness"]
pub type ctl_pfnSetCurrentSharpness_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_sharpness_settings_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlI2CAccess"]
pub type ctl_pfnI2CAccess_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_i2c_access_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlAUXAccess"]
pub type ctl_pfnAUXAccess_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_aux_access_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetPowerOptimizationCaps"]
pub type ctl_pfnGetPowerOptimizationCaps_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_power_optimization_caps_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetPowerOptimizationSetting"]
pub type ctl_pfnGetPowerOptimizationSetting_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_power_optimization_settings_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlSetPowerOptimizationSetting"]
pub type ctl_pfnSetPowerOptimizationSetting_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_power_optimization_settings_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlSetBrightnessSetting"]
pub type ctl_pfnSetBrightnessSetting_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_set_brightness_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetBrightnessSetting"]
pub type ctl_pfnGetBrightnessSetting_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_get_brightness_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPixelTransformationGetConfig"]
pub type ctl_pfnPixelTransformationGetConfig_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_pixtx_pipe_get_config_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPixelTransformationSetConfig"]
pub type ctl_pfnPixelTransformationSetConfig_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_pixtx_pipe_set_config_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPanelDescriptorAccess"]
pub type ctl_pfnPanelDescriptorAccess_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_panel_descriptor_access_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSupportedRetroScalingCapability"]
pub type ctl_pfnGetSupportedRetroScalingCapability_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_retro_scaling_caps_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSetRetroScaling"]
pub type ctl_pfnGetSetRetroScaling_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_retro_scaling_settings_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSupportedScalingCapability"]
pub type ctl_pfnGetSupportedScalingCapability_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_scaling_caps_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetCurrentScaling"]
pub type ctl_pfnGetCurrentScaling_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_scaling_settings_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlSetCurrentScaling"]
pub type ctl_pfnSetCurrentScaling_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_scaling_settings_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetLACEConfig"]
pub type ctl_pfnGetLACEConfig_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_lace_config_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlSetLACEConfig"]
pub type ctl_pfnSetLACEConfig_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_lace_config_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlSoftwarePSR"]
pub type ctl_pfnSoftwarePSR_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_sw_psr_settings_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetIntelArcSyncInfoForMonitor"]
pub type ctl_pfnGetIntelArcSyncInfoForMonitor_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_intel_arc_sync_monitor_params_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumerateMuxDevices"]
pub type ctl_pfnEnumerateMuxDevices_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_api_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_mux_output_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetMuxProperties"]
pub type ctl_pfnGetMuxProperties_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_mux_output_handle_t,
        arg2: *mut ctl_mux_properties_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlSwitchMux"]
pub type ctl_pfnSwitchMux_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_mux_output_handle_t,
        arg2: ctl_display_output_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetIntelArcSyncProfile"]
pub type ctl_pfnGetIntelArcSyncProfile_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_intel_arc_sync_profile_params_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlSetIntelArcSyncProfile"]
pub type ctl_pfnSetIntelArcSyncProfile_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_intel_arc_sync_profile_params_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEdidManagement"]
pub type ctl_pfnEdidManagement_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_edid_management_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSetCustomMode"]
pub type ctl_pfnGetSetCustomMode_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_display_output_handle_t,
        arg2: *mut ctl_get_set_custom_mode_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSetCombinedDisplay"]
pub type ctl_pfnGetSetCombinedDisplay_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_combined_display_args_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSetDisplayGenlock"]
pub type ctl_pfnGetSetDisplayGenlock_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ctl_device_adapter_handle_t,
        arg2: *mut *mut ctl_genlock_args_t,
        arg3: u32,
        arg4: *mut ctl_device_adapter_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumEngineGroups"]
pub type ctl_pfnEnumEngineGroups_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_engine_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEngineGetProperties"]
pub type ctl_pfnEngineGetProperties_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_engine_handle_t,
        arg2: *mut ctl_engine_properties_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEngineGetActivity"]
pub type ctl_pfnEngineGetActivity_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_engine_handle_t, arg2: *mut ctl_engine_stats_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumFans"]
pub type ctl_pfnEnumFans_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_fan_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFanGetProperties"]
pub type ctl_pfnFanGetProperties_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_fan_handle_t, arg2: *mut ctl_fan_properties_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFanGetConfig"]
pub type ctl_pfnFanGetConfig_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_fan_handle_t, arg2: *mut ctl_fan_config_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFanSetDefaultMode"]
pub type ctl_pfnFanSetDefaultMode_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ctl_fan_handle_t) -> ctl_result_t>;
#[doc = "\n @brief Function-pointer for ctlFanSetFixedSpeedMode"]
pub type ctl_pfnFanSetFixedSpeedMode_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_fan_handle_t, arg2: *const ctl_fan_speed_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFanSetSpeedTableMode"]
pub type ctl_pfnFanSetSpeedTableMode_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_fan_handle_t,
        arg2: *const ctl_fan_speed_table_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFanGetState"]
pub type ctl_pfnFanGetState_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_fan_handle_t,
        arg2: ctl_fan_speed_units_t,
        arg3: *mut i32,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumFrequencyDomains"]
pub type ctl_pfnEnumFrequencyDomains_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_freq_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFrequencyGetProperties"]
pub type ctl_pfnFrequencyGetProperties_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_freq_handle_t, arg2: *mut ctl_freq_properties_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFrequencyGetAvailableClocks"]
pub type ctl_pfnFrequencyGetAvailableClocks_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_freq_handle_t, arg2: *mut u32, arg3: *mut f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFrequencyGetRange"]
pub type ctl_pfnFrequencyGetRange_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_freq_handle_t, arg2: *mut ctl_freq_range_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFrequencySetRange"]
pub type ctl_pfnFrequencySetRange_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_freq_handle_t, arg2: *const ctl_freq_range_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFrequencyGetState"]
pub type ctl_pfnFrequencyGetState_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_freq_handle_t, arg2: *mut ctl_freq_state_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlFrequencyGetThrottleTime"]
pub type ctl_pfnFrequencyGetThrottleTime_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_freq_handle_t,
        arg2: *mut ctl_freq_throttle_time_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSupportedVideoProcessingCapabilities"]
pub type ctl_pfnGetSupportedVideoProcessingCapabilities_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_video_processing_feature_caps_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlGetSetVideoProcessingFeature"]
pub type ctl_pfnGetSetVideoProcessingFeature_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_video_processing_feature_getset_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumMemoryModules"]
pub type ctl_pfnEnumMemoryModules_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_mem_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlMemoryGetProperties"]
pub type ctl_pfnMemoryGetProperties_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_mem_handle_t, arg2: *mut ctl_mem_properties_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlMemoryGetState"]
pub type ctl_pfnMemoryGetState_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_mem_handle_t, arg2: *mut ctl_mem_state_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlMemoryGetBandwidth"]
pub type ctl_pfnMemoryGetBandwidth_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_mem_handle_t, arg2: *mut ctl_mem_bandwidth_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockGetProperties"]
pub type ctl_pfnOverclockGetProperties_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_oc_properties_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockWaiverSet"]
pub type ctl_pfnOverclockWaiverSet_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t) -> ctl_result_t>;
#[doc = "\n @brief Function-pointer for ctlOverclockGpuFrequencyOffsetGet"]
pub type ctl_pfnOverclockGpuFrequencyOffsetGet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: *mut f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockGpuFrequencyOffsetSet"]
pub type ctl_pfnOverclockGpuFrequencyOffsetSet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockGpuVoltageOffsetGet"]
pub type ctl_pfnOverclockGpuVoltageOffsetGet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: *mut f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockGpuVoltageOffsetSet"]
pub type ctl_pfnOverclockGpuVoltageOffsetSet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockGpuLockGet"]
pub type ctl_pfnOverclockGpuLockGet_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_oc_vf_pair_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockGpuLockSet"]
pub type ctl_pfnOverclockGpuLockSet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: ctl_oc_vf_pair_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockVramFrequencyOffsetGet"]
pub type ctl_pfnOverclockVramFrequencyOffsetGet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: *mut f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockVramFrequencyOffsetSet"]
pub type ctl_pfnOverclockVramFrequencyOffsetSet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockVramVoltageOffsetGet"]
pub type ctl_pfnOverclockVramVoltageOffsetGet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: *mut f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockVramVoltageOffsetSet"]
pub type ctl_pfnOverclockVramVoltageOffsetSet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockPowerLimitGet"]
pub type ctl_pfnOverclockPowerLimitGet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: *mut f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockPowerLimitSet"]
pub type ctl_pfnOverclockPowerLimitSet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockTemperatureLimitGet"]
pub type ctl_pfnOverclockTemperatureLimitGet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: *mut f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlOverclockTemperatureLimitSet"]
pub type ctl_pfnOverclockTemperatureLimitSet_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_device_adapter_handle_t, arg2: f64) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPowerTelemetryGet"]
pub type ctl_pfnPowerTelemetryGet_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_power_telemetry_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPciGetProperties"]
pub type ctl_pfnPciGetProperties_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_pci_properties_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPciGetState"]
pub type ctl_pfnPciGetState_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut ctl_pci_state_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumPowerDomains"]
pub type ctl_pfnEnumPowerDomains_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_pwr_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPowerGetProperties"]
pub type ctl_pfnPowerGetProperties_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_pwr_handle_t, arg2: *mut ctl_power_properties_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPowerGetEnergyCounter"]
pub type ctl_pfnPowerGetEnergyCounter_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_pwr_handle_t,
        arg2: *mut ctl_power_energy_counter_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPowerGetLimits"]
pub type ctl_pfnPowerGetLimits_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_pwr_handle_t, arg2: *mut ctl_power_limits_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlPowerSetLimits"]
pub type ctl_pfnPowerSetLimits_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_pwr_handle_t, arg2: *const ctl_power_limits_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlEnumTemperatureSensors"]
pub type ctl_pfnEnumTemperatureSensors_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ctl_device_adapter_handle_t,
        arg2: *mut u32,
        arg3: *mut ctl_temp_handle_t,
    ) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlTemperatureGetProperties"]
pub type ctl_pfnTemperatureGetProperties_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_temp_handle_t, arg2: *mut ctl_temp_properties_t) -> ctl_result_t,
>;
#[doc = "\n @brief Function-pointer for ctlTemperatureGetState"]
pub type ctl_pfnTemperatureGetState_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: ctl_temp_handle_t, arg2: *mut f64) -> ctl_result_t,
>;
